{"Argomenti/Algoritmi/Esercizi-di-programmazione-per-livello-e-tipologia":{"slug":"Argomenti/Algoritmi/Esercizi-di-programmazione-per-livello-e-tipologia","filePath":"Argomenti/Algoritmi/Esercizi di programmazione per livello e tipologia.md","title":"Esercizi di programmazione per livello e tipologia","links":["tags/include"],"tags":["include"],"content":"Eserciziari per prendere spunto\nEserciziario IP UniGe\nEsercizi Giacomin Università Brescia\nEsercizi sui fondamenti\nLivello base\nOperazioni aritmetiche di base su due numeri\nScrivere un programma che legge due numeri interi e ne stampa la somma, la differenza, il prodotto, il quoziente e il modulo.\nSwap\nScrivere un programma che scambia tra loro i valori di due variabili intere, lette da input, e stampa i valori prima e dopo lo scambio.\nPerimetro\nScrivere un programma che calcola perimetro e area di un rettangolo, dopo aver chiesto e letto i dati necessari.\nCalcolo età\nScrivere un programma che chiede all’utente in che anno è nato e stampa quanti anni ha.\nCalcolatore di minuti\nScrivere un programma che prende in input il numero di ore (compreso fra 0 e 23) e di minuti (compreso fra 0 e 59) e stampa in output il numero di minuti totali.\nArea del cerchio\nScrivere un programma che calcola circonferenza e area di un cerchio.\nMedia tra tre numeri\nScrivere un programma che calcola la media tra tre numeri.\nValutazione di variabili booleane\nScrivere un programma che, per ciascuna di queste frasi, stampa la frase seguita dal simbolo = e da un’espressione booleana che calcola il suo valore di verità.\n\n\n                  \n                  Suggerimento \n                  \n                \n\n\nPer stampare i booleani come true e false invece che come 1 e 0 si deve impostare a true il flag boolalpha di cout. Per fare questo si usa la stessa sintassi della stampa, ovvero si deve “stampare” un comando, come segue: std::cout &lt;&lt; std::boolalpha\n\n\n\n• tre è maggiore di uno\n• quattro diviso due è minore di zero\n• il carattere “zero” è uguale al valore zero\n• dieci mezzi è compreso fra zero escluso e dieci incluso (ossia: dieci mezzi è maggiore di zero E dieci mezzi è minore o uguale a dieci)\n• non è vero che tre è maggiore di due e minore di uno\n• tre minore di meno cinque implica sette maggiore di zero\nLivello avanzato\nStampa in ordine crescente senza confronto\nScrivere un programma che legge due numeri e li stampa in ordine crescente senza confrontarli.\n\n\n                  \n                  Suggerimento \n                  \n                \n\n\nSe alla media sottraggo la semidistanza, che valore ottengo?\n\n\n\nSwap senza variabile ausiliaria\nScrivere un programma che scambia fra loro i valori di due variabili senza usare variabili di appoggio.\n\n\n                  \n                  Suggerimento \n                  \n                \n\n\nL’or esclusivo, o XOR (in C++ l’operatore ^), gode di varie proprietà, tra cui la proprietà di simmetria\n\ncioè A^B  B^A – e la proprietà associativa – cioè (A^B)^C  A^(B^C). Inoltre, A^A 0 e A^0A per qualsiasi A, B e C.\n\n\n\n\nControllo del flusso (solo condizionale senza cicli)\nLivello base\nConfronto caratteri\nLeggere due caratteri e stampare “Uguali” se sono identici, altrimenti “Diversi”.\nConfronto numeri\nLeggere tre numeri interi e stamparli in ordine crescente.\nLivello medio\nTriangolo\nScrivere un programma che verifica se tre numeri interi dati in input possono essere i lati di un triangolo, cioè se nessuno di essi è maggiore della somma degli altri due o minore del valore assoluto della loro differenza.\nScegliere un colore tramite l’iniziale\nCalcolare il valore assoluto di un numero\nStampare il valore assoluto di un numero intero.\nPari o dispari\nVerificare se il numero inserito è pari o dispari.\nScegliere una cena attraverso un menù\nAll’utente viene presentato cosa scegliere come primo piatto, secondo e dolce tra 4 scelte disponibili per ogni portata. Alla fine viene stampato l’intero menù scelto.\nGiocare una mano di morra cinese\nSimulare un round di carta-forbice-sasso tra due giocatori e stampane l’esito.\nTermometro\nScrivere un programma che legge da input un numero intero temp e stampa:\n• “Freddo dannato” se temp è compreso fra −20 e 0\n• “Freddo” se temp è compreso fra 1 e 15\n• “Normale” se temp è compreso fra 16 e 23\n• “Caldo” se temp è compreso fra 24 e 30\n• “Caldo da morire” se temp è compreso fra 31 e 40\n• “Non ci credo, il termometro deve essere rotto” se temp è superiore a 40 o inferiore a −20\nVerificare su un anno è bisestile o no\nInserito in input un anno, calcolare se è bisestile o no.\nCalcolo degli anni bisestili:\nUn anno è bisestile se soddisfa le seguenti condizioni:\n\nÈ divisibile per 4.\nSe è divisibile per 100, deve essere anche divisibile per 400.\n\nNumero del mese\nStampare il nome del mese corrispondente a un numero da 1 a 12.\nLivello avanzato\nOrologio\nScrivere un programma che scrive in lettere i nomi italiani delle ore, approssimati per difetto a 15 minuti. Il programma deve prendere in input due valori interi, uno tra 1 e 12 (ore) e l’altro tra 0 e 59 (minuti) e se i valori dati in input non rispettano il vincolo stampa un messaggio di errore ed esce ritornando -1 come codice di errore. Se l’input è corretto, scrive “Sono le ore ” seguito dal valore delle ore (p.es. se è 11 scrive “undici”, ma se è 1 scrive “una”) e dal valore dei minuti, approssimato al quarto d’ora (p.es. se è 18 scrive “ e un quarto”, se è 39 scrive “ e mezza”, se è 55 scrive “ e tre quarti”; se è 0 invece non scrive niente). Infine, se i minuti non sono divisibili esattamente per 15, scrive “ circa”.\nEquazione di secondo grado\nScrivere un programma che prende in input tre numeri reali, a, b e c e stampa le radici dell’equazione di secondo grado ax2 + bx + c. Attenzione alle radici immaginarie.\n\n\n                  \n                  Suggerimento \n                  \n                \n\n\nRadice di x: sqrt(x); aggiungere in testa al file: include &lt;cmath&gt;\n\n\n\nAzienda spedizioni\nUn’azienda di spedizioni vuole sviluppare un sistema per calcolare il costo di spedizione di un pacco in base al suo peso e alla destinazione. Le regole per il calcolo del costo sono le seguenti:\nPeso del pacco:\n\nLeggero: se il peso è inferiore o uguale a 1 kg.\nMedio: se il peso è superiore a 1 kg ma inferiore o uguale a 5 kg.\nPesante: se il peso è superiore a 5 kg ma inferiore o uguale a 20 kg.\nMolto Pesante: se il peso è superiore a 20 kg.\n\nDestinazione:\n\nNazionale: Spedizioni all’interno del paese.\nInternazionale: Spedizioni verso l’estero.\n\nTariffe di spedizione:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLeggeroMedioPesanteMolto PesanteNazionaleInternazionaleNazionaleInternazionaleNazionaleInternazionaleNazionaleInternazionale5€10€10€20€15€30€25€50€\nL’algoritmo deve prendere in input il peso del pacco e la destinazione, e restituire il costo di spedizione.\nPromozioni nel negozio\nChiedi all’utente di inserire il prezzo di base di un prodotto, se il prodotto è in promozione (rispondendo con “sì” o “no”), e la categoria del prodotto (rispondendo con “A”, “B” o “C”). Se il prodotto è in promozione, applica uno sconto del 10% per i prodotti di categoria A, del 15% per i prodotti di categoria B e del 20% per i prodotti di categoria C. Successivamente, calcola il prezzo finale aggiungendo una tassa del 22% sul prezzo scontato (se applicabile) o sul prezzo di base.\nControllo del flusso (condizionale e cicli)\nLivello base\nCalcolare la media di n numeri letti da input\nCalcolare la media di n numeri letti da input, creare due varianti diverse, una col for e una col while o do-while.\nLettere maiuscole\nLeggere lettere maiuscole finché l’utente non inserisce un carattere non maiuscolo e stampare la più piccola.\nStampare una successione di numeri con una determinata regola\nIndovina la radice quadrata di un numero, riprovando finché non riesci\nL’utente inserisce un numero n. Poi gli viene chiesto di indovinarne la radice quadrata, finché non riesce. Non utilizzare funzioni per calcolare la radice quadrata.\nStampare il carattere fornito n volte\nInserire in input un carattere e un numero intero n, stampare il carattere n volte.\nLivello medio\nConteggio unario\nScrivi un programma che chiede dei numeri interi positivi. Il programma stampa tante barre | quante il numero inserito su una nuova riga. Ogni volta il programma chiede all’utente se vuole uscire o inserire un altro numero.\nMassimo K per somma di K\nScrivere un programma che riceva in ingresso un numero positivo N e determini il massimo intero K tale che la somma dei primi K interi sia minore o uguale a N.\nStampare i primi 5 anni bisestili a partire dall’anno inserito\nScrivi un algoritmo che chieda all’utente di inserire un numero intero positivo N e, successivamente, stampi i primi 5 anni bisestili strettamente superiori al numero acquisito.\nAd esempio: se inserisco l’anno 2198, l’output sarà: 2204 2208 2212 2216 2220\nCalcolare il MCM di due numeri\nInseriti due numeri, calcolare il loro MCM.\nCalcolare MCD di due numeri\nInseriti due numeri, calcolare il loro MCD.\nDeterminare se un numero è primo\nInserito un numero n determinare se è primo oppure no.\nConvertire numero da binario a decimale\nInserire un numero binario e convertirlo in decimale.\nConvertire numero da decimale a binario\nScrivere un programma che preso in input un numero in base 10 lo trasformi in binario.\nColore preferito\nScrivere un programma che chiede all’utente il suo colore preferito proponendo almeno 5 scelte di colori che iniziano con lettere diverse. Il colore viene scelto dall’utente con l’iniziale del colore, è indifferente se la lettera inserita è minuscola o maiuscola. Se la lettera inserita non corrisponde a nessun colore, il programma ricomincia da capo.\nGiocare più mani di morra cinese\nScrivere un programma che faccia giocare più mani di morra cinese e che chieda agli utenti se vogliono continuare o no dopo ogni mano. Stampare ogni volta il punteggio dei due giocatori e quando si termina stampare il vincitore.\nTrapezio di x\nScrivere un programma che legge due numeri interi positivi e stampa il trapezio rettangolo fatto di x con le basi lunghe quanto i numeri letti, e l’altezza pari alla differenza fra le basi più uno. Esempio con 5 e 9:\nxxxxx\nxxxxxx\nxxxxxxx\nxxxxxxxx\nxxxxxxxxx\n\nTriangolo di asterischi\nStampare un triangolo di asterischi con base di lunghezza data. Ad esempio se inserisco 3:\n*\n**\n***\n\nGenerare una serie di numeri di Fibonacci fino a un certo numero n\nInserire un numero n e scrivere i primi n numeri della sequenza di Fibonacci.\nLa sequenza di Fibonacci è una serie di numeri in cui ogni numero è la somma dei due numeri precedenti, a partire da 0 e 1. La sequenza inizia così: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34…\nIl primo numero della sequenza è 0, il secondo è 1. A partire dal terzo numero, ogni numero della sequenza è ottenuto sommando i due numeri precedenti. Ad esempio, il terzo numero è 1 (0 + 1), il quarto numero è 2 (1 + 1), il quinto numero è 3 (1 + 2), e così via.\nCalcolare il fattoriale di un numero\nDato un numero n calcolare il suo fattoriale. Nel caso si sappiano usare le funzioni, calcolarlo con la ricorsione.\nSomma, pari e dispari finché non inserisco zero\nScrivi un programma che chieda in input una serie di numeri interi positivi fino a quando l’utente inserisce il numero zero. Il programma deve calcolare e stampare la somma e la media di tutti i numeri inseriti (escludendo lo zero). Inoltre, il programma deve stampare il numero di numeri pari e dispari inseriti.\nMassimo e minimo finché non inserisco zero\nScrivi un programma che chieda in input una serie di numeri interi positivi fino a quando l’utente inserisce il numero zero. Il programma deve calcolare e stampare il massimo e il minimo.\nRombo di asterischi\nScrivere un programma che chiede all’utente un numero intero positivo n e stampa un rombo di asterischi che ha sulla diagonale 2\\times n+1 caratteri. Ad esempio su 8 stampa:\n        *\n       *** \n      *****\n     *******\n    *********\n   ***********\n  *************\n ***************\n*****************\n ***************\n  *************\n   ***********\n    *********\n     *******\n      *****\n       ***\n        *\n\nChe sulla diagonale ha 17 caratteri.\nSequenza di Collatz\nScrivere un algoritmo che:\n\nRichieda all’utente di inserire un numero intero positivo.\nCalcoli la sequenza di Collatz partendo da tale numero. Le regole sono:\n\nSe il numero è pari, dividilo per 2.\nSe il numero è dispari, moltiplicalo per 3 e aggiungi 1.\n\n\nContinua il calcolo fino a quando il numero non diventa 1.\nDurante l’esecuzione, il programma deve:\n\nStampare ogni valore della sequenza.\nContare il numero totale di passaggi necessari per raggiungere il 1.\nIndividuare e stampare il valore massimo raggiunto nella sequenza.\n\n\n\nSoluzione\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int n;\n    cout &lt;&lt; &quot;Inserisci un numero intero positivo: &quot;;\n    cin &gt;&gt; n;\n    \n    if (n &lt;= 0) {\n        cout &lt;&lt; &quot;Il numero deve essere positivo.&quot; &lt;&lt; endl;\n        return 1;\n    }\n    \n    int steps = 0;\n    int maxVal = n;\n    \n    cout &lt;&lt; &quot;Sequenza: &quot; &lt;&lt; n;\n    \n    while (n != 1) {\n        if (n % 2 == 0)\n            n = n / 2;\n        else\n            n = n * 3 + 1;\n        \n        if (n &gt; maxVal)\n            maxVal = n;\n        \n        cout &lt;&lt; &quot; &quot; &lt;&lt; n;\n        steps++;\n    }\n    \n    cout &lt;&lt; &quot;\\nNumero totale di passaggi: &quot; &lt;&lt; steps &lt;&lt; endl;\n    cout &lt;&lt; &quot;Valore massimo raggiunto: &quot; &lt;&lt; maxVal &lt;&lt; endl;\n    \n    return 0;\n}\nDivisori\nRealizzare uno schema di flusso che acquisisca da tastiera un numero intero positivo N e ne determini:\n\ntutti i divisori (eccetto sé stesso)\nil numero totale di divisori\nla somma di tutti i divisori\nil divisore più grande\nla classificazione di N come perfetto, abbondante o difettivo.\n\nLivello avanzato\nNumero palindromo\nInserito un numero n verificare se è palindromo o no.\nScomposizione in fattori primi\nScrivere un programma che chiede all’utente un numero intero maggiore di 1 e ne stampa la scomposizione in fattori primi. Ad esempio su 392 stampa 392 = 2^3 x 7^ 2.\nNumero di Armstrong\nVerificare se un numero intero positivo dato in input è un numero di Armstrong. Un numero di Armstrong è uguale alla somma delle potenze n-esime delle cifre che lo compongono.\nAd esempio 153=1^3+5^3+3^3 è un numero di Armstrong.\nNumeri romani\nScrivere un programma che legge un numero intero positivo compreso tra 1 e 3000 e lo stampa in notazione romana.\nInvertitore di numeri senza array\nScrivere un programma che chiede all’utente un numero intero positivo e lo stampa al contrario. Ad esempio 27458 diventa 85472.\nVarianti\nAggiungere il supporto ai numeri negativi.\nProblemi complessi (per verifiche)\nMinigioco a vita\nL’utente inserisce i punti vita del personaggio (che devono essere strettamente maggiori di zero). A quel punto comincia un prototipo di gioco che dura 5 turni. Ad ogni turno l’utente vede la vita attuale del personaggio e quella massima inserita all’inizio (ad esempio se la vita attuale e’ 20 e quella iniziale 50: 20/50) L’utente ogni turno puo’ scegliere una mossa: Far combattere il personaggio e perdere 10 punti vita o far riposare il personaggio e guadagnare 20 punti vita. Se la vita del personaggio scende a 0 o sotto, stampa un messaggio “Sei morto” e termina il gioco. Se la vita del personaggio arriva o sale oltre i punti vita iniziali, stampa il messaggio “Completamente ripristinato” e imposta la sua vita attuale uguale a quella massima. Quando finiscono i turni e non sei morto, stampa il messaggio “Sei sopravvissuto”.\nAzienda spedizioni\nScrivere un programma che gestisce le spedizioni di un’azienda. Il programma dovrà:\n\n\nChiedere all’utente di inserire il numero di pacchi da spedire (N, intero positivo).\n\n\nPer ciascun pacco (da 1 a N):\n\nRichiedere il peso del pacco (in kg, valore positivo). Se il valore inserito non è positivo, richiedere nuovamente l’inserimento.\nRichiedere la destinazione, che può essere:\n\nN (o n) per spedizione nazionale\nI (o i) per spedizione internazionale\nSe il valore inserito non corrisponde a nessuna delle opzioni, richiedere nuovamente l’inserimento.\n\n\n\n\n\nDeterminare la categoria del pacco in base al peso:\n\nLeggero: peso ≤ 1 kg\nMedio: 1 &lt; peso ≤ 5 kg\nPesante: 5 &lt; peso ≤ 20 kg\nMolto Pesante: peso &gt; 20 kg\n\n\n\nCalcolare il costo di spedizione per ciascun pacco in base alla seguente tabella:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCategoriaNazionaleInternazionaleLeggero5€10€Medio10€20€Pesante15€30€Molto Pesante25€50€\n\n\nPer ogni pacco, stampare:\n\nNumero del pacco\nPeso inserito\nDestinazione (stampare “Nazionale” o “Internazionale”)\nCategoria determinata\nCosto di spedizione\n\nSe il costo per un pacco supera 30€, stampare accanto al costo anche il messaggio: “Pacco costoso”.\n\n\nAl termine, stampare:\n\nIl costo totale di tutte le spedizioni.\nLa media del costo per pacco.\n\n\n\nUtilizzare cicli e strutture condizionali per gestire l’inserimento e la validazione dei dati, il calcolo delle tariffe e la stampa dei risultati.\nCassa negozio (Verifica fila A)\nRealizza un programma che simuli il funzionamento della cassa di un negozio.\nIl programma deve:\n\nRichiedere all’utente il numero di clienti.\nPer ciascun cliente, chiedere il numero di articoli acquistati.\nPer ogni articolo, acquisire il prezzo e la quantità.\nCalcolare il totale speso dal cliente e, se supera 100 euro, applicare uno sconto del 10% (facendolo notare).\nVisualizzare il totale speso da ogni cliente.\nAl termine, mostrare il totale incassato nella giornata e identificare il cliente che ha speso di più.\n\nSoluzione\n#include &lt;iostream&gt;\n#include &lt;climits&gt;\nusing namespace std;\n \nint main() {\n    int clienti;\n    cout&lt;&lt;&quot;Inserisci il numero di clienti&quot;&lt;&lt;endl;\n    do{\n        cin&gt;&gt;clienti;\n    }while(clienti&lt;=0);\n \n    int num_articoli;\n    int totale_spesa_giornata=0;\n    int spesa_max = INT_MIN;\n    int cliente_max;\n \n    for(int i=0; i&lt;clienti; i++){\n        cout&lt;&lt;&quot;Inserisci il numero di articoli acquistati per il cliente &quot;&lt;&lt;i+1&lt;&lt;endl;\n        do{\n            cin&gt;&gt;num_articoli;\n        }while(num_articoli&lt;=0);\n \n        int totale_spesa_cliente = 0;\n \n        for(int j=0; j&lt;num_articoli; j++){\n            int prezzo, quantita;\n            cout&lt;&lt;&quot;Cliente &quot;&lt;&lt;i+1&lt;&lt;&quot;: inserisci il prezzo dell&#039;articolo &quot;&lt;&lt;j+1&lt;&lt;endl;\n            do{\n                cin&gt;&gt;prezzo;\n \n            }while(prezzo&lt;=0);\n \n            cout&lt;&lt;&quot;Cliente &quot;&lt;&lt;i+1&lt;&lt;&quot;: inserisci la quantita&#039; dell&#039;articolo &quot;&lt;&lt;j+1&lt;&lt;endl;\n            do{\n                cin&gt;&gt;quantita;\n            }while(quantita&lt;=0);\n \n            totale_spesa_cliente += prezzo * quantita;\n        }\n        if(totale_spesa_cliente&gt;100){\n            totale_spesa_cliente = totale_spesa_cliente - totale_spesa_cliente * 0.10;\n            cout&lt;&lt;&quot;Applico sconto del 10%&quot;&lt;&lt;endl;\n        }\n        cout&lt;&lt;&quot;Totale spesa Cliente &quot;&lt;&lt;i+1&lt;&lt;&quot;: &quot;&lt;&lt;totale_spesa_cliente&lt;&lt;endl;\n        totale_spesa_giornata+=totale_spesa_cliente;\n        if(totale_spesa_cliente&gt;spesa_max){\n            spesa_max = totale_spesa_cliente;\n            cliente_max = i+1;\n        }\n    }\n    cout&lt;&lt;&quot;Guadagno totale giornata: &quot;&lt;&lt;totale_spesa_giornata&lt;&lt;endl;\n    cout&lt;&lt;&quot;Cliente che ha speso di più: Cliente &quot;&lt;&lt;cliente_max&lt;&lt;&quot;con una spesa di &quot;&lt;&lt;spesa_max&lt;&lt;endl;\n \n    return 0;\n}\n \nCorsa a tappe (Verifica fila B)\nRealizza un programma che simuli una gara di corsa su tappe.\nIl programma deve:\n\nRichiedere all’utente il numero totale di partecipanti.\nPer ciascun partecipante:\n\nRichiedere il numero di tappe della gara.\nPer ogni tappa, acquisire il tempo impiegato (in minuti).\nCalcolare il tempo totale impiegato dal partecipante per completare la gara.\nSe il tempo totale è inferiore a una soglia prefissata (ad esempio 180 minuti), visualizzare un messaggio di congratulazioni.\n\n\nAl termine, visualizzare il tempo totale di gara per ogni partecipante.\nIdentificare il partecipante che ha completato la gara nel tempo minore (cioè il vincitore), mostrando il suo numero d’ordine e il tempo totale impiegato.\n\nSoluzione\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int numParticipants;\n    cout &lt;&lt; &quot;Inserisci il numero totale di partecipanti: &quot;;\n    cin &gt;&gt; numParticipants;\n    \n    int winner = 0;\n    int minTotalTime = 0;\n    bool firstParticipant = true;\n    \n    // Elaborazione di ogni partecipante\n    for (int i = 1; i &lt;= numParticipants; i++) {\n        int numStages;\n        cout &lt;&lt; &quot;\\nPartecipante &quot; &lt;&lt; i &lt;&lt; &quot; - Inserisci il numero di tappe: &quot;;\n        cin &gt;&gt; numStages;\n        \n        int totalTime = 0;\n        // Elaborazione di ogni tappa per il partecipante corrente\n        for (int j = 1; j &lt;= numStages; j++) {\n            int stageTime;\n            cout &lt;&lt; &quot;Tappa &quot; &lt;&lt; j &lt;&lt; &quot; - Inserisci il tempo impiegato (in minuti): &quot;;\n            cin &gt;&gt; stageTime;\n            totalTime += stageTime;\n        }\n        \n        // Messaggio di congratulazioni se il tempo totale è inferiore a 180 minuti\n        if (totalTime &lt; 180) {\n            cout &lt;&lt; &quot;Complimenti, hai completato la gara in meno di 180 minuti!&quot; &lt;&lt; endl;\n        }\n        \n        // Visualizza il tempo totale del partecipante\n        cout &lt;&lt; &quot;Partecipante &quot; &lt;&lt; i &lt;&lt; &quot; - Tempo totale: &quot; &lt;&lt; totalTime &lt;&lt; &quot; minuti.&quot; &lt;&lt; endl;\n        \n        // Aggiorna il vincitore se necessario\n        if (firstParticipant || totalTime &lt; minTotalTime) {\n            minTotalTime = totalTime;\n            winner = i;\n            firstParticipant = false;\n        }\n    }\n    \n    // Visualizza il vincitore della gara\n    cout &lt;&lt; &quot;\\nIl vincitore e&#039; il partecipante &quot; &lt;&lt; winner \n         &lt;&lt; &quot; con un tempo totale di &quot; &lt;&lt; minTotalTime &lt;&lt; &quot; minuti.&quot; &lt;&lt; endl;\n    \n    return 0;\n}\n \nCollatz con tentativi e numero max (Verifica fila A2)\nScrivi un programma che esegua le seguenti operazioni:\n\nL’utente inserisce un numero intero positivo.\nIn ogni iterazione:\n\nSe il numero è pari, lo divide per 2.\nSe il numero è dispari, lo moltiplica per 3 e aggiunge 1.\n\n\nIl processo continua fino a quando il numero diventa 1 oppure sono state eseguite 50 iterazioni.\nAd ogni iterazione, il programma stampa il valore corrente.\nAl termine, il programma visualizza se il numero 1 è stato raggiunto e quante iterazioni sono state effettuate oppure un messaggio che indica il mancato raggiungimento di 1 entro il limite. Stampa anche il valore massimo ottenuto durante il processo.\n\nSoluzione\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    long long n;\n    cout &lt;&lt; &quot;Inserisci un numero intero positivo: &quot;;\n    cin &gt;&gt; n;\n    \n    if(n &lt;= 0) {\n        cout &lt;&lt; &quot;Il numero deve essere positivo.&quot; &lt;&lt; endl;\n        return 1;\n    }\n    \n    int iterations = 0;\n    long long maxVal = n;\n    \n    cout &lt;&lt; &quot;Valore iniziale: &quot; &lt;&lt; n &lt;&lt; endl;\n    \n    while(n != 1 &amp;&amp; iterations &lt; 50) {\n        if(n % 2 == 0)\n            n = n / 2;\n        else\n            n = n * 3 + 1;\n        \n        if(n &gt; maxVal)\n            maxVal = n;\n        \n        iterations++;\n        cout &lt;&lt; &quot;Iterazione &quot; &lt;&lt; iterations &lt;&lt; &quot;: &quot; &lt;&lt; n &lt;&lt; endl;\n    }\n    \n    if(n == 1)\n        cout &lt;&lt; &quot;Il numero 1 è stato raggiunto in &quot; &lt;&lt; iterations &lt;&lt; &quot; iterazioni.&quot; &lt;&lt; endl;\n    else\n        cout &lt;&lt; &quot;Il numero 1 non è stato raggiunto entro 50 iterazioni.&quot; &lt;&lt; endl;\n    \n    cout &lt;&lt; &quot;Il numero massimo ottenuto è: &quot; &lt;&lt; maxVal &lt;&lt; endl;\n    \n    return 0;\n}\nNumero massimo di divisori (Verifica fila B2)\nScrivi un programma che esegua le seguenti operazioni:\n\nL’utente inserisce un numero intero positivo N.\nPer ogni numero da 1 a N:\n\nCalcola quanti divisori ha il numero i.\nStampa il numero i insieme al conteggio dei suoi divisori.\n\n\nAl termine, il programma visualizza il numero che ha il maggior numero di divisori e il relativo conteggio.\n\nSoluzione\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int N;\n    cout &lt;&lt; &quot;Inserisci un numero intero positivo: &quot;;\n    cin &gt;&gt; N;\n    \n    if (N &lt;= 0) {\n        cout &lt;&lt; &quot;Il numero deve essere positivo.&quot; &lt;&lt; endl;\n        return 1;\n    }\n    \n    int maxDivisori = 0;\n    int numeroMax = 0;\n    \n    // Ciclo per ogni numero da 1 a N\n    for (int i = 1; i &lt;= N; i++) {\n        int divisori = 0;\n        \n        // Ciclo per contare i divisori di i\n        for (int j = 1; j &lt;= i; j++) {\n            if (i % j == 0) {\n                divisori++;\n            }\n        }\n        \n        // Stampa il numero e il suo conteggio di divisori\n        cout &lt;&lt; &quot;Numero &quot; &lt;&lt; i &lt;&lt; &quot; ha &quot; &lt;&lt; divisori &lt;&lt; &quot; divisori.&quot; &lt;&lt; endl;\n        \n        // Aggiorna il massimo se necessario\n        if (divisori &gt; maxDivisori) {\n            maxDivisori = divisori;\n            numeroMax = i;\n        }\n    }\n    \n    cout &lt;&lt; &quot;Il numero con il maggior numero di divisori e&#039; &quot; &lt;&lt; numeroMax \n         &lt;&lt; &quot; con &quot; &lt;&lt; maxDivisori &lt;&lt; &quot; divisori.&quot; &lt;&lt; endl;\n    \n    return 0;\n}\nSomma di numeri primi in serie\nScrivi un programma che esegua le seguenti operazioni:\n\nL’utente inserisce una serie di numeri finché non inserisce il numero zero.\nCalcola la somma di tutti i numeri primi presenti nella serie inserita\n\nStrutture dati di base\nEsercizi di riscaldamento\ncreaArrayInt\nCrea un array di prova con elementi di tipo int. Scrivere un programma che dichiara un array di N interi e lo popola assegnando ad ogni elemento il valore calcolato come N‑i.\ncreaArrayFloat\nCrea un array di float. Scrivere un programma uguale al precedente, ma che lavora su array di float.\nstampaArrayInt\nStampa un array di interi. Scrivere un programma che, dato un array di interi e la sua lunghezza N, stampi tutti gli elementi.\nstampaArrayFloat\nStampa un array di float. Scrivere un programma uguale al precedente, ma che lavora su array di float.\nleggiArrayInt\nLeggi un array di int da tastiera. Scrivere un programma che dichiara un array di N interi e lo popola leggendo i valori da input.\nEsercizi di base\nTrova massimo e conteggio\nScrivere un programma che legge N interi in un array e stampa il valore massimo contenuto, insieme al numero di volte in cui questo appare.\nConta numeri pari e dispari\nScrivere un programma che legge N interi in un array e, con un opportuno messaggio, stampa il numero P dei numeri pari e il numero D di quelli dispari presenti.\nreverse\nScrivere un programma che legge N interi in un array denominato “source” e copia in un array “dest” gli elementi di “source” in ordine inverso. Successivamente, stampare entrambi gli array (lasciando una riga vuota tra le stampe).\nCrivello di Eratostene\nScrivere un programma che, utilizzando l’algoritmo del Crivello di Eratostene, trova i numeri primi minori di 1000. L’algoritmo prevede di inizializzare un array di booleani a true, marcare i multipli di ogni numero partendo da 2 e stampare i numeri che risultano primi.\nArray bidimensionale (M×N riempito di 0)\nScrivere un programma che definisce due costanti, M pari a 5 e N pari a 8, dichiara un array bidimensionale di dimensioni M×N e lo riempie interamente di zeri.\nProdotto di matrici\nDate due matrici compatibili al prodotto di matrici, eseguirne il prodotto riga per colonna.\nTavola pitagorica\nScrivere un programma che definisce una costante N pari a 10, dichiara un array bidimensionale per la tavola pitagorica (dimensioni N×N) e lo riempie in modo tale che l’elemento (i, j) contenga il prodotto tra i+1 e j+1. Successivamente, il programma chiede all’utente una coppia di valori compresi tra 1 e 10 e restituisce il loro prodotto, ottenuto consultando la tavola come look‑up table.\nEsercizi più avanzati\npalyndrome\nScrivere un programma che legge un array e calcola un valore booleano che vale true se l’array è palindromo (cioè, se gli elementi letti da sinistra verso destra sono uguali a quelli letti da destra verso sinistra). Il programma deve poi stampare un messaggio che comunichi il risultato.\n\n\n                  \n                  Suggerimento \n                  \n                \n\n\nUtilizzare il programma reverse per confrontare l’array originale con quello invertito.\n\n\n\nFrequenza dei valori\nScrivere un programma che legge un array di interi e stampa la frequenza di ogni valore contenuto, ovvero il numero di volte che ciascun valore compare.\nSecondo valore più elevato\nScrivere un programma che legge un array di interi e stampa il secondo valore più elevato presente nell’array.\nOrdinamento con copia in un array ordinato\nScrivere un programma che legge un array di interi denominato “source” e copia il suo contenuto, ordinato in modo crescente, in un altro array “dest”. Infine, stampare l’array ordinato.\nOrdinamento in modo crescente (in-place)\nScrivere un programma che legge un array di interi, riordina i suoi elementi in modo crescente senza utilizzare un array ausiliario, e lo stampa.\nreverseinPlace\nScrivere un programma che legge un array di float e inverte l’ordine dei valori contenuti, senza utilizzare un array ausiliario.\n\n\n                  \n                  Suggerimento \n                  \n                \n\n\nBasta eseguire degli swap fra le celle poste alla stessa distanza dagli estremi dell’array.\n\n\n\nRimozione dei duplicati contigui (con array ausiliario)\nScrivere un programma che legge un array di interi positivi e, scorrendolo da inizio a fine, elimina tutte le occorrenze contigue duplicate, lasciando una sola occorrenza per ciascuna sequenza. Gli elementi rimanenti devono essere azzerati; infine, il programma stampa tutti gli elementi non zero.\n(Esempio: da “1 1 1 2 3 3 4” si ottiene “1 2 3 4 0 0 0”.)\nRimozione dei duplicati contigui in-place\nScrivere un programma che realizza quanto richiesto nell’esercizio precedente senza utilizzare array ausiliari, ovvero modificando l’array in-place.\nTavola pitagorica compatta\nScrivere un programma che usa un array monodimensionale per rappresentare la tavola pitagorica in modo compatto, sfruttando la simmetria (gli elementi sopra la diagonale sono speculari a quelli sotto). Il numero di elementi necessari è N(N+1)/2 e il comportamento del programma deve essere identico a quello dell’esercizio tradizionale sulla tavola pitagorica.\nTris\nImplementa il gioco del tris.\nApprofondimenti – Esercizi di riscaldamento\nSequentialSearch\nScrivere un programma che effettua la ricerca di un elemento intero in un array di 15 interi, restituendo la posizione in cui è trovato oppure un messaggio di “non trovato”.\nBinarySearch\nScrivere un programma che effettua la ricerca binaria di un elemento intero in un array di 15 interi ordinati.\n\n\n                  \n                  Suggerimento \n                  \n                \n\n\nLa ricerca binaria funziona solo su array ordinati.\n\n\n\nSelectionSort\nScrivere un programma che ordina un array utilizzando l’algoritmo Selection Sort, che seleziona iterativamente l’elemento minimo e lo scambia con quello in posizione corrente.\nOrdine decrescente (20 numeri)\nScrivere un programma che prende in input 20 numeri interi e li stampa in ordine decrescente.\nreadMatrix\nScrivere un programma che permette di riempire una matrice di interi di dimensioni M×N (con M = 3 e N = 4) leggendo i valori da input.\nprintMatrix\nScrivere un programma che stampa su output una matrice di interi di dimensioni M×N (con M = 3 e N = 4).\nApprofondimenti – Esercizi di base\nModifica degli esercizi di ricerca con conteggio accessi\nModificare gli esercizi di SequentialSearch e BinarySearch in modo da contare il numero di accessi all’array e stampare tale conteggio al termine dell’esecuzione.\nApprofondimenti – Esercizi più avanzati\nRappresentazione binaria in un array\nDato un numero intero positivo minore di 2N, scrivere un programma che memorizza la sua rappresentazione binaria in un array di lunghezza N e stampa il vettore risultante.\nshiftLeft\nScrivere un programma che esegue lo shift verso sinistra degli elementi di un vettore: ogni elemento viene spostato nella posizione immediatamente precedente, il primo elemento viene eliminato e l’ultimo sostituito da 0.\n(Esempio: [1, 10, 15, 18] diventa [10, 15, 18, 0]).\nrotateRight\nScrivere un programma che esegue la rotazione verso destra degli elementi di un vettore: ogni elemento viene spostato nella posizione immediatamente successiva, con il primo elemento sostituito dall’ultimo.\n(Esempio: [1, 10, 15, 18] diventa [18, 1, 10, 15]).\nshiftN/rotateN\nModificare i programmi shiftLeft e rotateRight per ottenere shiftN e rotateN che, dato un numero intero N (positivo o negativo), traslano o ruotano il vettore di |N| posizioni.\n\n\n                  \n                  Suggerimento \n                  \n                \n\n\nPer rotate, se |N| è maggiore della lunghezza dell’array, usare N modulo lunghezza.\n\n\n\nGioco del tris\nScrivere un programma che implementa il gioco del tris, utilizzando una matrice 3×3 per rappresentare la griglia e gestendo il turno alternato di due giocatori umani.\nGioco “Forza 4”\nScrivere un programma che implementa il gioco “Forza 4”.\nTris con computer\nModificare il programma del tris in modo che uno dei giocatori sia il computer, che sceglie casualmente tra le caselle libere.\nMastermind\nScrivere un programma che implementa il gioco “Mastermind”, seguendo le regole e le modalità tipiche di questo gioco.\nFunzioni e modularizzazione\nDistributore automatico\nImplementare un distributore automatico di merendine.\nGestione magazzino\nCrea un array  che gestisca l’inventario di un magazzino utilizzando un array statico di struct chiamate “oggetto”. La struct dovrà contenere campi quali codice identificativo, nome, quantità e prezzo. Il programma dovrà prevedere funzioni separate per inserire un nuovo oggetto, ricercare e stampare le informazioni di un oggetto tramite il codice, visualizzare tutti gli oggetti presenti nell’inventario e cancellare un oggetto, aggiornando di conseguenza l’array. Modularizzare quanto più possibile il codice utilizzando le funzioni.\nSoluzione\n#include&lt;iostream&gt;\n \nusing namespace std;\n \n  \n \nstruct oggetto{\n \nint id=-1;\n \nstring nome;\n \nint qta;\n \nfloat prezzo;\n \n};\n \n  \n \nconst int dimensione=10;\n \noggetto oggetti[dimensione];\n \n  \n \nbool isEmpty(oggetto oggetto);\n \nbool inserisciOggetto(oggetto oggetto);\n \nvoid stampaOggetto(oggetto oggetto);\n \nvoid visualizzaOggetti();\n \nvoid stampaOggettoId(int id);\n \nvoid eliminaOggettoId(int id);\n \n  \n  \n  \n \nint main(int argc, const char** argv) {\n \noggetto o1,o2;\n \n  \n \no1.id=1;\n \no1.nome=&quot;focaccia&quot;;\n \no1.qta=3;\n \no1.prezzo=2;\n \n  \n \no2.id=2;\n \no2.nome=&quot;pizza&quot;;\n \no2.qta=4;\n \no2.prezzo=5;\n \n  \n \ninserisciOggetto(o1);\n \ninserisciOggetto(o2);\n \n  \n \n// stampaOggettoId(2);\n \neliminaOggettoId(2);\n \nstampaOggettoId(2);\n \nreturn 0;\n \n}\n \n  \n \nbool isEmpty(oggetto oggetto){\n \nreturn oggetto.id == -1;\n \n}\n \n  \n \nbool inserisciOggetto(oggetto oggetto){\n \nfor (int i=0; i&lt;dimensione; i++){\n \nif (isEmpty(oggetti[i])){\n \noggetti[i] = oggetto;\n \nreturn true;\n \n}\n \n}\n \nreturn false;\n \n}\n \n  \n \nint ricercaOggetto(int id){\n \nfor (int i=0; i&lt;dimensione; i++){\n \nif(oggetti[i].id == id){\n \nreturn i;\n \n}\n \n}\n \nreturn -1;\n \n}\n \n  \n \nvoid eliminaOggettoId(int id){\n \nint indiceOggetto = ricercaOggetto(id);\n \nif(indiceOggetto &gt;= 0){\n \noggetti[indiceOggetto].id = -1;\n \n}\n \n}\n \n  \n \nvoid stampaOggettoId(int id){\n \nint indiceOggetto = ricercaOggetto(id);\n \nif(indiceOggetto &gt;= 0){\n \nstampaOggetto(oggetti[indiceOggetto]);\n \n}\n \n}\n \n  \n \nvoid stampaOggetto(oggetto oggetto){\n \ncout&lt;&lt;&quot;Id oggetto:&quot;&lt;&lt;oggetto.id&lt;&lt;endl;\n \ncout&lt;&lt;&quot;Nome oggetto:&quot;&lt;&lt;oggetto.nome&lt;&lt;endl;\n \ncout&lt;&lt;&quot;Quantita&#039;:&quot;&lt;&lt;oggetto.qta&lt;&lt;endl;\n \ncout&lt;&lt;&quot;Prezzo:&quot;&lt;&lt;oggetto.prezzo&lt;&lt;&quot;€&quot;&lt;&lt;endl;\n \n}\n \n  \n \nvoid visualizzaOggetti(){\n \nfor (oggetto oggetto:oggetti){\n \nif(!isEmpty(oggetto)){\n \nstampaOggetto(oggetto);\n \ncout&lt;&lt;endl;\n \n}\n \n}\n \n}\nOperazioni statistiche su array di struct\nCrea un programma che gestisca i punteggi di un gioco di un gruppo di persone. Per ogni persona deve essere registrato il nome e il punteggio. Implementa le funzioni per:\n\nInserire un nuovo nome e punteggio\nModificare un punteggio esistente\nCercare e restituire una persona\nEliminare una persona\nStampare tutti i dati\nStampare la somma dei punteggi\nStampare la media dei punteggi\nStampare la persona con punteggio maggiore e il suo punteggio\n\nQuiz\nScrivi un programma che implementi un quiz a scelta multipla basato su un array di struct. Ogni elemento dell’array rappresenta una domanda e contiene:\n\nil testo della domanda\nun array di 3 possibili risposte\nun indice (0, 1 o 2) della risposta corretta\n\nIl programma deve:\n\nDefinire la struct Question con i campi richiesti.\nCreare un array di almeno 5 domande (hard‑coded), includendo per ciascuna il testo e le 3 opzioni. Potete utilizzare questo codice per inizializzare:\n\n   array&lt;Question, 5&gt; quiz = {{\n        {\n            &quot;Qual è il colore del cielo in una giornata serena?&quot;,\n            {&quot;Rosso&quot;, &quot;Verde&quot;, &quot;Blu&quot;},\n            2\n        },\n        {\n            &quot;Quale animale abbaia?&quot;,\n            {&quot;Gatto&quot;, &quot;Cane&quot;, &quot;Uccello&quot;},\n            1\n        },\n        {\n            &quot;Quale di questi linguaggi è compilato?&quot;,\n            {&quot;C++&quot;, &quot;JavaScript&quot;, &quot;Python&quot;},\n            0\n        },\n        {\n            &quot;Quale pianeta è il terzo dal Sole?&quot;,\n            {&quot;Venere&quot;, &quot;Terra&quot;, &quot;Marte&quot;},\n            1\n        },\n        {\n            &quot;Quale stagione segue la primavera?&quot;,\n            {&quot;Estate&quot;, &quot;Inverno&quot;, &quot;Autunno&quot;},\n            0\n        }\n    }};\n\nPer ogni domanda:\n\nstampare il testo e le 3 opzioni numerate 1–3\nleggere la scelta dell’utente (gestire input fuori range)\nverificare se la scelta corrisponde all’indice corretto\naggiornare il punteggio\n\n\nAl termine, stampare il numero di risposte corrette su totale.\n\nSoluzione\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;array&gt;\n#include &lt;limits&gt;\n \nusing namespace std;\n \n// struct che rappresenta una domanda a scelta multipla\nstruct Question {\n    string text;\n    array&lt;string, 3&gt; options;\n    int correctIndex; // 0-based\n};\n \n// chiede all’utente di rispondere a q e restituisce 1 se corretto, 0 altrimenti\nint askQuestion(const Question&amp; q) {\n    cout &lt;&lt; q.text &lt;&lt; &quot;\\n&quot;;\n    for (int i = 0; i &lt; 3; ++i) {\n        cout &lt;&lt; &quot;  &quot; &lt;&lt; (i + 1) &lt;&lt; &quot;) &quot; &lt;&lt; q.options[i] &lt;&lt; &quot;\\n&quot;;\n    }\n \n    int choice;\n    while (true) {\n        cout &lt;&lt; &quot;Your answer (1-3): &quot;;\n        if (cin &gt;&gt; choice &amp;&amp; choice &gt;= 1 &amp;&amp; choice &lt;= 3) {\n            break;\n        }\n        cin.clear();\n        cin.ignore(numeric_limits&lt;streamsize&gt;::max(), &#039;\\n&#039;);\n        cout &lt;&lt; &quot;Invalid input. Please enter a number between 1 and 3.\\n&quot;;\n    }\n \n    return (choice - 1 == q.correctIndex) ? 1 : 0;\n}\n \nint main() {\n    array&lt;Question, 5&gt; quiz = {{\n        {\n            &quot;Qual è il colore del cielo in una giornata serena?&quot;,\n            {&quot;Rosso&quot;, &quot;Verde&quot;, &quot;Blu&quot;},\n            2\n        },\n        {\n            &quot;Quale animale abbaia?&quot;,\n            {&quot;Gatto&quot;, &quot;Cane&quot;, &quot;Uccello&quot;},\n            1\n        },\n        {\n            &quot;Quale di questi linguaggi è compilato?&quot;,\n            {&quot;C++&quot;, &quot;JavaScript&quot;, &quot;Python&quot;},\n            0\n        },\n        {\n            &quot;Quale pianeta è il terzo dal Sole?&quot;,\n            {&quot;Venere&quot;, &quot;Terra&quot;, &quot;Marte&quot;},\n            1\n        },\n        {\n            &quot;Quale stagione segue la primavera?&quot;,\n            {&quot;Estate&quot;, &quot;Inverno&quot;, &quot;Autunno&quot;},\n            0\n        }\n    }};\n \n    int score = 0;\n    cout &lt;&lt; &quot;Benvenuto al quiz! Rispondi digitando 1, 2 o 3.\\n\\n&quot;;\n \n    for (size_t i = 0; i &lt; quiz.size(); ++i) {\n        cout &lt;&lt; &quot;Domanda &quot; &lt;&lt; (i + 1) &lt;&lt; &quot;:\\n&quot;;\n        score += askQuestion(quiz[i]);\n        cout &lt;&lt; &quot;\\n&quot;;\n    }\n \n    cout &lt;&lt; &quot;Hai risposto correttamente a &quot; &lt;&lt; score\n         &lt;&lt; &quot; domande su &quot; &lt;&lt; quiz.size() &lt;&lt; &quot;.\\n&quot;;\n \n    return 0;\n}\nTeatro\nScrivi un programma che gestisca la prenotazione di posti in un teatro con 5 file e 10 colonne, usando un array bidimensionale di Seat. Ogni Seat deve contenere un campo SeatCategory category (Standard, Premium, VIP) e un campo std::string name. Il programma deve fornire le funzioni:\n\nfunzione per verificare se il posto è già prenotato\nfunzione per prenotare il posto se non è già prenotato\nfunzione per stampare l’elenco di prenotazioni con i nomi e il tipo di posto prenotato, oltre che il totale di posti prenotati\nfunzione per cancellare la prenotazione se presente\nfunzione per stampare la pianta mostrando per ogni posto [V]/[P]/[S] se libero o [X] se occupato\n\nIl main() deve inizializzare la sala, poi mostrare un menu ripetuto con opzioni\n\nPrenota posto\nCancella prenotazione\nVisualizza piantina\nvisualizza prenotazioni\nEsci e invocare le funzioni corrispondenti fino a uscita.\n\nSoluzione\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\nenum SeatCategory { Standard, Premium, VIP };\nconst int ROWS = 5;\nconst int COLS = 10;\nstruct Seat { SeatCategory category; string name; };\nSeat hall[ROWS][COLS] = {\n    { {VIP,&quot;&quot;},{VIP,&quot;&quot;},{VIP,&quot;&quot;},{VIP,&quot;&quot;},{VIP,&quot;&quot;},{VIP,&quot;&quot;},{VIP,&quot;&quot;},{VIP,&quot;&quot;},{VIP,&quot;&quot;},{VIP,&quot;&quot;} },\n    { {Premium,&quot;&quot;},{Premium,&quot;&quot;},{Premium,&quot;&quot;},{Premium,&quot;&quot;},{Premium,&quot;&quot;},{Premium,&quot;&quot;},{Premium,&quot;&quot;},{Premium,&quot;&quot;},{Premium,&quot;&quot;},{Premium,&quot;&quot;} },\n    { {Premium,&quot;&quot;},{Premium,&quot;&quot;},{Premium,&quot;&quot;},{Premium,&quot;&quot;},{Premium,&quot;&quot;},{Premium,&quot;&quot;},{Premium,&quot;&quot;},{Premium,&quot;&quot;},{Premium,&quot;&quot;},{Premium,&quot;&quot;} },\n    { {Standard,&quot;&quot;},{Standard,&quot;&quot;},{Standard,&quot;&quot;},{Standard,&quot;&quot;},{Standard,&quot;&quot;},{Standard,&quot;&quot;},{Standard,&quot;&quot;},{Standard,&quot;&quot;},{Standard,&quot;&quot;},{Standard,&quot;&quot;} },\n    { {Standard,&quot;&quot;},{Standard,&quot;&quot;},{Standard,&quot;&quot;},{Standard,&quot;&quot;},{Standard,&quot;&quot;},{Standard,&quot;&quot;},{Standard,&quot;&quot;},{Standard,&quot;&quot;},{Standard,&quot;&quot;},{Standard,&quot;&quot;} }\n};\nbool isBooked(const Seat&amp; s) { return !s.name.empty(); }\nbool bookSeat(int r,int c,const string&amp; name) {\n    if(r&lt;0||r&gt;=ROWS||c&lt;0||c&gt;=COLS||isBooked(hall[r][c])) return false;\n    hall[r][c].name = name; return true;\n}\nbool cancelSeat(int r,int c) {\n    if(r&lt;0||r&gt;=ROWS||c&lt;0||c&gt;=COLS||!isBooked(hall[r][c])) return false;\n    hall[r][c].name.clear(); return true;\n}\nstring categoryToString(SeatCategory c) {\n    return c==VIP?&quot;VIP&quot;:c==Premium?&quot;Premium&quot;:&quot;Standard&quot;;\n}\nvoid printHall() {\n    cout&lt;&lt;&quot;   &quot;; for(int c=0;c&lt;COLS;++c) cout&lt;&lt;c+1&lt;&lt;&quot; &quot;; cout&lt;&lt;&quot;\\n&quot;;\n    for(int r=0;r&lt;ROWS;++r) {\n        cout&lt;&lt;r+1&lt;&lt;&quot;  &quot;;\n        for(int c=0;c&lt;COLS;++c) {\n            if(!isBooked(hall[r][c])) {\n                char label = hall[r][c].category==VIP?&#039;V&#039;:hall[r][c].category==Premium?&#039;P&#039;:&#039;S&#039;;\n                cout&lt;&lt;&quot;[&quot;&lt;&lt;label&lt;&lt;&quot;] &quot;;\n            } else {\n                cout&lt;&lt;&quot;[X] &quot;;\n            }\n        }\n        cout&lt;&lt;&quot;\\n&quot;;\n    }\n}\nvoid printReservations() {\n    int count=0;\n    cout&lt;&lt;&quot;Elenco prenotazioni:\\n&quot;;\n    for(int r=0;r&lt;ROWS;++r) for(int c=0;c&lt;COLS;++c) if(isBooked(hall[r][c])) {\n        cout&lt;&lt;&quot;Fila &quot;&lt;&lt;r+1&lt;&lt;&quot; Col &quot;&lt;&lt;c+1&lt;&lt;&quot;: &quot;&lt;&lt;hall[r][c].name\n            &lt;&lt;&quot; (&quot;&lt;&lt;categoryToString(hall[r][c].category)&lt;&lt;&quot;)\\n&quot;;\n        ++count;\n    }\n    cout&lt;&lt;&quot;Totale prenotati: &quot;&lt;&lt;count&lt;&lt;&quot;\\n&quot;;\n}\nint main() {\n    int choice=0;\n    while(choice!=5) {\n        cout&lt;&lt;&quot;Menu:\\n&quot;;\n        cout&lt;&lt;&quot;1) Prenota\\n&quot;;\n        cout&lt;&lt;&quot;2) Cancella\\n&quot;;\n        cout&lt;&lt;&quot;3) Visualizza pianta\\n&quot;;\n        cout&lt;&lt;&quot;4) Elenco prenotazioni\\n&quot;;\n        cout&lt;&lt;&quot;5) Esci\\n&quot;;\n        cout&lt;&lt;&quot;Scelta: &quot;; cin&gt;&gt;choice;\n        if(choice==1) {\n            int r,c; string name;\n            cout&lt;&lt;&quot;Fila: &quot;; cin&gt;&gt;r;\n            cout&lt;&lt;&quot;Colonna: &quot;; cin&gt;&gt;c;\n            cin.ignore();\n            cout&lt;&lt;&quot;Nome: &quot;; getline(cin,name);\n            cout&lt;&lt;(bookSeat(r-1,c-1,name)\n                  ?&quot;Prenotazione confermata.\\n&quot;\n                  :&quot;Prenotazione fallita.\\n&quot;);\n        } else if(choice==2) {\n            int r,c;\n            cout&lt;&lt;&quot;Fila: &quot;; cin&gt;&gt;r;\n            cout&lt;&lt;&quot;Colonna: &quot;; cin&gt;&gt;c;\n            cout&lt;&lt;(cancelSeat(r-1,c-1)\n                  ?&quot;Cancellazione confermata.\\n&quot;\n                  :&quot;Cancellazione fallita.\\n&quot;);\n        } else if(choice==3) {\n            printHall();\n        } else if(choice==4) {\n            printReservations();\n        } else if(choice!=5) {\n            cout&lt;&lt;&quot;Scelta non valida.\\n&quot;;\n        }\n    }\n    cout&lt;&lt;&quot;Fine.\\n&quot;;\n    return 0;\n}\n \nInput/Output da file"},"Argomenti/Algoritmi/Estratto-eserciziario-IP-UniGe":{"slug":"Argomenti/Algoritmi/Estratto-eserciziario-IP-UniGe","filePath":"Argomenti/Algoritmi/Estratto eserciziario IP UniGe.md","title":"Estratto eserciziario IP UniGe","links":[],"tags":[],"content":"Espressioni, lettura e assegnazione\nEsercizi di riscaldamento\n\nScrivere un programma che legge due interi e ne stampa la somma.\nCome l’esercizio 1, ma con messaggi di richiesta prima di ogni input.\nScrivere un programma che scambia tra loro i valori di due variabili intere lette da input.\nScrivere un programma che legge due interi e ne stampa la differenza.\n\nEsercizi di base\n\nScrivere un programma che scambia i valori di due variabili di tipo char lette da input.\nScrivere un programma che scambia in maniera circolare “verso sinistra” i valori di tre variabili float.\nScrivere un programma che calcola perimetro e area di un rettangolo dopo aver letto i dati necessari.\nScrivere un programma che chiede all’utente in che anno è nato e stampa quanti anni ha.\nScrivere un programma che calcola perimetro e area di un triangolo.\nScrivere un programma che prende in input ore e minuti e calcola il totale dei minuti.\nScrivere un programma che calcola circonferenza e area di un cerchio.\nScrivere un programma che calcola la media tra due numeri.\nScrivere un programma che valuta delle espressioni booleane date.\n\nEsercizi più avanzati\n\nStampare due numeri letti in ordine crescente senza confrontarli.\nScambiare due variabili senza usare una variabile di appoggio.\n\n\nScelte condizionali\nEsercizi di riscaldamento\n\nLeggere due caratteri e stampare “Uguali” se sono identici, altrimenti “Diversi”.\nLeggere tre numeri interi e stamparli in ordine crescente.\n\nMinimo sindacale\n\nStampare il valore assoluto di un numero intero.\nLeggere tre numeri reali e stamparli in ordine decrescente.\nVerificare se un numero è divisibile per 13.\nVerificare se tre numeri possono essere i lati di un triangolo.\nEffettuare una serie di divisioni e moltiplicazioni su un numero e verificare la precisione.\nVerificare se un anno è bisestile.\nSimulare una partita di forbice-carta-sasso.\nStampare un messaggio in base alla temperatura letta.\nStampare il nome del mese corrispondente a un numero da 1 a 12.\n\nPer chi non si accontenta\n\nVerificare se un anno è bisestile usando la regola del calendario gregoriano.\nStampare l’orario in lettere, arrotondando ai 15 minuti.\nRisolvere un’equazione di secondo grado.\n\n\nCicli\nEsercizi di riscaldamento\n\nCalcolare la media di N numeri letti da input (varianti con for, while e do-while).\nLeggere lettere maiuscole finché l’utente non inserisce un carattere non maiuscolo e stampare la più piccola.\nCalcolare il fattoriale di un numero.\nStampare un carattere letto N volte.\nStampare un triangolo di asterischi con base di lunghezza data.\nImplementare un menu interattivo con più scelte.\nStampare barre verticali in base ai numeri inseriti.\nStampare un numero letto in ordine inverso.\n\nEsercizi di base\n\nGiocare più mani di morra cinese.\nStampare il numero di cifre di un numero intero.\nCalcolare la media di una sequenza di numeri fino a che l’utente non decide di terminare.\nStampare un trapezio rettangolo con ‘x’.\nStampare un rombo di asterischi.\nChiedere il colore preferito e gestire l’input in modo robusto.\nVerificare se un numero è palindromo.\nGioco di indovinare la radice quadrata.\nScomporre un numero in fattori primi.\n\nEsercizi più avanzati\n\nVerificare se un numero è un numero di Armstrong.\nContare il numero di zeri alla fine del fattoriale di un numero.\nStampare un numero in notazione romana.\n\n\nArray\nEsercizi di riscaldamento\n\nCreare e popolare un array di interi.\nStampare un array di interi.\nLeggere un array di interi da input.\nCalcolare la media di un array di numeri reali.\nScrivere un valore in un array in base a una formula e stamparlo.\n\nEsercizi di base\n\nTrovare il massimo in un array e quante volte appare.\nContare numeri pari e dispari in un array.\nInvertire un array.\nImplementare il Crivello di Eratostene per trovare numeri primi.\nInizializzare una matrice con zeri.\nCreare una tavola pitagorica e usarla per calcolare prodotti.\n\nEsercizi più avanzati\n\nVerificare se un array è palindromo.\nContare le occorrenze di ciascun valore in un array.\nTrovare il secondo valore più alto in un array.\nOrdinare un array e copiarlo in un altro array ordinato.\nOrdinare un array in-place.\nInvertire un array in-place.\nRimuovere elementi ripetuti in un array mantenendone solo uno.\nImplementare l’algoritmo precedente senza array ausiliari.\nUsare un array monodimensionale per rappresentare metà di una tavola pitagorica.\n\n\nArray: approfondimenti\nEsercizi di riscaldamento\n\nSequentialSearch: Ricerca sequenziale di un valore intero in un array di 15 elementi.\nBinarySearch: Ricerca binaria di un valore intero in un array ordinato di 15 elementi.\nSelectionSort: Implementare l’algoritmo di Selection Sort su un array.\nLeggere 20 numeri interi e stamparli in ordine decrescente dopo averli ordinati.\nreadMatrix: Leggere una matrice di dimensioni 3×4 da input.\nprintMatrix: Stampare una matrice di dimensioni 3×4.\n\nEsercizi di base\n\nModifica degli esercizi 1 e 2: Contare il numero di confronti effettuati durante la ricerca sequenziale e binaria.\nInsertionSort: Implementare l’algoritmo di Insertion Sort su un array.\nBubbleSort: Implementare l’algoritmo di Bubble Sort su un array.\nMatrixSum: Sommare due matrici di interi di dimensione 3×3.\nMatrixProduct: Calcolare il prodotto di due matrici quadrate di dimensione 3×3.\nTransposeMatrix: Calcolare la trasposta di una matrice quadrata.\nDiagonalSum: Sommare gli elementi della diagonale principale di una matrice quadrata.\n\nEsercizi più avanzati\n\nMergeSort: Implementare l’algoritmo di Merge Sort per ordinare un array.\nQuickSort: Implementare l’algoritmo di Quick Sort per ordinare un array.\nRicerca del valore più frequente: Determinare il valore che appare più frequentemente in un array.\nSomma degli elementi sopra la diagonale principale: Data una matrice quadrata, calcolare la somma degli elementi sopra la diagonale principale.\nEliminazione di righe e colonne contenenti un valore specifico: Data una matrice, eliminare tutte le righe e colonne contenenti un certo valore.\nRotazione di una matrice: Ruotare una matrice quadrata di 90 gradi in senso orario.\nCompressione di matrici sparse: Implementare un metodo per memorizzare matrici sparse in modo ottimizzato.\n\n\nStruct\nEsercizi di riscaldamento\n\nDichiarare una struct Punto con due coordinate e inizializzarla.\nDichiarare una struct Rettangolo e calcolarne l’area e il perimetro.\nDichiarare una struct Studente con nome, matricola e voto e stamparne i dati.\nDichiarare una struct Libro con titolo, autore e anno di pubblicazione e stamparne i dati.\nDichiarare una struct Data con giorno, mese e anno e verificare se una data è valida.\n\nEsercizi di base\n\nDichiarare una struct Tempo con ore, minuti e secondi e calcolare la differenza tra due orari.\nDichiarare una struct Persona e confrontare due persone in base all’età.\nDichiarare una struct Auto con modello, targa e chilometraggio e ordinarne una lista.\nDichiarare una struct Complesso per numeri complessi e implementare somme e moltiplicazioni.\nDichiarare una struct Poligono con vertici e calcolarne il perimetro.\n\nEsercizi più avanzati\n\nDichiarare una struct Matrice e implementare operazioni di somma, prodotto e trasposizione.\nDichiarare una struct Albero binario e implementare inserimento e ricerca.\nDichiarare una struct Lista concatenata e implementare aggiunta ed eliminazione di nodi.\nImplementare una coda con struct e array.\nImplementare una pila con struct e array.\n\n\nFunzioni\nEsercizi di riscaldamento\n\nScrivere una funzione che calcola il massimo tra due numeri interi.\nScrivere una funzione che calcola il minimo tra due numeri interi.\nScrivere una funzione che verifica se un numero è pari o dispari.\nScrivere una funzione che calcola il fattoriale di un numero.\nScrivere una funzione che verifica se un numero è primo.\n\nEsercizi di base\n\nScrivere una funzione per calcolare il MCD di due numeri.\nScrivere una funzione per calcolare il minimo comune multiplo.\nScrivere una funzione che calcola la potenza di un numero con esponente intero.\nScrivere una funzione che inverte una stringa.\nScrivere una funzione che conta le vocali in una stringa.\n\nEsercizi più avanzati\n\nImplementare una funzione che ordina un array con il metodo Selection Sort.\nImplementare una funzione che ordina un array con il metodo QuickSort.\nImplementare una funzione ricorsiva per calcolare la sequenza di Fibonacci.\nImplementare una funzione ricorsiva per il calcolo del fattoriale.\nImplementare una funzione ricorsiva per la ricerca binaria.\n\n\nPuntatori\nEsercizi di riscaldamento\n\nDichiarare un puntatore a intero e assegnargli un valore.\nDichiarare un puntatore a float e usarlo per modificare una variabile.\nDichiarare un puntatore a struct e usarlo per modificare un campo.\nUsare un puntatore per scambiare due variabili.\n\nEsercizi di base\n\nScrivere una funzione che prende due puntatori e scambia i valori delle variabili puntate.\nAllocare dinamicamente un array di interi.\nUsare malloc per allocare memoria per una stringa.\nScrivere una funzione che alloca dinamicamente una matrice.\nScrivere una funzione che libera la memoria allocata dinamicamente.\n\nEsercizi più avanzati\n\nImplementare una funzione che ridimensiona dinamicamente un array.\nImplementare una funzione per concatenare due stringhe usando solo puntatori.\nImplementare una funzione che inverte una stringa in-place usando solo puntatori.\nImplementare una funzione che trova il valore massimo in un array usando solo puntatori.\nImplementare una funzione che ordina un array con QuickSort usando solo puntatori.\n\n\nRicorsione\nEsercizi di riscaldamento\n\nScrivere una funzione ricorsiva che calcola il fattoriale di un numero.\nScrivere una funzione ricorsiva per calcolare la somma dei primi N numeri.\nScrivere una funzione ricorsiva per trovare il massimo in un array.\nScrivere una funzione ricorsiva per verificare se una stringa è palindroma.\n\nEsercizi di base\n\nImplementare la ricerca binaria in modo ricorsivo.\nImplementare la sequenza di Fibonacci in modo ricorsivo.\nImplementare il calcolo dell’MCD in modo ricorsivo.\nImplementare una funzione ricorsiva per invertire una stringa.\n\nEsercizi più avanzati\n\nImplementare Merge Sort in modo ricorsivo.\nImplementare Quick Sort in modo ricorsivo.\nImplementare una funzione ricorsiva per risolvere il problema delle torri di Hanoi.\nImplementare una funzione ricorsiva per generare tutte le permutazioni di un array.\nImplementare una funzione ricorsiva per risolvere il problema del cammino minimo in un grafo.\n\n\nVector\nEsercizi di riscaldamento\n\nDichiarare un vector di interi e assegnargli dei valori.\nDichiarare un vector di float e assegnargli dei valori.\nStampare il contenuto di un vector di interi.\nStampare il contenuto di un vector di float.\nAggiungere e rimuovere elementi da un vector di interi.\n\nEsercizi di base\n\nLeggere un vector di interi da input e stamparlo.\nTrovare il massimo valore in un vector.\nTrovare il valore più frequente in un vector.\nOrdinare un vector con il metodo Bubble Sort.\nOrdinare un vector con il metodo QuickSort.\n\nEsercizi più avanzati\n\nImplementare la ricerca binaria su un vector ordinato.\nImplementare una funzione che rimuove i duplicati da un vector.\nImplementare una funzione che trova la mediana di un vector.\nImplementare una funzione che calcola la somma degli elementi di un vector.\nImplementare una funzione che inverte un vector.\n\n\nLibrerie\nEsercizi di riscaldamento\n\nUsare la libreria &lt;cmath&gt; per calcolare la radice quadrata di un numero.\nUsare la libreria &lt;cmath&gt; per calcolare la potenza di un numero.\nUsare la libreria &lt;cstring&gt; per copiare una stringa.\nUsare la libreria &lt;cstring&gt; per concatenare due stringhe.\nUsare la libreria &lt;vector&gt; per dichiarare un vector.\n\nEsercizi di base\n\nUsare &lt;fstream&gt; per leggere da un file e stampare il contenuto.\nUsare &lt;fstream&gt; per scrivere un file.\nUsare &lt;sstream&gt; per convertire una stringa in un numero.\nUsare &lt;algorithm&gt; per ordinare un vector.\nUsare &lt;map&gt; per contare le occorrenze di elementi in un vector.\n\nEsercizi più avanzati\n\nImplementare un programma che legge e scrive su file CSV.\nImplementare un dizionario di parole usando &lt;map&gt;.\nImplementare un sistema di login con file di testo.\nImplementare un analizzatore lessicale di un testo usando &lt;regex&gt;.\nImplementare un algoritmo di compressione di stringhe usando &lt;unordered_map&gt;.\n\n\nEsercizio: Pac-Man\nEsercizi di riscaldamento\n\nDisegnare la griglia di gioco con un array bidimensionale.\nPosizionare Pac-Man in una posizione iniziale.\nPosizionare i fantasmi in posizioni casuali.\nStampare la griglia con Pac-Man e i fantasmi.\nConsentire a Pac-Man di muoversi nella griglia.\n\nEsercizi di base\n\nConsentire ai fantasmi di muoversi in modo casuale.\nImplementare un sistema di collisione tra Pac-Man e i fantasmi.\nAggiungere le pillole che Pac-Man può raccogliere.\nImplementare il sistema di punteggio.\nAggiungere una condizione di vittoria e sconfitta.\n\nEsercizi più avanzati\n\nImplementare un algoritmo per far muovere i fantasmi in modo intelligente.\nImplementare un sistema di livelli con difficoltà crescente.\nImplementare un’interfaccia grafica per il gioco.\nAggiungere il supporto al salvataggio delle partite.\nAggiungere il supporto per il multiplayer.\n\n\nEsercizio: Matrici dense e sparse\nEsercizi di riscaldamento\n\nDichiarare una matrice 3x3 e inizializzarla con valori casuali.\nStampare una matrice in formato leggibile.\nTrovare il massimo e il minimo di una matrice.\nContare il numero di zeri in una matrice.\nVerificare se una matrice è simmetrica.\n\nEsercizi di base\n\nImplementare la somma tra due matrici.\nImplementare il prodotto tra due matrici.\nImplementare la trasposizione di una matrice.\nConvertire una matrice densa in una rappresentazione sparsa.\nConvertire una matrice sparsa in una rappresentazione densa.\n\nEsercizi più avanzati\n\nImplementare la moltiplicazione tra matrici sparse.\nImplementare un algoritmo per trovare la matrice inversa.\nImplementare il metodo di Gauss-Jordan per la riduzione di matrici.\nImplementare un algoritmo per decomposizione LU.\nImplementare un algoritmo per risolvere sistemi lineari con matrici sparse.\n\n\nRicorsione\nEsercizi di riscaldamento\n\nCalcolare la somma dei primi N numeri in modo ricorsivo.\nCalcolare la sequenza di Fibonacci in modo ricorsivo.\nCalcolare il fattoriale in modo ricorsivo.\nContare il numero di cifre di un numero in modo ricorsivo.\nVerificare se una stringa è palindroma in modo ricorsivo.\n\nEsercizi di base\n\nImplementare una funzione ricorsiva per la ricerca binaria.\nImplementare una funzione ricorsiva per calcolare il MCD.\nImplementare una funzione ricorsiva per stampare un triangolo di asterischi.\nImplementare una funzione ricorsiva per sommare gli elementi di un array.\nImplementare una funzione ricorsiva per ordinare un array con Merge Sort.\n\nEsercizi più avanzati\n\nImplementare una funzione ricorsiva per risolvere il problema delle torri di Hanoi.\nImplementare una funzione ricorsiva per generare tutte le permutazioni di un array.\nImplementare una funzione ricorsiva per risolvere il problema del cammino minimo in un grafo.\nImplementare un algoritmo ricorsivo per calcolare il coefficiente binomiale.\nImplementare un algoritmo ricorsivo per risolvere equazioni differenziali semplici.\nEcco il proseguimento dell’estrazione degli esercizi dal documento.\n\n\nPuntatori - senza allocazione dinamica di memoria\nEsercizi di riscaldamento\n\nDichiarare un puntatore a intero e assegnargli un valore.\nDichiarare un puntatore a float e modificarne il valore attraverso il puntatore.\nDichiarare un array di interi e accedervi tramite puntatori.\nImplementare una funzione che prende un puntatore a intero e modifica il valore della variabile puntata.\nImplementare una funzione che scambia il contenuto di due variabili usando puntatori.\n\nEsercizi di base\n\nImplementare una funzione che calcola la lunghezza di una stringa senza usare &lt;cstring&gt;, solo con puntatori.\nImplementare una funzione che conta il numero di vocali in una stringa usando solo puntatori.\nImplementare una funzione che trova il valore massimo in un array usando puntatori.\nImplementare una funzione che copia un array in un altro usando solo puntatori.\nImplementare una funzione che ordina un array di interi usando Bubble Sort e puntatori.\n\nEsercizi più avanzati\n\nImplementare una funzione che somma due array elemento per elemento usando solo puntatori.\nImplementare una funzione che verifica se due stringhe sono anagrammi usando solo puntatori.\nImplementare una funzione che concatena due stringhe senza usare &lt;cstring&gt;.\nImplementare una funzione che inverte una stringa senza usare array di supporto, solo puntatori.\nImplementare una funzione che calcola il prodotto scalare tra due vettori usando solo puntatori.\n\n\nPuntatori - allocazione dinamica di memoria\nEsercizi di riscaldamento\n\nAllocare dinamicamente un array di interi e riempirlo con valori letti da input.\nAllocare dinamicamente un array di float e calcolarne la media.\nAllocare e deallocare dinamicamente una stringa.\nAllocare dinamicamente una matrice di interi.\nAllocare dinamicamente una matrice di float e calcolarne la somma.\n\nEsercizi di base\n\nImplementare una funzione che ridimensiona un array dinamico raddoppiandone la capacità.\nImplementare una funzione che copia un array statico in uno dinamico.\nImplementare una funzione che concatena due stringhe dinamiche.\nImplementare una funzione che legge una stringa di lunghezza arbitraria usando allocazione dinamica.\nImplementare una funzione che simula una pila con allocazione dinamica.\n\nEsercizi più avanzati\n\nImplementare una lista concatenata con allocazione dinamica.\nImplementare una coda con allocazione dinamica.\nImplementare una funzione che legge una matrice sparsa in modo dinamico.\nImplementare una funzione che calcola il determinante di una matrice usando allocazione dinamica.\nImplementare un algoritmo di gestione della memoria che simula un allocatore di heap.\n\n\nRicorsione\nEsercizi di riscaldamento\n\nImplementare una funzione ricorsiva per calcolare il fattoriale di un numero.\nImplementare una funzione ricorsiva per calcolare il massimo comune divisore.\nImplementare una funzione ricorsiva per verificare se una stringa è palindroma.\nImplementare una funzione ricorsiva per contare il numero di cifre di un intero.\nImplementare una funzione ricorsiva per calcolare la somma dei primi N numeri naturali.\n\nEsercizi di base\n\nImplementare una funzione ricorsiva per trovare il numero massimo in un array.\nImplementare una funzione ricorsiva per invertire una stringa.\nImplementare una funzione ricorsiva per ordinare un array con Merge Sort.\nImplementare una funzione ricorsiva per risolvere il problema delle torri di Hanoi.\nImplementare una funzione ricorsiva per generare tutte le permutazioni di un array.\n\nEsercizi più avanzati\n\nImplementare un algoritmo ricorsivo per risolvere equazioni di secondo grado.\nImplementare una funzione ricorsiva per trovare il cammino minimo in un grafo.\nImplementare un algoritmo ricorsivo per risolvere il problema dello zaino (Knapsack Problem).\nImplementare un algoritmo ricorsivo per il calcolo del coefficiente binomiale.\nImplementare un algoritmo ricorsivo per trovare la soluzione di Sudoku.\n\n\nEsercizi di riepilogo\nEsercizi di riscaldamento\n\nScrivere un programma che legge un numero intero e stampa la sua rappresentazione in binario.\nScrivere un programma che legge una stringa e ne stampa la lunghezza.\nScrivere un programma che legge un array di interi e stampa la somma degli elementi.\nScrivere un programma che legge due numeri interi e ne calcola il massimo comune divisore.\nScrivere un programma che verifica se una stringa è palindroma.\n\nEsercizi di base\n\nImplementare una funzione che ordina un array con il metodo Selection Sort.\nImplementare una funzione che ordina un array con il metodo Quick Sort.\nImplementare una funzione che trova il numero più frequente in un array.\nImplementare una funzione che calcola la somma di una matrice.\nImplementare una funzione che verifica se due matrici sono uguali.\n\nEsercizi più avanzati\n\nImplementare una funzione che calcola il determinante di una matrice quadrata.\nImplementare una funzione che trova la trasposta di una matrice.\nImplementare un algoritmo per risolvere sistemi di equazioni lineari.\nImplementare una funzione che risolve il problema del commesso viaggiatore con Programmazione Dinamica.\nImplementare una funzione che implementa l’algoritmo di Dijkstra per trovare il cammino minimo in un grafo.\n"},"Argomenti/Algoritmi/Introduzione-agli-algoritmi":{"slug":"Argomenti/Algoritmi/Introduzione-agli-algoritmi","filePath":"Argomenti/Algoritmi/Introduzione agli algoritmi.md","title":"Introduzione agli algoritmi","links":["tags/todo"],"tags":["todo"],"content":"Il Mondo Digitale e il Ruolo dei Programmi\nOgni dispositivo elettronico che utilizziamo, dai computer agli smartphone, dai forni a microonde ai sistemi di navigazione, funziona grazie a programmi informatici. Un programma è un insieme di istruzioni che indica a un dispositivo cosa fare e come farlo.\nQuando apriamo un’app di messaggistica, un software elabora il nostro messaggio e lo invia al destinatario. Quando giochiamo a un videogioco, un programma controlla la grafica, il punteggio e le interazioni tra i personaggi. Ogni azione che compiamo in un dispositivo digitale è gestita da uno o più programmi.\nChe cos’è un Programma?\nUn programma è un insieme di istruzioni che un computer esegue per svolgere un determinato compito. Esso è il risultato della traduzione di un algoritmo in un linguaggio di programmazione.\nDifferenza tra Algoritmo e Programma\n\nUn algoritmo è una sequenza di passi logici per risolvere un problema.\nUn programma è l’implementazione di un algoritmo in un linguaggio comprensibile dal computer.\n\nEsempi di Programmi nella Vita Quotidiana\nI programmi informatici sono ovunque:\n\nApp di messaggistica: WhatsApp, Telegram.\nGiochi: Minecraft, FIFA.\nSoftware di gestione: Word, Excel.\nSistemi operativi: Windows, Linux, macOS.\n\nOgni programma è costruito seguendo una logica precisa, basata su algoritmi.\nChe cos’è un Algoritmo?\nUn algoritmo è una sequenza di passi ben definiti e ordinati che permette di risolvere un problema o eseguire un compito. Possiamo pensarlo come una ricetta di cucina: ogni passaggio deve essere seguito nell’ordine corretto per ottenere il risultato desiderato.\nEsempio: Algoritmo di una Ricetta di Cucina\nImmaginiamo di voler preparare una torta al cioccolato. Per farlo, seguiamo un procedimento preciso:\n\n\nIngredienti necessari (input):\n\n200g di farina\n100g di zucchero\n50g di cacao in polvere\n2 uova\n100ml di latte\n1 bustina di lievito\n\n\n\nProcedimento (sequenza di istruzioni):\n\nPrendere una ciotola grande.\nVersare la farina, lo zucchero e il cacao nella ciotola.\nAggiungere le uova e mescolare.\nVersare il latte lentamente e continuare a mescolare.\nAggiungere il lievito e amalgamare il tutto.\nVersare il composto in una teglia da forno.\nCuocere in forno preriscaldato a 180°C per 30 minuti.\n\n\n\nRisultato (output): una torta soffice e gustosa pronta da mangiare!\n\n\nQuesta ricetta segue lo schema di un algoritmo:\n\nHa un input (gli ingredienti).\nSegue una sequenza logica di operazioni (la preparazione).\nHa un output ben definito (la torta pronta).\nSe si segue ogni passaggio correttamente, il risultato sarà sempre lo stesso.\n\nIl Processo: Dal Problema al Programma\nPer sviluppare un algoritmo efficace che diventi un programma funzionante, è necessario seguire un processo ben definito.\n1. Problema\nIdentificare il problema da risolvere è il primo passo. È necessario capire esattamente cosa si vuole ottenere.\nEsempio: Vogliamo creare un programma che calcoli la media di tre numeri inseriti dall’utente.\n2. Analisi\nIn questa fase si analizzano i dati in ingresso e il risultato atteso. Bisogna stabilire quali informazioni sono necessarie per risolvere il problema.\nEsempio:\n\nInput: Tre numeri.\nElaborazione: Sommare i numeri e dividere il risultato per tre.\nOutput: La media dei tre numeri.\n\n3. Sviluppo dell’Algoritmo\nA questo punto si scrive l’algoritmo che descrive passo dopo passo come risolvere il problema.\nEsempio in pseudocodice:\nInizio\n   Leggi numero1, numero2, numero3\n   Somma ← numero1 + numero2 + numero3\n   Media ← Somma / 3\n   Scrivi Media\nFine\n\n4. Simulazione\nPrima di scrivere il codice, si può testare l’algoritmo manualmente per verificare che funzioni correttamente.\nEsempio: Se inseriamo i numeri 5, 10, 15, l’algoritmo esegue:\n\nSomma = 5 + 10 + 15 = 30\nMedia = 30 / 3 = 10 L’output sarà 10, quindi l’algoritmo funziona.\n\n5. Codifica\nOra si traduce l’algoritmo in un linguaggio di programmazione, ad esempio in Python:\nnumero1 = float(input(&quot;Inserisci il primo numero: &quot;))\nnumero2 = float(input(&quot;Inserisci il secondo numero: &quot;))\nnumero3 = float(input(&quot;Inserisci il terzo numero: &quot;))\n \nsomma = numero1 + numero2 + numero3\nmedia = somma / 3\n \nprint(&quot;La media è:&quot;, media)\n6. Programma Funzionante\nIl risultato finale è un programma eseguibile che accetta tre numeri in input, calcola la media e la stampa.\nVariabili\nImmagina di avere un cassetto in cui puoi mettere un oggetto. Quel cassetto ha un’etichetta con un nome, che mi deve dare idea di quale oggetto ci possa trovare dentro.\nPuoi aprire il cassetto, mettere un oggetto dentro, cambiarlo ecc…\n\nOperazioni di base sulle variabili\n1. Assegnazione di un valore\nMetti un oggetto dentro il cassetto.\nstring cassetto = &quot;maglietta&quot;;  // Il cassetto ora contiene una maglietta\n🔹 Esempio pratico: Apri il cassetto e metti dentro una maglietta.\nSe poi vuoi cambiarlo:\ncassetto = &quot;pantaloni&quot;;  // Ora il cassetto contiene pantaloni\n🔹 Hai tolto la maglietta e messo dei pantaloni al suo posto.\n\n2. Incremento (o decremento) di una variabile\nSe il cassetto contiene qualcosa che può essere aumentato o diminuito (ad esempio, un numero di monete), possiamo modificarlo.\nint monete = 5;\nmonete = monete + 1;  // Ora il cassetto contiene 6 monete\nmonete = monete - 1;  // Ora il cassetto contiene 5 monete di nuovo\n🔹 Hai messo una moneta in più nel cassetto, poi ne hai tolta una.\n\n3. Modifica del valore di una variabile\nSe vuoi cambiare cosa c’è dentro un cassetto, basta sostituire l’oggetto.\nstring cassetto = &quot;maglietta&quot;;\ncassetto = &quot;giacca&quot;;  // Ora il cassetto contiene una giacca\n🔹 Hai tolto la maglietta e ci hai messo una giacca.\n\n4. Assegnazione del valore di una variabile a un’altra\nPrendi il contenuto di un cassetto e lo copi in un altro.\nstring cassetto1 = &quot;calzini&quot;;\nstring cassetto2 = cassetto1;  // Ora il secondo cassetto contiene anch&#039;esso &quot;calzini&quot;\n🔹 Hai aperto un secondo cassetto e ci hai messo dentro gli stessi calzini che erano nel primo (entrambi ora contengono gli stessi calzini, magia).\nSe ora cambi il contenuto di cassetto1,  quello di cassetto2 non cambia:\ncassetto1 = &quot;cintura&quot;;  \n// cassetto2 contiene ancora &quot;calzini&quot;, perché abbiamo cambiato solo il primo cassetto.\n\n5. Scambio di valore tra due variabili\ntodo Funziona molto meglio l’esempio con due bicchieri, uno di acqua e uno di cola, viene evidente che per scambiarli ho bisogno del terzo bicchiere.\nHai due cassetti e vuoi scambiare il loro contenuto.\nstring cassetto1 = &quot;guanti&quot;;\nstring cassetto2 = &quot;sciarpa&quot;;\nstring temp = cassetto1;  // Usiamo un cassetto temporaneo per salvare &quot;guanti&quot;\ncassetto1 = cassetto2;    // Ora cassetto1 contiene &quot;sciarpa&quot;\ncassetto2 = temp;         // Ora cassetto2 contiene &quot;guanti&quot;\n🔹 Hai preso i guanti dal primo cassetto, li hai messi in un cassetto di passaggio, poi hai messo la sciarpa nel primo cassetto e infine i guanti nel secondo.\nOppure, senza usare un cassetto temporaneo (solo con numeri):\nint a = 5, b = 10;\na = a + b;  // a = 15\nb = a - b;  // b = 5\na = a - b;  // a = 10\n🔹 Hai scambiato i numeri senza usare un cassetto di passaggio."},"Argomenti/Algoritmi/Introduzione-alla-programmazione":{"slug":"Argomenti/Algoritmi/Introduzione-alla-programmazione","filePath":"Argomenti/Algoritmi/Introduzione alla programmazione.md","title":"Introduzione alla programmazione","links":["Argomenti/Fattorizzazione-del-codice-e-makefile/Code-smells-e-refactoring"],"tags":[],"content":"\n\n                  \n                  Crediti \n                  \n                \n\n\nAutore: Davide Daffonchio\nAlcuni esercizi sono presi da “Introduzione alla programmazione - eserciziario” dei docenti dell’università di Genova e altri sono stati trovati in rete.\nQuesto documento è stato creato con il supporto di un’intelligenza artificiale per facilitare la raccolta e l’organizzazione delle informazioni. L’autore ha verificato e integrato le informazioni per garantire accuratezza e coerenza, ma si raccomanda di consultare fonti aggiuntive e di considerare eventuali aggiornamenti successivi alla stesura. L’uso del contenuto è a scopo informativo e didattico.\nUltimo Aggiornamento: 29-04-2025\n\n\n\n\n\n                  \n                  Stato di revisione \n                  \n                \n\n\nTutti i capitoli sono stati revisionati\n\n\n\nIndice\n \nCapitolo 1: Introduzione alla Programmazione\nCos’è la Programmazione?\nLa programmazione è il processo di scrittura, verifica e manutenzione di istruzioni che un computer può eseguire per risolvere un problema o realizzare un compito specifico.\n\nObiettivo della programmazione: tradurre un problema reale in una serie di passi logici, scritti in un linguaggio formale che il calcolatore può comprendere ed eseguire.\nUn programma(algoritmo) è quindi una sequenza di istruzioni che determinano il comportamento di un computer.\nL’obiettivo di un programmatore non è soltanto quello di risolvere un problema con una serie di istruzioni, ma quello di farlo nel modo più efficiente possibile.\n\n\nCome elabora le informazioni il computer\nUn computer è composto da hardware e software:\n\nHardware: la parte fisica del computer (CPU, RAM, disco rigido, ecc.).\nSoftware: insieme delle istruzioni che permettono all’hardware di svolgere determinate funzioni.\n\nFunzionamento di Base del Calcolatore\n\nInput: ricezione di dati dall’esterno (tastiera, mouse, file).\nElaborazione: La CPU (Central Processing Unit) esegue le istruzioni di un programma utilizzando il ciclo fetch-decode-execute:\n\nFetch: recupera l’istruzione dalla memoria RAM.\nDecode: interpreta l’istruzione.\nExecute: esegue l’operazione richiesta.\n\n\nOutput: invio dei risultati verso un dispositivo (monitor, file).\n\n\nLinguaggi di Programmazione\nIl computer comprende solo 0 e 1. Pertanto ho bisogno di interpreti che trasformino il mio linguaggio in una serie di 0 e 1, ovvero i linguaggi di programmazione.\nUn linguaggio di programmazione è un linguaggio formale che permette di scrivere programmi. Si dividono principalmente in:\n\nLinguaggi a basso livello di astrazione:\n\nVicini al linguaggio macchina (es. Assembly).\nMolto efficienti ma difficili da leggere e scrivere.\n\n\nLinguaggi ad alto livello di astrazione:\n\nPiù vicini al linguaggio naturale umano.\nTendenzialmente meno efficienti(meno controllo sulle risorse).\nEsempi: C, Python, Java.\n\n\n\nParadigmi di Programmazione\nUn paradigma definisce uno stile di programmazione. I principali paradigmi sono:\n\nProgrammazione Imperativa: descrive come eseguire un’operazione (sequenza di istruzioni).  È il paradigma di programmazione utilizzato in questa dispensa.\nProgrammazione Dichiarativa: descrive cosa deve essere fatto (es. SQL).\nProgrammazione Funzionale: basata sulle funzioni matematiche.\nProgrammazione Orientata agli Oggetti: organizza il codice attorno a “oggetti” che combinano dati e funzioni (è una tipologia specifica di programmazione imperativa)\n\n\nCompilazione e Interpretazione\nPer trasformare un programma scritto in linguaggio ad alto livello in linguaggio macchina, si usano compilatori o interpreti.\nCompilatore\nLa compilazione in C++ è il processo che trasforma il codice sorgente scritto dall’utente in un programma eseguibile. Si compone di quattro fasi principali:\n1. Preprocessing\n\nViene eseguito dal preprocessore (ad es., g++ -E file.cpp).\nElabora direttive come #include, #define, e macro.\nRimuove i commenti e include file di intestazione (.h).\n\n2. Compilazione\n\nIl codice sorgente preprocessato viene tradotto in assembly, un linguaggio di basso livello leggibile dalla macchina.\nQuesta fase rileva errori di sintassi e di semantica.\nComando: g++ -S file.cpp.\n\n3. Assemblaggio\n\nIl codice assembly viene tradotto in codice oggetto (file binario .o).\nQuesta fase è gestita dall’assembler.\nComando: g++ -c file.s.\n\n4. Linking\n\nIl linker collega il codice oggetto con eventuali librerie esterne o interne.\nProduce il file eseguibile finale.\nComando: g++ file.o.\n\nComando Completo\nPer automatizzare tutte le fasi:\ng++ file.cpp\nQuesto comando genera un file eseguibile chiamato a.out. Se volessi invece dare un nome all’eseguibile, posso usare l’argomento -o:\ng++ file.cpp -o programma\nIn breve, preprocessing → compilazione → assemblaggio → linking portano al programma finale eseguibile.\nEsecuzione\nPosso infine eseguire l’eseguibile che ho creato:\n./programma\nOppure posso usare la concatenazione &amp;&amp; per compilare ed eseguire il programma:\ng++ file.cpp -o programma &amp;&amp; ./programma\n\n\n                  \n                  Nota \n                  \n                \n\n\nSu linux, . significa la cartella corrente, per cui la notazione ./ significa che il file si trova dentro la cartella in cui mi trovo.\nIl processo compilazione di progetti più complessi che includono molteplici files, solitamente in C e C++ si automatizza con un makefile, che sarà un argomento avanzato.\n\n\n\nInterprete\n\nTraduce ed esegue il programma mentre lo esegue, istruzione per istruzione.\nEsempi di linguaggi interpretati: Python, Java.\nNon genera un file eseguibile ma esegue direttamente il codice sorgente.\n\nCompilato vs interpretato\nEsempio:\n\nC++ (compilato):\n\nScrivo il codice.\nCompilo il programma con g++ (es. g++ hello.cpp -o hello).\nEseguo il file eseguibile con ./hello.\n\n\nPython (interpretato):\n\nScrivo il codice.\nIl codice viene eseguito direttamente dall’interprete Python: python hello.py.\n\n\n\n\nIl nostro primo programma\nVediamo il classico esempio “Hello, World!” sia in un linguaggio compilato (C++) che interpretato (Python).\nEsempio in C ++\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    cout&lt;&lt;&quot;Hello, World!&quot;&lt;&lt;endl;\n    return 0;\n}\n\nScriviamo il codice.\nCompiliamo il programma con g++ (es. g++ hello.c -o hello).\nEseguiamo il file eseguibile con ./hello.\nSe tutto è andato a buon fine, vedremo a schermo la scritta\n\nHello, World!\n\nAl momento, possiamo prendere per buone alcune delle cose scritte nel codice, che vedremo nel dettaglio andando più avanti nel corso:\n\n\n#include &lt;iostream&gt;:\n\nInclude il file di intestazione iostream, che contiene le definizioni di funzioni e oggetti per la gestione dello stream di input e output, come std::cout e std::cin.\n\n\n\nusing namespace std;:\n\nPermette di evitare di scrivere std:: prima di ogni elemento dello standard namespace. Ad esempio, invece di scrivere std::cout, puoi usare semplicemente cout.\n\n\n\nint main():\n\nPunto di ingresso del programma. La funzione main() è dove il programma inizia l’esecuzione.\nRestituisce un valore di tipo int. Tradizionalmente, restituire 0 indica che il programma è terminato correttamente.\nIn C++, tutte le funzioni (tra cui il main, che è anch’esso una funzione) e le strutture di controllo di flusso, devono racchiudere il codice all’interno di parentesi graffe.\n\n\n\ncout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; endl;:\n\ncout è l’output stream standard che scrive dati sulla console.\nL’operatore &lt;&lt; è utilizzato per inviare i dati allo stream.\n&quot;Hello, World!&quot; è una stringa letterale che verrà stampata.\nendl è un manipolatore che aggiunge un carattere di nuova linea (\\n) e svuota il buffer dello stream.\n\n\n\nreturn 0;:\n\nRestituisce il valore 0 al sistema operativo per indicare che il programma è terminato senza errori.\n\n\n\nL’uso di using namespace std; può essere comodo per programmi semplici, ma in programmi più complessi è preferibile usare il prefisso std:: per evitare conflitti di nomi.\nEsempio senza using namespace std;:\n#include &lt;iostream&gt;\n \nint main() {\n    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;\n    return 0;\n}\nDurante il nostro corso, dovremmo utilizzare sempre il namespace std.\n\nEsercizi\n\n\n                  \n                  Esercizio \n                  \n                \n\n\nCrea un file sorgente che stampi una qualunque stringa di testo. Compilalo ed eseguilo.\nProva ad arrivare al file compilato seguendo invece passo a passo tutte le fasi della compilazione, che file produci? Hai provato ad aprirli per vedere cosa si trova all’interno?\nInfine prova a sperimentare cambiando alcune cose all’interno del file sorgente e vedi cosa succede. Se scrivi del codice sbagliato cosa succede? Il compilatore ti aiuta a capire cosa hai sbagliato?\n\n\n\n\nCapitolo 2: Fondamenti della programmazione imperativa\nCos’è la programmazione imperativa?\nLa programmazione imperativa si basa su un modello in cui le istruzioni vengono eseguite sequenzialmente per modificare lo stato del programma. È come dare ordini sequenziali al computer per eseguire azioni precise.\nLe caratteristiche principali sono:\n\nSequenzialità: le istruzioni vengono eseguite nell’ordine in cui sono scritte.\nModifica dello stato: i valori delle variabili cambiano nel corso del programma.\nControllo del flusso: utilizzo di condizioni e cicli per deviare il percorso.\n\nEsempio semplice in C++:\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int a = 5;        // Dichiarazione di una variabile\n    a = a + 3;        // Modifica dello stato\n    cout &lt;&lt; a &lt;&lt; endl; // Stampa: 8\n    return 0;\n}\n\nCommenti\nCome abbiamo già visto nell’esempio prima, nel codice posso inserire dei “commenti”. I commenti sono cose che io posso scrivere nel codice senza che queste vengano considerate dal compilatore. Posso quindi usarli per annotare cose, descrivere il funzionamento di parti di codice (senza esagerare), o per disabilitare temporaneamente parti di codice che non voglio che siano eseguite per debugging (il debugging è quella fase in cui testo il programma per cercare errori all’interno del codice e correggerli).\nPer fare un commento in una linea aggiungiamo // prima del commento, per farlo multilinea dobbiamo racchiudere il commento tra /* e */ come si vede nel prossimo esempio:\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int a = 5;        // Questo è un commento\n    a = a + 3;\n    // Anche questo è un commento\n    cout &lt;&lt; a &lt;&lt; endl; \n    // cout &lt;&lt; &quot;Ciao!&quot; &lt;&lt; endl; &lt;- questa linea di codice non viene eseguita\n    /* questo è\n\tun commento su più\n\tlinee */\n    return 0;\n}\n\nVariabili e ai tipi di dati in C++\nLe variabili sono contenitori per memorizzare dati. Ogni variabile ha un tipo di dato che definisce il tipo di valore che può contenere e un nome che le identifica univocamente. Questo consente di organizzare e manipolare i dati all’interno di un programma in modo efficiente.\nTipi di dati principali in C++\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipoDescrizioneEsempio di assegnazioneintNumeri interiint a = 5;floatNumeri decimali (precisione singola)float b = 3.14;doubleNumeri decimali (alta precisione)double c = 2.718;charCarattere singolochar d = &#039;A&#039;;stringSequenza di caratteristring s = &quot;Ciao&quot;;boolValori booleani (vero/falso)bool e = true;\nDichiarazione e assegnazione\nUna variabile deve essere dichiarata specificando il tipo e il nome. L’assegnazione consiste nell’attribuire un valore alla variabile:\nint numero;\nnumero = 10; // Assegnazione\nOppure dichiarazione e assegnazione possono essere combinate:\nint numero = 10;\nAssegnazioni possono essere effettuate anche da altre variabili o espressioni:\nint a = 5;\nint b = a; // Assegnazione da un&#039;altra variabile\nint c = a + b; // Assegnazione da un&#039;espressione\nPosso anche creare delle costanti, per valori che non voglio che siano cambiati dopo l’inizializzazione:\nconst double PI = 3.14159;\nOperazioni di base sulle variabili\nIncremento e decremento\nLe variabili numeriche possono essere incrementate o decrementate utilizzando gli operatori ++ e --:\nint x = 5;\nx++; // Incrementa x di 1 (x diventa 6) equivale a fare x = x + 1\nx--; // Decrementa x di 1 (x torna a 5)\nOperatori di assegnazione combinati\nC++ fornisce operatori che combinano assegnazione e operazioni:\nint a = 10;\na += 5; // Equivale a: a = a + 5 (a diventa 15)\na -= 3; // Equivale a: a = a - 3 (a diventa 12)\na *= 2; // Equivale a: a = a * 2 (a diventa 24)\na /= 4; // Equivale a: a = a / 4 (a diventa 6)\na %= 2; // Equivale a: a = a % 2 (a diventa 0)\nEsempio completo in C++\nUn esempio di utilizzo delle variabili e dei tipi di dato principali:\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n \nint main() {\n    int a = 8, b = 3;\n    int somma = a + b;\n    int prodotto = a * b;\n    \n    a += 2; // Incremento combinato\n \n    string nome = &quot;Mario&quot;;\n    string saluto = &quot;Ciao, &quot; + nome;\n \n    cout &lt;&lt; &quot;Somma: &quot; &lt;&lt; somma &lt;&lt; endl;\n    cout &lt;&lt; &quot;Prodotto: &quot; &lt;&lt; prodotto &lt;&lt; endl;\n    cout &lt;&lt; &quot;Nuovo valore di a: &quot; &lt;&lt; a &lt;&lt; endl;\n    cout &lt;&lt; saluto &lt;&lt; endl;\n \n    return 0;\n}\nDa questo esempio notiamo come posso anche “sommare” le stringhe. In verità questa operazione si chiama concatenazione, e unisce due stringhe in una stringa unica.\n\nInput e Output da console\nPer interagire con l’utente, utilizziamo cin per l’input e cout per l’output.\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int numero;\n    cout &lt;&lt; &quot;Inserisci un numero: &quot;;\n    cin &gt;&gt; numero;\n    cout &lt;&lt; &quot;Hai inserito: &quot; &lt;&lt; numero &lt;&lt; endl;\n \n    return 0;\n}\nCome vediamo nell’esempio, cin e cout utilizzano rispettivamente &gt;&gt; e &lt;&lt; come separatori. Posso concatenare con i separatori di output più stringhe e valori insieme. Posso anche concatenare più input: in tal caso il programma aspetterà più valori da inserire, separati da spazi o dalla pressione del tasto invio.\n\nCaratteri speciali nelle stringhe\nQuando utilizzi cout per stampare a schermo, puoi includere caratteri speciali usando il carattere di escape \\ per rappresentare simboli o comportamenti particolari. Ecco un elenco dei più comuni:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCarattere specialeSignificatoEsempioOutput\\nNuova rigacout &lt;&lt; &quot;Ciao\\nMondo&quot;;CiaoMondo\\tTabulazione orizzontalecout &lt;&lt; &quot;Ciao\\tMondo&quot;;Ciao     Mondo\\\\Barra rovesciata (\\)cout &lt;&lt; &quot;C:\\\\Documenti&quot;;C:\\Documenti\\&#039;Apice singolocout &lt;&lt; &quot;L\\&#039;utente&quot;;L’utente\\&quot;Apice doppiocout &lt;&lt; &quot;\\&quot;C++\\&quot; è fantastico!&quot;;”C++” è fantastico!\n\nEsempi pratici:\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    cout &lt;&lt; &quot;Esempio di nuova riga:\\n&quot;;\n    cout &lt;&lt; &quot;Ciao\\nMondo&quot; &lt;&lt; endl;\n \n    cout &lt;&lt; &quot;\\nEsempio di tabulazione:\\n&quot;;\n    cout &lt;&lt; &quot;Ciao\\tMondo&quot; &lt;&lt; endl;\n \n    cout &lt;&lt; &quot;\\nEsempio di barra rovesciata:\\n&quot;;\n    cout &lt;&lt; &quot;Percorso: C:\\\\Documenti\\\\File&quot; &lt;&lt; endl;\n \n    cout &lt;&lt; &quot;\\nEsempio di apici:\\n&quot;;\n    cout &lt;&lt; &quot;L&#039;utente ha detto: \\&quot;C++ è fantastico!\\&quot;&quot; &lt;&lt; endl;\n \n    cout &lt;&lt; &quot;\\nEsempio di ritorno a capo:\\n&quot;;\n    cout &lt;&lt; &quot;12345\\rABC&quot; &lt;&lt; endl; // Ritorna a inizio riga e sovrascrive\n \n    return 0;\n}\nOutput:\nEsempio di nuova riga:\nCiao\nMondo\n\nEsempio di tabulazione:\nCiao    Mondo\n\nEsempio di barra rovesciata:\nPercorso: C:\\Documenti\\File\n\nEsempio di apici:\nL&#039;utente ha detto: &quot;C++ è fantastico!&quot;\n\nEsempio di ritorno a capo:\nABC45\n\n\nOperazioni aritmetiche\nLe operazioni aritmetiche in C++ seguono i simboli standard:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperazioneSimboloEsempioRisultatoAddizione+5 + 38Sottrazione-5 - 32Moltiplicazione*5 * 315Divisione/6 / 32Modulo%5 % 32\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int a = 10, b = 3;\n \n    cout &lt;&lt; &quot;Addizione: &quot; &lt;&lt; a + b &lt;&lt; endl;\n    cout &lt;&lt; &quot;Sottrazione: &quot; &lt;&lt; a - b &lt;&lt; endl;\n    cout &lt;&lt; &quot;Moltiplicazione: &quot; &lt;&lt; a * b &lt;&lt; endl;\n    cout &lt;&lt; &quot;Divisione: &quot; &lt;&lt; a / b &lt;&lt; endl;\n    cout &lt;&lt; &quot;Modulo: &quot; &lt;&lt; a % b &lt;&lt; endl;\n \n    return 0;\n}\nIn questo esempio notiamo come posso anche inserire direttamente delle espressioni nell’output di cout.\n\nEsempio completo: somma di due numeri\nEcco un esempio che utilizza input, operazioni aritmetiche e output.\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int num1, num2, somma;\n \n    // Input\n    cout &lt;&lt; &quot;Inserisci il primo numero: &quot;;\n    cin &gt;&gt; num1;\n    cout &lt;&lt; &quot;Inserisci il secondo numero: &quot;;\n    cin &gt;&gt; num2;\n \n    // Operazione\n    somma = num1 + num2;\n \n    // Output\n    cout &lt;&lt; &quot;La somma è: &quot; &lt;&lt; somma &lt;&lt; endl;\n \n    return 0;\n}\n\nEsercizi\n\n\n                  \n                  Esercizi \n                  \n                \n\n\n\nScrivi un programma che riceva in input 3 numeri e ne calcoli la somma e la media.\nCalcola l’area di un triangolo dati base e altezza.\nScrivi un programma che converte una temperatura da Celsius a Fahrenheit\n\n\n\n\nCapitolo 3: Strutture di Controllo del Flusso\nIntroduzione\nIn un programma imperativo, le strutture di controllo del flusso sono fondamentali per prendere decisioni e ripetere blocchi di codice:\n\nStrutture condizionali: consentono di eseguire porzioni di codice solo se una condizione è soddisfatta.\nStrutture iterative (cicli): permettono di ripetere un blocco di istruzioni più volte finché una determinata condizione è soddisfatta (è l’unico modo “legale” che abbiamo per tornare indietro nel codice).\n\n\nStrutture Condizionali\nL’istruzione if\nLa struttura if consente di eseguire un blocco di codice solo se una condizione è vera.\nSintassi:\nif (condizione) {\n    // Blocco di codice eseguito se la condizione è vera\n}\nEsempio:  Questo programma stampa Il numero è positivo. solo se l’utente inserisce un numero maggiore di zero.\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int numero;\n    cout &lt;&lt; &quot;Inserisci un numero: &quot;;\n    cin &gt;&gt; numero;\n \n    if (numero &gt; 0) { // Condizione\n        cout &lt;&lt; &quot;Il numero è positivo.&quot; &lt;&lt; endl; // blocco di codice eseguito solo se la condizione è soddisfatta\n    }\n    return 0;\n}\n\nL’istruzione if-else\nL’istruzione if-else aggiunge un percorso alternativo se la condizione è falsa.\nif (condizione) {\n    // Codice eseguito se la condizione è vera\n} else {\n    // Codice eseguito se la condizione è falsa\n}\n\n\n                  \n                  Nota \n                  \n                \n\n\nQuando utilizziamo delle espressioni logiche (le useremo soprattutto all’interno delle condizioni), dobbiamo ricordarci che “diverso da” si indica con != e “uguale a” si indica con ==. Il singolo = serve esclusivamente per fare le assegnazioni, quindi ha un significato diverso da quello matematico, che per noi è il doppio uguale.\n\n\n\nEsempio:\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int numero;\n    cout &lt;&lt; &quot;Inserisci un numero: &quot;;\n    cin &gt;&gt; numero;\n \n    if (numero % 2 == 0) { \n        cout &lt;&lt; &quot;Il numero è pari.&quot; &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; &quot;Il numero è dispari.&quot; &lt;&lt; endl;\n    }\n    return 0;\n}\n\n\n                  \n                  Esercizio \n                  \n                \n\n\nCosa ti aspetti che succeda se togli il blocco else e metti cout &lt;&lt; &quot;Il numero è dispari.&quot; &lt;&lt; endl; fuori dal blocco if?\n\n\n\n\nL’istruzione if-else if\nQuando si devono valutare più condizioni, si utilizza l’istruzione if-else if.\nSintassi:\nif (condizione1) {\n    // Codice eseguito se condizione1 è vera\n} else if (condizione2) {\n    // Codice eseguito se condizione2 è vera\n}\nelse if (condizione3) {\n    // Codice eseguito se condizione3 è vera\n}\n//...\nelse {\n    // Codice eseguito se nessuna condizione è vera\n}\nPosso inserire tutte le condizioni che voglio, attenzione tuttavia che se ne inserisco troppe, probabilmente devo usare una struttura più avanzata (non le useremo in questo corso), come ad esempio una struttura dati dizionario.\nEsempio:\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int numero;\n    cout &lt;&lt; &quot;Inserisci un numero: &quot;;\n    cin &gt;&gt; numero;\n \n    if (numero &gt; 0) {\n        cout &lt;&lt; &quot;Il numero è positivo.&quot; &lt;&lt; endl;\n    } else if (numero &lt; 0) {\n        cout &lt;&lt; &quot;Il numero è negativo.&quot; &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; &quot;Il numero è zero.&quot; &lt;&lt; endl;\n    }\n    return 0;\n}\n\nL’istruzione switch\nL’istruzione switch è una istruzione equivalente a if-else ifutile quando si devono confrontare i valori di una variabile con più casi specifici.\nSintassi:\nswitch (espressione) {\n    case valore1:\n        // Codice da eseguire se espressione == valore1\n        break;\n    case valore2:\n        // Codice da eseguire se espressione == valore2\n        break;\n    default:\n        // Codice eseguito se nessun caso corrisponde\n}\nEsempio:\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int giorno;\n    cout &lt;&lt; &quot;Inserisci un numero (1-7) per il giorno della settimana: &quot;;\n    cin &gt;&gt; giorno;\n \n    switch (giorno) {\n\t\tcase 1:\n        \tcout &lt;&lt; &quot;Lunedì&quot; &lt;&lt; endl;\n        \tbreak;\n        case 2:\n        \tcout &lt;&lt; &quot;Martedì&quot; &lt;&lt; endl;\n        \tbreak;\n        case 3:\n        \tcout &lt;&lt; &quot;Mercoledì&quot; &lt;&lt; endl;\n        \tbreak;\n        case 4:\n        \tcout &lt;&lt; &quot;Giovedì&quot; &lt;&lt; endl;\n        \tbreak;\n        case 5:\n        \tcout &lt;&lt; &quot;Venerdì&quot; &lt;&lt; endl;\n        \tbreak;\n        case 6:\n        \tcout &lt;&lt; &quot;Sabato&quot; &lt;&lt; endl;\n        \tbreak;\n        case 7:\n        \tcout &lt;&lt; &quot;Domenica&quot; &lt;&lt; endl;\n        \tbreak;\n        default:\n        \tcout &lt;&lt; &quot;Numero non valido!&quot; &lt;&lt; endl;\n    }\n    return 0;\n}\nIl break (che posso anche usare per interrompere manualmente un ciclo) è necessario ad ogni istruzione in questo caso, poiché lo switch esegue l’istruzione corrispondente al valore, ma poi esegue anche tutte quelle sottostanti. In rari casi posso omettere il break se questo comportamento è voluto.\n\n\n                  \n                  Esercizio \n                  \n                \n\n\nNel codice precedente, prova a rimuovere i break e guarda cosa succede.\n\n\n\nOperatore ternario\nL’operatore ternario è un costrutto che permette di esprimere una scelta condizionale in una singola espressione. La sua sintassi è la seguente:\ncondizione ? espressione_se_vera : espressione_se_falsa;\nIn pratica, la condizione viene valutata: se risulta vera, viene eseguita e restituita l’espressione_se_vera; altrimenti, viene eseguita e restituita l’espressione_se_falsa.\nVantaggi e utilizzi\n\nCompattezza: consente di scrivere in modo più sintetico delle semplici strutture condizionali, evitando blocchi if-else più lunghi.\nEspressività: essendo un’espressione, può essere usata direttamente in assegnazioni o in altre espressioni complesse. Ad esempio:\n\nint absValue = (x &gt;= 0) ? x : -x;\nQuesto codice assegna a absValue il valore assoluto di x senza dover ricorrere a una struttura if-else.\nConsiderazioni\n\nLeggibilità: per condizioni troppo complesse o annidate, l’uso dell’operatore ternario può ridurre la chiarezza del codice. In questi casi, è preferibile utilizzare le strutture condizionali tradizionali.\nPrecedenza: l’operatore ternario ha una precedenza relativamente bassa, quindi a volte può essere necessario usare le parentesi per assicurare l’ordine di valutazione desiderato.\n\nL’operatore ternario è quindi un utile strumento per semplificare il codice, purché venga utilizzato in contesti in cui la condizione e le espressioni coinvolte rimangano facilmente comprensibili.\n\nEspressioni logiche e algebra di Boole\nDopo aver visto esempi semplici con condizioni singole, possiamo combinare insieme più condizioni semplici per ottenerne di più complesse attraverso gli operatori logici e l’algebra di Boole.\n\nTabelle di verità dell’algebra di Boole\nL’algebra di Boole è alla base delle espressioni logiche:\n\n0 rappresenta false (falso)\n1 rappresenta vero (true)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABA AND BA OR BNOT A00001010111001011110I connettivi logici di base funzionano esattamente come il linguaggio naturale che utilizziamo per parlare:\n\nAND: tradotto in italiano come “e”, assume valore vero solo se entrambe le espressioni sono vere, ad esempio l’espressione “Ho una maglietta gialle e (and) ho i pantaloni neri” è vera soltanto se vesto sia una maglietta gialla che i pantaloni neri. Se avessi la maglietta gialla e i pantaloni verdi sarebbe falsa.\nOR: tradotto in italiano come “o”, assume valore vero solo se almeno una o tutte le espressioni della frase sono vere, ad esempio l’espressione “Ho una maglietta gialle o (or) ho i pantaloni neri” è vera sia che vesta una maglietta gialla e i pantaloni neri sia che vesta la maglietta gialla e i pantaloni verdi. Sarebbe falsa solo se avessi ad esempio la maglia rossa e i pantaloni verdi.\nNOT: inverte il valore di verità dell’espressione, tradotto in italiano come “non”, ad esempio fuori non(not) piove è vera se il valore piove è falso, mentre assume valore falso se il valore di piove è vero.\n\nCosi come gli operatori nelle espressioni matematiche, anche i connettivi logici hanno precedenze diverse. Gli ordini di precedenza sono not→and→or. Pertanto se avessi una espressione A or B and not C, verrà valutato prima not C, poi B and not C e infine il risultato messo in or con A.\nPosso usare le parentesi come nelle espressioni matematiche per cambiare le precedenze, ricorda tuttavia che posso usare solo parentesi tonde anche una dentro l’altra (graffe e quadre servono per altre cose).\n\nEsempi pratici in C++\n\nCondizione con AND (&amp;&amp; o and):\n\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int eta;\n    cout &lt;&lt; &quot;Inserisci la tua età: &quot;;\n    cin &gt;&gt; eta;\n \n    if (eta &gt;= 18 and eta &lt;= 65) {\n        cout &lt;&lt; &quot;Sei in età lavorativa.&quot; &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; &quot;Non sei in età lavorativa.&quot; &lt;&lt; endl;\n    }\n    return 0;\n}\n\nCondizione con OR (|| o or):\n\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    char lettera;\n    cout &lt;&lt; &quot;Inserisci una lettera: &quot;;\n    cin &gt;&gt; lettera;\n \n    if (lettera == &#039;a&#039; or lettera == &#039;e&#039; or lettera == &#039;i&#039; or lettera == &#039;o&#039; or lettera == &#039;u&#039;) {\n        cout &lt;&lt; &quot;Hai inserito una vocale!&quot; &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; &quot;Non è una vocale.&quot; &lt;&lt; endl;\n    }\n    return 0;\n}\n\nUso del NOT (! o not):\n\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    bool piove = true; // posso salvare valori (anche risultati di espressioni) booleani in variabili di tipo bool\n \n    if (!piove) {\n        cout &lt;&lt; &quot;Esco senza ombrello.&quot; &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; &quot;Porto l’ombrello.&quot; &lt;&lt; endl;\n    }￼￼)￼￼:\n    return 0;\n}\n\nCombinare più condizioni\nPuoi combinare più espressioni logiche per creare condizioni ancora più complesse\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int a, b;\n    cout&lt;&lt;&quot;Inserisci a e b&quot;&lt;&lt;endl;\n    cin&gt;&gt;a&gt;&gt;b;\n \n    if (a &gt; 0 and b &gt; 0 or a == b) {\n        cout &lt;&lt; &quot;Le condizioni sono soddisfatte.&quot; &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; &quot;Le condizioni NON sono soddisfatte.&quot; &lt;&lt; endl;\n    }\n    return 0;\n}\n\n\n                  \n                  Esercizio \n                  \n                \n\n\nCome faccio in questo codice a soddisfare la condizione inserendo in input due numeri negativi?\n\n\n\n\nBoolean playground\nSperimenta liberamente con questo codice per capire come funzionano le espressioni booleane (e rispetta i miei capelli):\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\nusing namespace std;\n \nvoid clear()\n{\n\t#ifdef _WIN32\n\t    std::system(&quot;cls&quot;);\n\t#else\n\t    // Assume POSIX\n\t    std::system (&quot;clear&quot;);\n\t#endif\n}\n/* run this program using the console pauser or add your own getch, system(&quot;pause&quot;) or input loop */\n \nint main(int argc, char** argv) {\n\t// nota: in booleano, true (vero) equivale a 1 e false (falso) equivale a 0\n\t// == sta per uguale, != sta per diverso. Attenzione a non confondersi con = che significa assegnazione\n\tcout&lt;&lt;&quot;L&#039;espressione 1==3 vale: &quot;&lt;&lt; (1==3) &lt;&lt;endl;\n\tcout&lt;&lt;&quot;L&#039;espressione 1==1 vale: &quot;&lt;&lt; (1==1) &lt;&lt;endl;\t\n\tcout&lt;&lt;&quot;L&#039;espressione 1!=3 vale: &quot;&lt;&lt; (1!=3) &lt;&lt;endl;\n\tcout&lt;&lt;&quot;L&#039;espressione 1!=1 vale: &quot;&lt;&lt; (1!=1) &lt;&lt;endl;\n\tcout&lt;&lt;&quot;L&#039;espressione 1&lt;3 vale: &quot;&lt;&lt; (1&lt;3) &lt;&lt;endl;\n\tcout&lt;&lt;endl;\n\t\n\t//i capelli del prof\n\tbool capelli_scuri = true; //not capelli_scuri sta per capelli biondi\n\tbool capelli_corti = true; // not capelli_corti sta per capelli lunghi\n\t\n\t//and (in italiano: e): e&#039; vero solo quando tutti i valori dell&#039;espressione sono veri\n\tcout&lt;&lt;&quot;Il prof ha i capelli corti e scuri: &quot;&lt;&lt;(capelli_corti and capelli_scuri)&lt;&lt;endl;\n\tcout&lt;&lt;&quot;Il prof ha i capelli corti e biondi: &quot;&lt;&lt;(capelli_corti and not capelli_scuri)&lt;&lt;endl;\n\tcout&lt;&lt;&quot;Il prof ha i capelli lunghi e scuri: &quot;&lt;&lt;(not capelli_corti and capelli_scuri)&lt;&lt;endl;\n\tcout&lt;&lt;&quot;Il prof ha i capelli lunghi e biondi: &quot;&lt;&lt;(not capelli_corti and not capelli_scuri)&lt;&lt;endl;\n\tcout&lt;&lt;endl;\n\t\n\t//or (in italiano: o): e&#039; falso solo quando tutti i valori dell&#039;espressione sono falsi\n\tcout&lt;&lt;&quot;Il prof ha i capelli corti o scuri: &quot;&lt;&lt;(capelli_corti or capelli_scuri)&lt;&lt;endl;\n\tcout&lt;&lt;&quot;Il prof ha i capelli corti o biondi: &quot;&lt;&lt;(capelli_corti or not capelli_scuri)&lt;&lt;endl;\n\tcout&lt;&lt;&quot;Il prof ha i capelli lunghi o scuri: &quot;&lt;&lt;(not capelli_corti or capelli_scuri)&lt;&lt;endl;\n\tcout&lt;&lt;&quot;Il prof ha i capelli lunghi o biondi: &quot;&lt;&lt;(not capelli_corti or not capelli_scuri)&lt;&lt;endl;\t\n\tcout&lt;&lt;endl;\n\t\n\t//posso utilizzare le parentesi come in un&#039;espressione matematica, ad esempio:\n\tcout&lt;&lt;&quot;Non e&#039; vero che il prof ha i capelli lunghi e biondi: &quot;&lt;&lt;not(not capelli_corti or not capelli_scuri)&lt;&lt;endl;\n\tcout&lt;&lt;endl;\n\t//le espressioni booleane sono utili per fare condizioni piu&#039; complesse\n\t//proviamo con un quiz\n\t\n\tcout&lt;&lt;&quot;Premi invio per continuare...&quot;&lt;&lt;endl;\n\tcin.get(); // usiamo questo tipo di cin per mettere in pausa il programma finche l&#039;utente non preme invio\n\tclear();\n\t\n\tint primaRisposta; //vanno dichiarate fuori dal ciclo se le uso come condizioni\n\tint secondaRisposta;\n\tbool primaVolta=true;\n\tdo{\n\t\tif (not primaVolta){\n\t\t\tcout&lt;&lt;&quot;Risposta errata, riprova!&quot;&lt;&lt;endl;\n\t\t}\n\t\tprimaVolta=false;\n\t\tcout&lt;&lt;&quot;Di che lunghezza sono i capelli del prof?&quot;&lt;&lt;endl;\n\t\tcout&lt;&lt;&quot;1) Corti&quot;&lt;&lt;endl;\n\t\tcout&lt;&lt;&quot;2) Lunghi&quot;&lt;&lt;endl;\n\t\tcin&gt;&gt;primaRisposta;\n\t\tcout&lt;&lt;&quot;Di che colore sono i capelli del prof?&quot;&lt;&lt;endl;\n\t\tcout&lt;&lt;&quot;1) Biondi&quot;&lt;&lt;endl;\n\t\tcout&lt;&lt;&quot;2) Scuri&quot;&lt;&lt;endl;\n\t\tcin&gt;&gt;secondaRisposta;\n\t\tclear();\t\n\t} while (not (primaRisposta==1 and secondaRisposta==2));\n\t//se non e&#039; vero che primaRisposta equivale a 1 e secondaRisposta equivale a 2 ripeti il ciclo\n\t\n\tcout&lt;&lt;&quot;Risposta esatta!&quot;&lt;&lt;endl;\n \n\treturn 0;\n}\n\n\n                  \n                  Nota \n                  \n                \n\n\nNel codice è presente un ciclo, non li abbiamo ancora visti ma sono il prossimo argomento che leggerai. È anche presente una funzione (altro argomento che faremo) che richiama una funzione di sistema.\n\n\n\nEsercizio su espressioni booleane\nQuesto esercizio permette di sperimentare con l’algebra booleana e anche di capire alcuni fondamenti di programmazione:\n\n\n                  \n                  Esercizio \n                  \n                \n\n\nScrivere un programma che, per ciascuna di queste frasi, stampa la frase seguita dal simbolo = e da un’espressione booleana che calcola il suo valore di verità.\n\n\n                  \n                  Suggerimento \n                  \n                \nPer stampare i booleani come true e false invece che come 1 e 0 si deve impostare a true il flag boolalpha di cout. Per fare questo si usa la stessa sintassi della stampa, ovvero si deve “stampare” un comando, come segue: std::cout &lt;&lt; std::boolalpha\n\n• tre è maggiore di uno\n• quattro diviso due è minore di zero\n• il carattere “zero” è uguale al valore zero\n• dieci mezzi è compreso fra zero escluso e dieci incluso (ossia: dieci mezzi è maggiore di zero E dieci mezzi è minore o uguale a dieci)\n• non è vero che tre è maggiore di due e minore di uno\n• tre minore di meno cinque implica sette maggiore di zero\n\n\n\nEsercizi su strutture condizionali\n\n\n                  \n                  Esercizi \n                  \n                \n\n\n\n\nPositivo, Negativo o Zero\nScrivi un programma che chiede all’utente di inserire un numero e stampa se è positivo, negativo o zero.\nObiettivo: Usare if-else if con più condizioni.\n\n\nControllo dell’età\nScrivi un programma che chiede all’utente di inserire la sua età. Se è minore di 18, stampa “Minorenne”. Se è tra 18 e 65, stampa “Adulto”. Altrimenti, stampa “Anziano”.\nObiettivo: Utilizzare if-else if e l’operatore logico &amp;&amp;.\n\n\nCalcolatrice con switch\nScrivi un programma che implementa una semplice calcolatrice. Chiedi all’utente di inserire due numeri e un’operazione (+, -, *, /) e calcola il risultato utilizzando switch.\nObiettivo: Praticare l’uso di switch con un caso default per gestire operazioni non valide.\n\n\nVerifica multipla con operatori logici\nScrivi un programma che chiede all’utente di inserire due numeri interi a e b.\nStampa:\n\n\n\n\n“Entrambi positivi” se entrambi i numeri sono maggiori di zero.\n\n\n“Uno positivo” se solo uno è maggiore di zero.\n\n\n“Entrambi negativi o zero” altrimenti.\nObiettivo: Combinare operatori logici &amp;&amp; e ||.\n\n\n\nQuiz sul giorno della settimana\nScrivi un programma che chiede all’utente di inserire un numero tra 1 e 7 e stampa il giorno corrispondente (1 = Lunedì, 2 = Martedì, …, 7 = Domenica).\nEstensione: Se il numero non è compreso tra 1 e 7, stampa “Errore: numero non valido”.\nObiettivo: Usare switch con casi numerici e un caso default.\n\n\n\n\nCicli e Iterazioni\nI cicli servono per ripetere blocchi di codice, e sono l’unico modo che ho per ripetere del codice (in quanto i salti incondizionati sono fortemente sconsigliati). Ne ho di 3 di tipo diverso in base al mio obiettivo:\nIl ciclo for\nIl ciclo for è usato per ripetere un blocco di codice un numero specifico di volte.\nSintassi:\nfor (inizializzazione; condizione; incremento) {\n    // Blocco di codice da ripetere\n}\nEsempio: Stampare i numeri da 1 a 5.\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    for (int i = 1; i &lt;= 5; i++) {\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    }\n    cout&lt;&lt;endl;\n    return 0;\n}\n\nIl ciclo while\nIl ciclo while ripete un blocco di codice finché una condizione è vera. In questo caso, a differenza del ciclo for, non so effettivamente quante volte verrà eseguito il blocco di codice.\nSintassi:\nwhile (condizione) {\n    // Blocco di codice da ripetere\n}\nEsempio: Chiedere all’utente di inserire il numero 5 finché non lo inserisce.\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int numero = 3;\n    while(numero != 5){\n    cout&lt;&lt;&quot;Finche non inserisci il numero 5 io continuo a chiedertelo&quot;&lt;&lt;endl;\n    cin&gt;&gt;numero;\n    }\n    cout&lt;&lt;&quot;Finalmente!&quot;&lt;&lt;endl;\n    return 0;\n}\n\n\n                  \n                  Nota \n                  \n                \n\n\nIn questo esempio ho inizializzato la variabile numero a 3 per essere sicuro di entrare nel ciclo (poiché alla prima iterazione 3 != 5 è vero). Se non inizializzo la variabile, alcuni linguaggi di programmazione la inizializzano automaticamente a 0, altri a 1, altri con numeri completamente casuali a seconda dell’indirizzo di memoria. Prova con diversi linguaggi di programmazione e prova a stampare una variabile non inizializzata per vedere cosa succede!\n\n\n\n\nIl ciclo do-while\nIl ciclo do-while è simile al while, ma garantisce che il blocco di codice venga eseguito almeno una volta.\nSintassi:\ndo {\n    // Blocco di codice da ripetere\n} while (condizione);\nEsempio:\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int numero;\n    do{\n    cout&lt;&lt;&quot;Finche non inserisci il numero 5 io continuo a chiedertelo&quot;&lt;&lt;endl;\n    cin&gt;&gt;numero;\n    }while(numero != 5);\n    cout&lt;&lt;&quot;Finalmente!&quot;&lt;&lt;endl;\n    return 0;\n}\n\n\n                  \n                  Esercizio \n                  \n                \n\n\nIn questo caso non ho bisogno di inizializzare la variabile. Perché?\n\n\n\nQuale uso?\nIl ciclo for serve quando conosco a priori quante interazioni farò (che può dipendere da un numero assoluto, da una variabile, dal risultato di una espressione o di una formula ecc…).\nI cicli do-while e while servono quando non conosco a priori il numero di interazioni (e dunque la condizione dipende dalle azioni dell’utente), in particolare:\n\nwhile nei casi in cui non devo fare neanche una interazione se la condizione non è rispettata, poiché viene controllata prima del blocco di codice.\ndo-while nei casi in cui devo fare almeno una interazione prima del controllo della condizione, poiché questa viene controllata dopo il blocco di codice. Questo è particolarmente utile quando la condizione viene aggiornata direttamente all’interno del blocco di codice prima di essere inizializzata, ad esempio se devo controllare una password inserita dall’utente.\n\nbreak e continue nei cicli\nAll’interno di un ciclo, posso utilizzare i comandi break e continue per controllare il flusso di esecuzione in modo più preciso.\nIl comando break\nbreak interrompe immediatamente l’esecuzione del ciclo, uscendo completamente da esso indipendentemente dalla condizione. È utile quando voglio fermare un ciclo manualmente per qualche motivo.\nEsempio: Chiedere all’utente se vuole continuare o uscire dal ciclo.\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    for (int i = 1; i &lt;= 100; i++) { // Ciclo che può teoricamente contare fino a 100\n        cout &lt;&lt; i &lt;&lt; endl;\n        \n        char scelta;\n        cout &lt;&lt; &quot;Vuoi continuare? (s/n): &quot;;\n        cin &gt;&gt; scelta;\n        \n        if (scelta == &#039;n&#039; || scelta == &#039;N&#039;) {\n            cout &lt;&lt; &quot;Hai scelto di uscire dal ciclo.&quot; &lt;&lt; endl;\n            break; // Esce dal ciclo\n        }\n    }\n    return 0;\n}\n \n\n\n                  \n                  Esercizio \n                  \n                \n\n\nRiesci a usare la variabile scelta dopo che sei uscito dal ciclo? Come mai? Approfondisci sugli “scopes” delle variabili per avere una risposta.\n\n\n\nIl comando continue\ncontinue interrompe l’iterazione corrente e salta direttamente alla successiva. È utile quando voglio ignorare il resto del blocco di codice per una determinata condizione, ma continuare il ciclo.eseguibile\nEsempio: Stampare solo numeri dispari.\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    for (int i = 1; i &lt;= 10; i++) {\n        if (i % 2 == 0) {\n            continue; // Salta il resto del codice in questa iterazione\n        }\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    }\n    return 0;\n}\n\nConfronto tra break e continue\n\nbreak esce completamente dal ciclo.\ncontinue salta solo l’iterazione corrente, ma il ciclo continua.\n\nEsercizi sui cicli\n\n\n                  \n                  Esercizi \n                  \n                \n\n\n\nSomma dei numeri positivi\nScrivi un programma che chiede all’utente di inserire numeri interi uno alla volta. Il programma termina quando l’utente inserisce un numero negativo e stampa la somma di tutti i numeri positivi inseriti.\nObiettivo: Utilizzare un ciclo while con una condizione logica.\nTabelline\nScrivi un programma che chiede all’utente di inserire un numero intero e stampa la sua tabellina (moltiplicazione da 1 a 10).\nObiettivo: Usare un ciclo for per iterazioni fisse.\nIndovina il numero\nScrivi un programma che genera un numero casuale tra 1 e 100. L’utente deve indovinarlo inserendo numeri finché non trova quello corretto. Dopo ogni tentativo, il programma deve dire se il numero inserito è più alto o più basso di quello da indovinare.\nObiettivo: Usare un ciclo do-while con una condizione e operatori logici.\nNumero primo\nScrivi un programma che chiede all’utente di inserire un numero intero e verifica se è un numero primo.\nObiettivo: Usare cicli annidati e condizioni logiche.\nFibonacci\nScrivi un programma che calcola e stampa i primi n numeri della sequenza di Fibonacci. n è dato in input dall’utente.\nObiettivo: Utilizzare un ciclo for per una sequenza iterativa.\n\n\n\n\n\nCapitolo 4: Strutture Dati di Base\nIntroduzione\nLe strutture dati sono entità usate per organizzare insiemi di dati nella memoria in modo strutturato. Nel paradigma imperativo con C++, le strutture dati di base includono:\n\nArray\nStringhe\nStruct\n\nIn questo capitolo analizzeremo ciascuna di queste strutture, mostrando esempi pratici di implementazione.\nArray in C++\nGli array sono una struttura dati fondamentale che permette di memorizzare una collezione di valori dello stesso tipo, organizzati in modo contiguo in memoria. Gli array sono utili quando è necessario lavorare con più dati correlati.\n\nDichiarazione e inizializzazione\nUn array in C++ si dichiara specificando il tipo di dati, il nome e la dimensione. La dimensione deve essere un valore intero positivo.\nSintassi:\ntipo nome_array[dimensione];\nEsempi:\nint numeri[5]; // Array di 5 interi, non inizializzato\nint voti[3] = {8, 9, 10}; // Array di 3 interi inizializzati\nfloat decimali[4] = {1.2, 3.4, 5.6, 7.8}; // Array di 4 float inizializzati\nchar lettere[3] = {&#039;A&#039;, &#039;B&#039;, &#039;C&#039;}; // Array di 3 caratteri (somiglia a qualcosa?)\nSe non si specificano tutti i valori, gli elementi rimanenti sono impostati a 0:\nint numeri[5] = {1, 2}; // Array: {1, 2, 0, 0, 0}\n\nAccesso agli elementi\nGli elementi di un array sono indicizzati a partire da 0. È possibile accedervi utilizzando il nome dell’array e un indice tra parentesi quadre.\nEsempio:\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int numeri[5] = {10, 20, 30, 40, 50};\n \n    cout &lt;&lt; &quot;Il primo elemento è: &quot; &lt;&lt; numeri[0] &lt;&lt; endl; // 10\n    cout &lt;&lt; &quot;Il terzo elemento è: &quot; &lt;&lt; numeri[2] &lt;&lt; endl; // 30\n \n    // Modifica di un elemento\n    numeri[1] = 25;\n    cout &lt;&lt; &quot;Il secondo elemento modificato è: &quot; &lt;&lt; numeri[1] &lt;&lt; endl; // 25\n \n    return 0;\n}\n\n\n                  \n                  Nota \n                  \n                \n\n\nAccedere a un indice fuori dai limiti dell’array può causare comportamenti imprevedibili, perché il compilatore non esegue controlli automatici sui limiti.\n\n\n\n\nArray e cicli\nGli array sono spesso utilizzati con i cicli per elaborare tutti gli elementi in modo efficiente. Spesso si usa un ciclo for per scorrere tutti gli elementi di un array, mettendo come condizione di uscita la lunghezza dell’array. Questa operazione si chiama scorrimento.\nEsempio: Somma di tutti gli elementi di un array:\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n\tint d=5;\n    int numeri[d] = {10, 20, 30, 40, 50};\n    int somma = 0;\n \n    for (int i = 0; i &lt; d; i++) {\n        somma += numeri[i];\n    }\n \n    cout &lt;&lt; &quot;La somma degli elementi è: &quot; &lt;&lt; somma &lt;&lt; endl; // 150\n \n    return 0;\n}\n\n\n                  \n                  Esercizio \n                  \n                \n\n\nDato un array di numeri interi, ordinalo in ordine crescente. Hai appena creato un algoritmo di ordinamento, ne esistono vari standard, ognuno con le sue caratteristiche. L’algoritmo che hai inventato esiste già? Come si chiama? Prova a descrivere quali algoritmi di ordinamento esistono e come funzionano, poi prova ad implementarli tutti in un unico programma.\n\n\n\nRange based for (for-each)\nIl ciclo for range-based mi permette di scrivere velocemente un ciclo for per iterare la collezione senza preoccuparmi dei contatori.\nIn questo esempio viene illustrata la differenza tra il ciclo for tradizionale e il range-based for (chiamato anche for-each) in C++. Utilizzeremo un array normale per mostrare come iterare sugli elementi. Il ciclo for tradizionale usa un contatore (di tipo int) per accedere agli elementi, mentre il range-based for semplifica l’iterazione eliminando la gestione manuale dell’indice.\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int numbers[] = {1, 2, 3, 4, 5};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n \n    // Ciclo for tradizionale\n    cout &lt;&lt; &quot;Traditional for loop: &quot;;\n    for (int i = 0; i &lt; size; i++) {\n        cout &lt;&lt; numbers[i] &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n \n    // Ciclo range-based for (foreach)\n    cout &lt;&lt; &quot;Range-based for loop: &quot;;\n    for (int num : numbers) {\n        cout &lt;&lt; num &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n \n    return 0;\n}\nNel primo caso viene utilizzato un indice (di tipo int) per accedere agli elementi dell’array, permettendo un controllo dettagliato dell’iterazione. Nel secondo caso, il ciclo range-based for itera direttamente sugli elementi, semplificando il codice e riducendo il rischio di errori nella gestione dell’indice.\nNelle versioni più recenti di C++, posso utilizzare il tipo di dato auto per inferire automaticamente il tipo di dato dell’elemento che itero dal tipo di dato della collezione.\n\nArray multidimensionali\nGli array possono avere più dimensioni, come una tabella o una matrice.\nSintassi:\ntipo nome_array[righe][colonne];\nEsempio: Matrice 2x3:\nEcco come scorrere una matrice e stamparne il contenuto in modo ordinato. La struttura con i due for annidati è il classico metodo di scorrimento di una matrice:\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int matrice[2][3] = {\n        {1, 2, 3},\n        {4, 5, 6}\n    };\n \n    for (int i = 0; i &lt; 2; i++) {\n        for (int j = 0; j &lt; 3; j++) {\n            cout &lt;&lt; matrice[i][j] &lt;&lt; &quot; &quot;;\n        }\n        cout &lt;&lt; endl;\n    }\n \n    return 0;\n}\nAlgoritmi di ordinamento e complessità asintotica (Big O)\nBig O\nLa notazione Big O è uno strumento fondamentale per descrivere la complessità degli algoritmi, cioè come variano il tempo di esecuzione o l’uso della memoria in funzione della dimensione dell’input, soprattutto per valori grandi.\nBig O esprime il limite superiore della crescita di una funzione. In altre parole, indica l’ordine di grandezza del tempo (o spazio) necessario man mano che l’input n aumenta. Le costanti e i termini meno significativi vengono ignorati per concentrarsi sul comportamento asintotico.\n\nO(1): Tempo costante. L’algoritmo esegue lo stesso numero di operazioni, indipendentemente dalla dimensione dell’input.\nO(n): Tempo lineare. Il numero di operazioni cresce proporzionalmente a n, come in un ciclo che attraversa l’intero array.\nO(n²): Tempo quadratico. Tipico di algoritmi con cicli annidati, dove il numero di operazioni è proporzionale al quadrato di n.\nO(log n): Tempo logaritmico. L’algoritmo riduce il problema in maniera esponenziale ad ogni iterazione, tipico di ricerche in strutture ordinate (ad esempio, la ricerca binaria).\nO(n log n): Complessità intermedia, comune in algoritmi di ordinamento efficienti come Merge Sort e Quick Sort nella media dei casi.\n\nBubble Sort\nL’algoritmo ha complessità O(n²) nel caso medio e peggiore, mentre nel caso migliore (array già ordinato) si comporta in O(n).\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    // Bubble Sort: iterazione esterna per n-1 passate\n    for (int i = 0; i &lt; n - 1; i++) {\n        // Ogni passata posiziona l&#039;elemento massimo al fondo\n        for (int j = 0; j &lt; n - i - 1; j++) {\n            // Confronta elementi adiacenti e scambia se fuori ordine\n            if (arr[j] &gt; arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n    \n    // Stampa dell&#039;array ordinato\n    for (int i = 0; i &lt; n; i++) {\n        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n    \n    return 0;\n}\nSelection Sort\nL’algoritmo Selection Sort seleziona in ogni iterazione l’elemento minimo dalla parte non ordinata e lo scambia con il primo elemento non ordinato. La complessità è sempre O(n²).\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int arr[] = {29, 10, 14, 37, 13};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    // Selection Sort: per ogni posizione, trova il minimo nell&#039;intervallo non ordinato\n    for (int i = 0; i &lt; n - 1; i++) {\n        int min_idx = i; // ipotizza che l&#039;elemento corrente sia il minimo\n        // Cerca il minimo nell&#039;array da i+1 a n-1\n        for (int j = i + 1; j &lt; n; j++) {\n            if (arr[j] &lt; arr[min_idx])\n                min_idx = j;\n        }\n        // Scambia l&#039;elemento corrente con il minimo trovato\n        int temp = arr[i];\n        arr[i] = arr[min_idx];\n        arr[min_idx] = temp;\n    }\n    \n    // Stampa dell&#039;array ordinato\n    for (int i = 0; i &lt; n; i++) {\n        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n    \n    return 0;\n}\nInsertion Sort\nInsertion Sort costruisce progressivamente una porzione ordinata dell’array, inserendo ogni nuovo elemento nella sua posizione corretta. Ha complessità O(n) nel caso migliore e O(n²) in quello medio/peggiore.\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int arr[] = {12, 11, 13, 5, 6};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    // Insertion Sort: a partire dal secondo elemento, inserisce ogni elemento nell&#039;array ordinato a sinistra\n    for (int i = 1; i &lt; n; i++) {\n        int key = arr[i]; // elemento da inserire\n        int j = i - 1;\n        // Sposta gli elementi maggiori di key verso destra per fare spazio\n        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        // Inserisce key nella posizione corretta\n        arr[j + 1] = key;\n    }\n    \n    // Stampa dell&#039;array ordinato\n    for (int i = 0; i &lt; n; i++) {\n        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n    \n    return 0;\n}\nMerge Sort (Iterativo)\nMerge Sort divide l’array in sottoarray più piccoli, li ordina e poi li fonde. L’implementazione qui proposta è iterativa e ha complessità O(n log n).\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt; // per std::min\nusing namespace std;\n \nint main() {\n    int arr[] = {38, 27, 43, 3, 9, 82, 10};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int temp[100]; // Array temporaneo per la fusione, supponendo n &lt;= 100\n \n    // curr_size indica la dimensione corrente dei sottoarray da fondere\n    for (int curr_size = 1; curr_size &lt; n; curr_size *= 2) {\n        // left_start indica l&#039;inizio di ogni coppia di sottoarray da fondere\n        for (int left_start = 0; left_start &lt; n; left_start += 2 * curr_size) {\n            // Calcola il punto medio e l&#039;estremo destro, gestendo i casi in cui la dimensione non sia multipla di curr_size\n            int mid = min(left_start + curr_size, n);\n            int right_end = min(left_start + 2 * curr_size, n);\n            int i = left_start, j = mid, k = left_start;\n            \n            // Fusione dei due sottoarray ordinati in temp[]\n            while (i &lt; mid &amp;&amp; j &lt; right_end) {\n                if (arr[i] &lt;= arr[j])\n                    temp[k++] = arr[i++];\n                else\n                    temp[k++] = arr[j++];\n            }\n            // Copia gli elementi rimanenti del sottoarray sinistro, se presenti\n            while (i &lt; mid)\n                temp[k++] = arr[i++];\n            // Copia gli elementi rimanenti del sottoarray destro, se presenti\n            while (j &lt; right_end)\n                temp[k++] = arr[j++];\n                \n            // Copia il risultato della fusione nell&#039;array originale\n            for (int p = left_start; p &lt; right_end; p++)\n                arr[p] = temp[p];\n        }\n    }\n    \n    // Stampa dell&#039;array ordinato\n    for (int i = 0; i &lt; n; i++)\n        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\n    cout &lt;&lt; endl;\n    \n    return 0;\n}\nQuick Sort (Iterativo)\nQuick Sort utilizza il paradigma divide-et-impera scegliendo un pivot e partizionando l’array. La versione iterativa qui usa uno stack per gestire gli intervalli. La complessità media è O(n log n), mentre il caso peggiore è O(n²).\n#include &lt;iostream&gt;\n#include &lt;stack&gt;\nusing namespace std;\n \nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    // Stack per memorizzare coppie (inizio, fine) degli intervalli da ordinare\n    stack&lt;pair&lt;int, int&gt;&gt; s;\n    s.push({0, n - 1});\n    \n    while (!s.empty()) {\n        int l = s.top().first;\n        int h = s.top().second;\n        s.pop();\n        \n        // Partizione dell&#039;intervallo corrente utilizzando lo schema di Lomuto\n        int pivot = arr[h]; // Si sceglie l&#039;ultimo elemento come pivot\n        int i = l - 1;      // Indice dell&#039;ultimo elemento minore del pivot\n        for (int j = l; j &lt;= h - 1; j++) {\n            if (arr[j] &lt; pivot) {\n                i++;\n                // Scambia arr[i] e arr[j]\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n        // Posiziona il pivot nella posizione corretta\n        int p = i + 1;\n        int temp = arr[p];\n        arr[p] = arr[h];\n        arr[h] = temp;\n        \n        // Se ci sono elementi a sinistra del pivot, li aggiunge allo stack\n        if (p - 1 &gt; l)\n            s.push({l, p - 1});\n        // Se ci sono elementi a destra del pivot, li aggiunge allo stack\n        if (p + 1 &lt; h)\n            s.push({p + 1, h});\n    }\n    \n    // Stampa dell&#039;array ordinato\n    for (int i = 0; i &lt; n; i++)\n        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\n    cout &lt;&lt; endl;\n    \n    return 0;\n}\nHeap Sort\nHeap Sort sfrutta un max heap per ordinare l’array. Dopo aver costruito il max heap (complessità O(n)), estrae ripetutamente il massimo e ricostruisce il heap, ottenendo una complessità complessiva O(n log n).\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    // Costruzione del max heap:\n    // Partiamo dall&#039;ultimo nodo non foglia: n/2 - 1 e andiamo a ritroso\n    for (int i = n / 2 - 1; i &gt;= 0; i--) {\n        int root = i;\n        // Heapify: corregge la struttura del heap per il nodo corrente\n        while (true) {\n            int left = 2 * root + 1;   // indice del figlio sinistro\n            int right = 2 * root + 2;  // indice del figlio destro\n            int largest = root;\n            if (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])\n                largest = left;\n            if (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])\n                largest = right;\n            // Se il nodo corrente non è il più grande, scambia e continua l&#039;heapify\n            if (largest != root) {\n                int temp = arr[root];\n                arr[root] = arr[largest];\n                arr[largest] = temp;\n                root = largest;\n            } else {\n                break;\n            }\n        }\n    }\n    \n    // Ordinamento: estrae ripetutamente il massimo e ricostruisce il max heap\n    for (int i = n - 1; i &gt; 0; i--) {\n        // Scambia la radice (massimo) con l&#039;ultimo elemento dell&#039;heap\n        int temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n        int heap_size = i; // Riduce la dimensione del heap\n        int root = 0;\n        // Heapify per ripristinare il max heap nella parte rimanente\n        while (true) {\n            int left = 2 * root + 1;\n            int right = 2 * root + 2;\n            int largest = root;\n            if (left &lt; heap_size &amp;&amp; arr[left] &gt; arr[largest])\n                largest = left;\n            if (right &lt; heap_size &amp;&amp; arr[right] &gt; arr[largest])\n                largest = right;\n            if (largest != root) {\n                int temp = arr[root];\n                arr[root] = arr[largest];\n                arr[largest] = temp;\n                root = largest;\n            } else {\n                break;\n            }\n        }\n    }\n    \n    // Stampa dell&#039;array ordinato\n    for (int i = 0; i &lt; n; i++)\n        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\n    cout &lt;&lt; endl;\n    \n    return 0;\n}\nConsiderazioni Finali\nOgni algoritmo ha vantaggi e svantaggi in termini di complessità computazionale e utilizzo della memoria.\n\nBubble, Selection e Insertion Sort: Semplici da implementare ma inefficienti per grandi dataset (O(n²)).\nMerge, Quick e Heap Sort: Offrono prestazioni migliori (O(n log n) in media), anche se possono richiedere maggiore gestione della memoria o attenzioni particolari (come la scelta del pivot in Quick Sort).\nLa scelta dell’algoritmo dipende dalle specifiche esigenze e dai vincoli dell’applicazione.\n\n\nEsercizi sugli Array\n\n\n                  \n                  Esercizi \n                  \n                \n\n\n\n\nInserimento e stampa\nScrivi un programma che chiede all’utente di inserire 5 numeri interi in un array e li stampa in ordine inverso.\n\n\nSomma e media\nScrivi un programma che calcola la somma e la media degli elementi di un array.\n\n\nTrova il massimo e il minimo\nScrivi un programma che trova l’elemento massimo e minimo in un array di numeri interi.\n\n\nSomma delle righe di una matrice\nScrivi un programma che legge una matrice 3x3 e calcola la somma di ciascuna riga.\n\n\nProdotto scalare\nScrivi un programma che calcola il prodotto scalare di due vettori di dimensione n, dove n è fornito dall’utente.\n\n\n\n\n\nStringhe\nUna stringa in C++ è una sequenza di caratteri terminata dal carattere speciale \\0. Esistono due modi principali per lavorare con le stringhe:\n\nArray di caratteri\nClasse string della libreria standard\n\n\nArray di Caratteri\nGli array di caratteri rappresentano una stringa in stile C. Ogni elemento è un carattere e l’ultimo carattere deve essere il terminatore \\0.\nEsempio:\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    char saluto[6] = {&#039;H&#039;, &#039;e&#039;, &#039;l&#039;, &#039;l&#039;, &#039;o&#039;, &#039;\\0&#039;}; // Array di caratteri\n    cout &lt;&lt; saluto &lt;&lt; endl;\n \n    return 0;\n}\n\n\n                  \n                  Nota \n                  \n                \n\n\nSenza il carattere \\0, il programma potrebbe leggere dati al di fuori della stringa causando comportamenti imprevedibili.\n\n\n\nTuttavia, lavorare con gli array di caratteri è meno intuitivo e richiede l’uso della libreria &lt;cstring&gt; per molte operazioni. Per questo motivo, in C++ moderno è preferibile utilizzare la classe string.\n\nClasse string\nLa classe string della libreria standard rende il lavoro con le stringhe molto più semplice e intuitivo rispetto agli array di caratteri. Non è necessario preoccuparsi del terminatore \\0, e offre numerosi metodi per manipolare le stringhe.\nPer utilizzare la classe string, devi includere la libreria &lt;string&gt;.\nEsempio base:\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n \nint main() {\n    string saluto = &quot;Ciao, mondo!&quot;;\n    cout &lt;&lt; &quot;Stringa: &quot; &lt;&lt; saluto &lt;&lt; endl;\n    cout &lt;&lt; &quot;Lunghezza: &quot; &lt;&lt; saluto.length() &lt;&lt; endl;\n \n    return 0;\n}\n\nInserire una stringa con spazi in input\nIn C++, per leggere da input una stringa che contiene spazi (come ad esempio &quot;ciao come stai&quot;), non si può usare il classico std::cin &gt;&gt; variabile, perché questo metodo si ferma al primo spazio.\nSe utilizzo:\nstring frase;\ncin &gt;&gt; frase;\nSe l’utente inserisce:\nciao come stai\n\nLa variabile frase conterrà solo &quot;ciao&quot;.\nIl comportamento di cin &gt;&gt; variabile è progettato per leggere una parola alla volta, cioè si ferma su spazi, tabulazioni o invii. È utile per leggere input divisi da spazi (come numeri o parole singole), ma non va bene per intere frasi.\nSoluzione: usare getline\nPer leggere l’intera riga, inclusi gli spazi, si usa:\nstring frase;\ngetline(cin, frase);\nQuesto legge tutti i caratteri fino al carattere di a capo (\\n), cioè quando l’utente preme Invio.\n\nOperazioni di Base con la Classe string\n\nConcatenazione di stringhe\nPuoi concatenare due stringhe utilizzando l’operatore + o +=. L’operatore + restituisce una nuova stringa concatenata, mentre += modifica la stringa a sinistra aggiungendo quella a destra.\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n \nint main() {\n    string s1 = &quot;Ciao&quot;;\n    string s2 = &quot;, mondo!&quot;;\n    string risultato = s1 + s2; // Restituisce una nuova stringa\n    cout &lt;&lt; risultato &lt;&lt; endl; // Output: Ciao, mondo!\n \n    return 0;\n}\n\n\n\n                  \n                  Nota \n                  \n                \n\n\nPer la prima volta nei prossimi esempi, vedrai in azione quella che si chiama chiamata di funzione (se vogliamo essere più pignoli, in questo caso si chiamano metodi dato che string è una classe… ma non trattiamo di programmazione orientata agli oggetti in questa dispensa). In uno dei capitoli vedremo cosa sono le funzioni, a cosa servono e come si implementano. Per ora prendile per buone, come se magicamente facessero quello che desideri chiamandole come vedi nel codice e mettendo gli argomenti nell’ordine richiesto.\n\n\n\n\nAccesso ai caratteri\nPuoi accedere ai singoli caratteri di una stringa usando l’operatore [] o il metodo at(). Entrambi richiedono come argomento l’indice del carattere (a partire da 0).\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n \nint main() {\n    string saluto = &quot;Ciao&quot;;\n \n    cout &lt;&lt; saluto[1] &lt;&lt; endl;  // Output: i (accesso diretto tramite indice)\n    cout &lt;&lt; saluto.at(2) &lt;&lt; endl; // Output: a (metodo membro che controlla i limiti)\n \n    // Nota: `at()` lancia un&#039;eccezione se l&#039;indice è fuori dai limiti.\n    return 0;\n}\n\n\n                  \n                  Nota \n                  \n                \n\n\nCon la classe string, in realtà anche l’accesso diretto all’indice si comporta come at, ovvero controlla i limiti. Nei casi invece si usi una cstring classica (array di carattery) allora at e l’accesso diretto si comportano in modo diverso.\n\n\n\n\n\nLunghezza della stringa\nUsa il metodo length() o size() (sono equivalenti) per ottenere la lunghezza della stringa. Non richiedono argomenti.\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n \nint main() {\n    string saluto = &quot;Hello, World!&quot;;\n    cout &lt;&lt; &quot;Lunghezza: &quot; &lt;&lt; saluto.length() &lt;&lt; endl; // Output: 13\n    cout &lt;&lt; &quot;Lunghezza (size): &quot; &lt;&lt; saluto.size() &lt;&lt; endl; // Output: 13\n \n    return 0;\n}\n\n\nSottostringhe\nIl metodo substr() restituisce una parte della stringa. Richiede due argomenti:\n\n\nPosizione iniziale (indice da cui iniziare la sottostringa).\nLunghezza (numero di caratteri da includere nella sottostringa).\n\nSe ometti il secondo argomento, restituisce tutti i caratteri fino alla fine della stringa.\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n \nint main() {\n    string saluto = &quot;Ciao, mondo!&quot;;\n \n    string parte1 = saluto.substr(0, 4); // Da indice 0, prendi 4 caratteri\n    cout &lt;&lt; parte1 &lt;&lt; endl; // Output: Ciao\n \n    string parte2 = saluto.substr(6); // Da indice 6 fino alla fine\n    cout &lt;&lt; parte2 &lt;&lt; endl; // Output: mondo!\n \n    return 0;\n}\n\n\nRicerca\nUsa il metodo find() per trovare la posizione di una sottostringa.\nRichiede come argomento:\n\n\nSottostringa da cercare.\nFacoltativamente, puoi specificare un secondo argomento:\nPosizione iniziale da cui avviare la ricerca.\n\nRestituisce l’indice della prima occorrenza o string::npos se non trova la sottostringa.\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n \nint main() {\n    string testo = &quot;Benvenuto al mondo della programmazione!&quot;;\n \n    size_t posizione = testo.find(&quot;mondo&quot;); // Cerca &quot;mondo&quot;\n    if (posizione != string::npos) {\n        cout &lt;&lt; &quot;Trovato &#039;mondo&#039; in posizione: &quot; &lt;&lt; posizione &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; &quot;&#039;mondo&#039; non trovato.&quot; &lt;&lt; endl;\n    }\n \n    return 0;\n}\n\n\nSostituzione\nIl metodo replace() sostituisce una parte della stringa.\nRichiede tre argomenti:\n\n\nIndice iniziale (da dove iniziare la sostituzione).\nLunghezza (numero di caratteri da sostituire).\nNuova stringa (stringa con cui sostituire).\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n \nint main() {\n    string testo = &quot;Ciao, universo!&quot;;\n \n    testo.replace(6, 8, &quot;mondo&quot;); // Sostituisci 8 caratteri a partire dall&#039;indice 6 con &quot;mondo&quot;\n    cout &lt;&lt; testo &lt;&lt; endl; // Output: Ciao, mondo!\n \n    return 0;\n}\n\n\nCancellare\nIl metodo erase() rimuove una parte della stringa.\nPuò essere usato in due modi:\n\n\nCon un solo argomento: rimuove tutti i caratteri dall’indice specificato in poi.\nCon due argomenti: specifica l’indice iniziale e il numero di caratteri da rimuovere.\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n \nint main() {\n    string saluto = &quot;Ciao, mondo!&quot;;\n \n    saluto.erase(5); // Rimuovi tutto da indice 5 in poi\n    cout &lt;&lt; saluto &lt;&lt; endl; // Output: Ciao,\n \n    saluto = &quot;Ciao, mondo!&quot;;\n    saluto.erase(5, 6); // Rimuovi 6 caratteri a partire dall&#039;indice 5\n    cout &lt;&lt; saluto &lt;&lt; endl; // Output: Ciao!\n \n    return 0;\n}\n\n\n                  \n                  Esercizio \n                  \n                \n\n\nImpara ad usare la documentazione. Cerca online la documentazione C++ sulle stringhe, guarda quali funzioni trovi, quali sono le loro signature (combinazione di nome e argomenti). Le hai trovate tutte? Hai trovato altre funzioni utili che vuoi aggiungere? (Continuo a chiamarle funzioni, ma ricorda che in realtà questi sono metodi).\n\n\n\n\nEsercizi sulle Stringhe\n\n\n                  \n                  Esercizi \n                  \n                \n\n\n\nLunghezza della stringa\nScrivi un programma che chiede all’utente di inserire una stringa e stampa la sua lunghezza.\nInvertire una stringa\nScrivi un programma che legge una stringa e la stampa al contrario.\nContare i caratteri\nScrivi un programma che conta quante volte un determinato carattere appare in una stringa fornita dall’utente.\nSostituzione di parole\nScrivi un programma che sostituisce tutte le occorrenze di una parola con un’altra in una stringa fornita dall’utente.\n\n\n\n\n\n\n                  \n                  Nota \n                  \n                \n\n\nGiocare con le stringhe con input e output da console è utile per imparare come funzionano, ma le cose si fanno sicuramente più interessanti una volta che impariamo ad utilizzare l’input e output da file nel capitolo dedicato.\n\n\n\n\nStruct\nLe struct permettono di raggruppare dati di tipi diversi sotto un unico nome. Sono particolarmente utili per rappresentare oggetti complessi, permettendoti di creare a tutti gli effetti un nuovo tipo di dato tuo che rappresenta quell’oggetto complesso. È ciò di più vicino che esiste alle classi, che imparerai ad utilizzare quando programmerai a oggetti.\nDichiarazione e Uso di una Struct\nSintassi:\nstruct nome_struttura {\n    tipo_dato campo1;\n    tipo_dato campo2;\n};\nEsempio:\n#include &lt;iostream&gt;\nusing namespace std;\n \nstruct Persona {\n    string nome;\n    int eta;\n    float altezza;\n};\n \nint main() {\n    Persona p1; // Dichiarazione di una variabile di tipo Persona\n \n    // Assegnazione dei valori\n    p1.nome = &quot;Mario Rossi&quot;;\n    p1.eta = 20;\n    p1.altezza = 28.5;\n \n    // Stampa dei valori\n    cout &lt;&lt; &quot;Nome: &quot; &lt;&lt; p1.nome &lt;&lt; endl;\n    cout &lt;&lt; &quot;Età: &quot; &lt;&lt; p1.eta &lt;&lt; endl;\n    cout &lt;&lt; &quot;Altezza: &quot; &lt;&lt; p1.altezza &lt;&lt; endl;\n \n    return 0;\n}\nOutput:\nNome: Mario Rossi  \nEtà: 20  \nAltezza: 28.5\n\n\n\n                  \n                  Nota \n                  \n                \n\n\nEssendo a tutti gli effetti un nuovo tipo di dato, puoi utilizzarli come tali. Quindi puoi ad esempio creare un array di studenti per creare una classe di scuola. Non sei limitato solo a questo, dentro gli array ci puoi mettere altri array, per cui puoi mettere le tue classi scolastiche all’interno di un altro array per creare una scuola. Tutti gli strumenti che hai visto finora possono essere combinati insieme con infinite potenzialità. Cosa vuoi creare di nuovo?\n\n\n\n\n\n                  \n                  Libera la fantasia \n                  \n                \n\n\nCrea un oggetto molto complesso ed elaboralo utilizzando la fantasia e gli strumenti che hai visto finora.\n\n\n\nEsercizi\n\n\n                  \n                  Esercizi \n                  \n                \n\n\n\n\nGestione di una rubrica\nCrea un programma che gestisce una rubrica telefonica utilizzando un array di struct. Ogni contatto deve contenere:\n\n\n\nNome (stringa)\nNumero di telefono (stringa)\nEmail (stringa)\n\nIl programma deve permettere di:\n\nAggiungere un nuovo contatto.\nCercare un contatto per nome e visualizzarne i dettagli.\nStampare tutti i contatti.\n\nEsempio di output:\n1. Aggiungi contatto\n2. Cerca contatto\n3. Mostra tutti i contatti\n4. Esci\nScegli un&#039;opzione: 1\n\nInserisci nome: Mario Rossi\nInserisci numero di telefono: 123456789\nInserisci email: mario.rossi@email.com\n\nScegli un&#039;opzione: 3\nContatti:\n1. Mario Rossi - 123456789 - mario.rossi@email.com\n\n\n\nAnalisi di una tabella di studenti\n\nScrivi un programma che gestisce i dati di una classe. Per ogni studente memorizza:\n\nNome (stringa)\nCognome (stringa)\nVoti di 5 materie (array di interi)\n\nIl programma deve:\n\nLeggere i dati di almeno 5 studenti.\nCalcolare la media dei voti per ciascuno studente.\nStampare i dettagli dello studente con la media più alta.\n\nEsempio di output:\nInserisci i dati dello studente 1:\nNome: Luca\nCognome: Bianchi\nVoti: 8 9 7 10 9\n\nInserisci i dati dello studente 2:\nNome: Maria\nCognome: Rossi\nVoti: 6 7 8 6 7\n\nStudente con la media più alta:\nLuca Bianchi - Media: 8.6\n\n\n\nGestione di un inventario\n\nCrea un programma per gestire l’inventario di un negozio. Ogni prodotto è rappresentato da una struct contenente:\n\nNome prodotto (stringa)\nQuantità (intero)\nPrezzo unitario (double)\n\nIl programma deve:\n\nAggiungere prodotti all’inventario.\nCercare un prodotto per nome e mostrarne i dettagli.\nCalcolare il valore totale dell’inventario.\n\nEsempio di output:\n1. Aggiungi prodotto\n2. Cerca prodotto\n3. Calcola valore totale inventario\n4. Esci\n\nScegli un&#039;opzione: 1\nNome prodotto: Laptop\nQuantità: 5\nPrezzo unitario: 899.99\n\nScegli un&#039;opzione: 3\nValore totale dell&#039;inventario: 4499.95\n\n\n\nAnalisi di testo\n\nScrivi un programma che analizza un paragrafo di testo fornito dall’utente. Il programma deve:\n\nContare il numero di parole nel testo.\nContare quante volte ogni parola appare (usa un array di struct dove ogni struct contiene una parola e il relativo conteggio).\nStampare l’elenco delle parole con il loro conteggio.\n\nEsempio di output:\nInserisci un testo:\nBenvenuti al corso di programmazione. Programmazione è divertente.\n\nAnalisi:\nNumero totale di parole: 7\nParole e frequenze:\n- Benvenuti: 1\n- al: 1\n- corso: 1\n- di: 1\n- programmazione: 2\n- è: 1\n- divertente: 1\n\n\n\nGioco del tris\n\nImplementa il gioco del tris (tic-tac-toe) utilizzando:\n\nUna matrice 3x3 per rappresentare il tabellone.\nStringhe per i nomi dei due giocatori.\nLogica per determinare se un giocatore ha vinto o se c’è un pareggio.\n\nRequisiti:\n\nIl programma deve permettere ai giocatori di inserire i propri nomi.\nAlternativamente, i giocatori inseriscono la loro mossa.\nDopo ogni mossa, il programma verifica se c’è un vincitore o un pareggio.\n\nEsempio di output:\nInserisci il nome del Giocatore 1: Alice\nInserisci il nome del Giocatore 2: Bob\n\nTabellone attuale:\n 1 | 2 | 3\n-----------\n 4 | 5 | 6\n-----------\n 7 | 8 | 9\n\nAlice, inserisci la tua mossa (1-9): 1\n\nTabellone attuale:\n X | 2 | 3\n-----------\n 4 | 5 | 6\n-----------\n 7 | 8 | 9\n\nBob, inserisci la tua mossa (1-9): 5\n...\n\n\n\n\n\n\n                  \n                  Nota \n                  \n                \n\n\nCon questi esercizi ti sarai sicuramente reso conto di una cosa… Il tuo codice sta diventando davvero lungo e difficile da leggere, inoltre in varie occasioni, potresti esserti accorto di aver copiato e incollato del codice (uno dei peccati mortali della programmazione, e spiegheremo perché). Il prossimo capitolo fa al caso tuo, perché imparerai ad usare le funzioni e a risolvere tutti questi problemi in modo più efficace!\n\n\n\n\nCapitolo 5: Funzioni e Modularizzazione\nIntroduzione\nLe funzioni sono uno strumento che permettono di suddividere un programma complesso in parti più piccole, gestibili e riutilizzabili (persino al di fuori del programma), migliorando la leggibilità, la manutenzione e il riutilizzo del codice.\nIn C++, una funzione è un blocco di codice che esegue un compito specifico (una funzione che svolge più di un compito è un cosiddetto “code smell”, puoi approfondire sulla dispensa sui code smells quando sarà il momento). Una funzione può ricevere dati in ingresso (parametri) e restituire un dato in uscita (valore di ritorno).\nvalori in ingresso → elaborazione dei dati → valore in uscita\nAlcuni linguaggi di programmazione ad alto livello di astrazione possono anche ritornare più valori.\n\nDichiarazione e Definizione di una Funzione\nSintassi\nUna funzione in C++ è definita nel seguente modo:\ntipo_di_ritorno nome_funzione(parametro1, parametro2, ...) {\n    // Corpo della funzione: blocco di istruzioni\n    return valore; // opzionale, solo se tipo_di_ritorno non è void\n}\n\ntipo_di_ritorno: specifica il tipo di dato che la funzione restituisce (es. int, float…). Può anche restituire un tipo particolare detto void; in questo caso non sono obbligato a mettere return (a meno che non voglia uscire dalla funzione in un punto diverso dalla fine in alcuni casi) e la funzione non restituirà nessun valore.\nnome_funzione: è il nome con cui la funzione viene chiamata.\nparametri: valori di ingresso (facoltativi) che la funzione utilizza.\n\n\n\n                  \n                  Nota \n                  \n                \n\n\nUna funzione può ricevere in ingresso o restituire anche dei puntatori di memoria (più approfondimenti nel capitolo dedicato). Questo mi permette di utilizzare anche oggetti più complessi come gli array (in modo implicito grazie al livello di astrazione di C++).\n\n\n\nEsempio di Funzione con parametri\nCalcolare il massimo di due numeri:\n#include &lt;iostream&gt;\nusing namespace std;\n \n// Dichiarazione della funzione\nint max(int a, int b) {\n    if(a&gt;b) \n    \treturn a;\n    return b;\n}\n \nint main() {\n    int x,y;\n    cout &lt;&lt; &quot;Inserisci i due numeri &quot; &lt;&lt; endl;\n    cin&gt;&gt;x&gt;&gt;y;\n    int risultato = max(x, y); // Chiamata alla funzione\n    cout &lt;&lt; &quot;Il numero più grande è: &quot; &lt;&lt; risultato &lt;&lt; endl;\n    return 0;\n}\n\n\n                  \n                  Nota \n                  \n                \n\n\nCome mai in questo esempio non ho usato else?\n\n\n\nPosso anche passare un array (devo ricordarmi di passare anche le dimensioni):\n#include &lt;iostream&gt;\nusing namespace std;\n \n// Funzione per stampare gli elementi di un array\nvoid printArray(int arr[], int size) {\n    for (int i = 0; i &lt; size; i++) {\n        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n}\n \nint main() {\n    // Dichiarazione dell&#039;array\n    int numbers[] = {5, 10, 15, 20, 25};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n \n    // Chiamata alla funzione per stampare l&#039;array\n    printArray(numbers, size);\n \n    return 0;\n}\n \n\n\n                  \n                  Nota \n                  \n                \n\n\nIn questo programma ho usato un metodo particolare per calcolare la dimensione dell’array (ci sono casi in cui mi può essere utile) in questa linea int size = sizeof(numbers) / sizeof(numbers[0]);.\nLa funzione di sistema sizeof mi restituisce la memoria occupata da un oggetto in memoria in byte. In questo caso io prendo la dimensione intera dell’array e la divido per la dimensione di ogni singolo elemento (prendo il primo). La dimensione di un numero intero in memoria è di 4 byte e l’intero array occupa 20 byte. Pertanto 20/4=5, ovvero la dimensione dell’array.\n\n\n\n\nFunzione senza Valore di Ritorno (void)\nUna funzione che non restituisce alcun valore utilizza il tipo void. Potrebbe essere una funzione che fa semplicemente output o una funzione che manipola dati passati come riferimento (vedi dopo).\n#include &lt;iostream&gt;\nusing namespace std;\n \nvoid saluta() {\n    cout &lt;&lt; &quot;Ciao, benvenuto nel programma!&quot; &lt;&lt; endl;\n}\n \nint main() {\n    saluta(); // Chiamata alla funzione\n    return 0;\n}\n\nPassaggio di Parametri\nI parametri possono essere passati in due modi principali:\n\nPassaggio per Valore\n\n\nIl valore della variabile viene copiato nella funzione.\nLe modifiche alla variabile non influenzano l’originale.\n\n#include &lt;iostream&gt;\nusing namespace std;\n \nvoid incrementa(int n) {\n\tn++;\n}\n \nint main() {\n\tint numero = 5;\n\tincrementa(numero);\n\tincrementa(numero);\n\tincrementa(numero);\n\tcout &lt;&lt; numero &lt;&lt; endl;\n\treturn 0;\n}\n\nPassaggio per Riferimento\n\n\nLa funzione riceve un riferimento alla variabile originale.\nLe modifiche effettuate influenzano il valore originale.\n\n#include &lt;iostream&gt;\nusing namespace std;\n \nvoid incrementa(int &amp;n) {\n\tn++;\n}\n \nint main() {\n\tint numero = 5;\n\tincrementa(numero);\n\tincrementa(numero);\n\tincrementa(numero);\n\tcout &lt;&lt; numero &lt;&lt; endl;\n\treturn 0;\n}\n\n\n                  \n                  Nota \n                  \n                \n\n\nProva ad eseguire entrambi i programmi. Cosa succede? Per quale motivo?\n\n\n\nPassaggio di array\nCome detto prima, passare un array o un oggetto complesso equivale sempre a passarlo come riferimento (senza la &amp; prima del parametro, metterla da errore).\nPuoi verificarlo con questa versione modificata del precedente programma:\n#include &lt;iostream&gt;\nusing namespace std;\n \n// Funzione per stampare gli elementi di un array\nvoid printArray(const int arr[], int &amp;size) {\n    for (int i = 0; i &lt; size; i++) {\n        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n}\n \nvoid modifyArray(int arr[], int size){\n    arr[0] = 0;\n}\n \nint main() {\n    // Dichiarazione dell&#039;array\n    int numbers[] = {5, 10, 15, 20, 25};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n    modifyArray(numbers, size); // Questa chiamata ha effetto sull&#039;array\n \n    // Chiamata alla funzione per stampare l&#039;array\n    printArray(numbers, size);\n \n    return 0;\n}\n\nFunzioni Ricorsive\nUna funzione è ricorsiva se chiama sé stessa al proprio interno. La ricorsione è utile per risolvere problemi che possono essere suddivisi in sottoproblemi più semplici.\nEsempio: Calcolo del Fattoriale\nIl fattoriale di un numero n (indicato come n!) è definito come:\n\nn! = n * (n-1) * (n-2) * ... * 1\nCaso base: 0! = 1\n\nImplementazione:\n#include &lt;iostream&gt;\nusing namespace std;\n \nint fattoriale(int n) {\n    if (n == 0) { // Caso base\n        return 1;\n    } else {\n        return n * fattoriale(n - 1); // Passo ricorsivo\n    }\n}\n \nint main() {\n    int numero;\n    cout &lt;&lt; &quot;Inserisci un numero: &quot;;\n    cin &gt;&gt; numero;\n    cout &lt;&lt; &quot;Il fattoriale di &quot; &lt;&lt; numero &lt;&lt; &quot; è: &quot; &lt;&lt; fattoriale(numero) &lt;&lt; endl;\n    return 0;\n}\n\n\nCaso Base: Se n è uguale a 0 o 1, il programma restituisce direttamente 1 perché il fattoriale di 0 e 1 è definito come 1.\n\n\nChiamata Ricorsiva: Per un valore di n maggiore di 1, la funzione richiama sé stessa passando come argomento n - 1. Questo crea una serie di chiamate che si accumulano sulla stack finché non viene raggiunto il caso base.\n\n\nRisoluzione: Una volta raggiunto il caso base, la funzione risolve le chiamate impilate, moltiplicando i risultati intermedi per calcolare il fattoriale.\n\n\nEsempio di Esecuzione per n = 5:\n\nfattoriale(5) chiama 5 * fattoriale(4)\nfattoriale(4) chiama 4 * fattoriale(3)\nfattoriale(3) chiama 3 * fattoriale(2)\nfattoriale(2) chiama 2 * fattoriale(1)\nfattoriale(1) restituisce 1 (caso base)\n\nOra si calcolano i risultati tornando indietro lungo la stack:\n\nfattoriale(2) restituisce 2 * 1 = 2\nfattoriale(3) restituisce 3 * 2 = 6\nfattoriale(4) restituisce 4 * 6 = 24\nfattoriale(5) restituisce 5 * 24 = 120\n\nIl risultato finale è 120.\n\n\n                  \n                  Nota \n                  \n                \n\n\nCome viene detto nel passaggio 2, la funzione ricorsiva accumula la serie di chiamate sullo stack; pertanto una funzione ricorsiva consuma molta più memoria di una funzione iterativa!\n\n\n\n\nGli scopes\nLe funzioni possono essere considerate come piccoli programmi autonomi all’interno di un programma più grande.\nScope nelle funzioni\nLo scope si riferisce alla visibilità e al ciclo di vita delle variabili, e mi permettono di mantenere il giusto grado di isolamento tra le varie funzioni del programma. Possiamo distinguere tra:\n\n\nScope locale:\n\n\nLe variabili definite all’interno di una funzione sono locali alla funzione e non possono essere accedute al di fuori di essa.\n\n\nQueste variabili vengono create quando la funzione viene chiamata e distrutte quando la funzione termina.\n\n\nEsempio:\nvoid exampleFunction() {\n    int localVar = 10; // Variabile locale\n    cout &lt;&lt; localVar &lt;&lt; endl;\n}\n\n\n\n\nScope globale:\n\n\nLe variabili definite al di fuori di tutte le funzioni hanno scope globale e possono essere accedute da qualsiasi funzione nel programma.\n\n\nDevono essere usate con cautela, perché possono introdurre dipendenze indesiderate.\n\n\nEsempio:\nint globalVar = 20; // Variabile globale\n \nvoid printGlobal() {\n    cout &lt;&lt; globalVar &lt;&lt; endl;\n}\n\n\n\n\nScope di parametri:\n\n\nI parametri di una funzione sono locali alla funzione stessa. Quando vengono passati dei valori, questi parametri sono una copia dei dati (se non si usa il riferimento).\n\n\nEsempio:\nvoid printNumber(int number) { // &quot;number&quot; è locale alla funzione\n    cout &lt;&lt; number &lt;&lt; endl;\n}\n\n\n\n\nShadowing:\n\n\nUna variabile locale con lo stesso nome di una variabile globale “nasconde” quest’ultima all’interno della funzione.\n\n\nEsempio:\nint x = 5; // Variabile globale\n \nvoid exampleFunction() {\n    int x = 10; // Variabile locale &quot;x&quot; nasconde quella globale\n    cout &lt;&lt; x &lt;&lt; endl; // Stampa 10\n}\n\n\n\n\n\n\n                  \n                  Nota \n                  \n                \n\n\nIl main è a tutti gli effetti una funzione e si comporta come tale, creando il proprio scope e avendo i suoi parametri in ingresso e valori di ritorno. L’unica cosa “speciale” del main è quella di essere il punto di ingresso del programma.\n\n\n\nModularizzazione\nLa modularizzazione è una tecnica che suddivide un programma in funzioni o moduli più piccoli, ciascuno con un compito specifico. Questo approccio ha diversi vantaggi:\n\nLeggibilità: il codice è più chiaro e organizzato.\nRiusabilità: le funzioni possono essere riutilizzate in diverse parti del programma.\nManutenibilità: è più facile modificare o correggere piccole porzioni di codice.\n\nAggiungo qui un estratto della mia dispensa sul refactoring (scrivere il codice in modo migliore) per mostrare quanto siano utili le funzioni. Per riassumere possiamo darci questa semplice regola d’oro: se mi metto a fare copia e incolla di una parte del codice, dovrei creare una funzione.\nEstratto da “Code smells e refactoring”\nTransclude of Code-smells-e-refactoring#codice-duplicato\n\nDiversi metodi di modularizzazione\nIn C++, esistono tre principali modalità per modularizzare il codice tramite l’uso delle funzioni:\n\nDefinire tutto in un unico file con il codice delle funzioni prima del main\nDefinire tutto in unico file con i prototipi delle funzioni prima del main e il codice dopo il main\nDefinire separatamente i prototipi in un file header h e l’implementazione in un file cpp e importarle nel main\n\n1. Tutto in un file (definizioni prima del main)\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n \nstruct Player {\n    string name;\n    int score;\n};\n \nPlayer createPlayer(string name, int score) {\n    Player p;\n    p.name = name;\n    p.score = score;\n    return p;\n}\n \nvoid printPlayer(const Player&amp; p) {\n    cout &lt;&lt; &quot;Player: &quot; &lt;&lt; p.name &lt;&lt; &quot;, Score: &quot; &lt;&lt; p.score &lt;&lt; endl;\n}\n \nvoid updateScore(Player&amp; p, int delta) {\n    p.score += delta;\n}\n \nint main() {\n    Player player = createPlayer(&quot;Alice&quot;, 10);\n    printPlayer(player);\n    updateScore(player, 5);\n    printPlayer(player);\n    return 0;\n}\nSe ho un codice molto piccolo, posso definire le funzioni con la loro implementazione direttamente sopra il main.\nIn questo caso l’ordine delle funzioni importa. Il compilatore deve incontrare una funzione prima che venga usata (ad esempio se la riutilizzo in una delle altre funzioni).\nSe chiami una funzione prima che sia definita, il compilatore darà errore.\n2. Con prototipi prima del main e definizioni dopo\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n \nstruct Player {\n    string name;\n    int score;\n};\n \n// Prototypes\nPlayer createPlayer(string name, int score);\nvoid printPlayer(const Player&amp; p);\nvoid updateScore(Player&amp; p, int delta);\n \nint main() {\n    Player player = createPlayer(&quot;Alice&quot;, 10);\n    printPlayer(player);\n    updateScore(player, 5);\n    printPlayer(player);\n    return 0;\n}\n \n// Definitions\nPlayer createPlayer(string name, int score) {\n    Player p;\n    p.name = name;\n    p.score = score;\n    return p;\n}\n \nvoid printPlayer(const Player&amp; p) {\n    cout &lt;&lt; &quot;Player: &quot; &lt;&lt; p.name &lt;&lt; &quot;, Score: &quot; &lt;&lt; p.score &lt;&lt; endl;\n}\n \nvoid updateScore(Player&amp; p, int delta) {\n    p.score += delta;\n}\nAnche questo metodo va bene per progetti piccoli o medi.\nIn questo caso l’ordine non importa più, perché dichiari anticipatamente le firme delle funzioni. Il compilatore sa che quella funzione esiste e potrà trovarla dopo.\n3. Separazione in header e file .cpp\nplayer.h:\n#ifndef PLAYER_H\n#define PLAYER_H\n \n#include &lt;string&gt;\nusing namespace std;\n \nstruct Player {\n    string name;\n    int score;\n};\n \nPlayer createPlayer(string name, int score);\nvoid printPlayer(const Player&amp; p);\nvoid updateScore(Player&amp; p, int delta);\n \n#endif\nplayer.cpp:\n#include &lt;iostream&gt;\n#include &quot;player.h&quot;\nusing namespace std;\n \nPlayer createPlayer(string name, int score) {\n    Player p;\n    p.name = name;\n    p.score = score;\n    return p;\n}\n \nvoid printPlayer(const Player&amp; p) {\n    cout &lt;&lt; &quot;Player: &quot; &lt;&lt; p.name &lt;&lt; &quot;, Score: &quot; &lt;&lt; p.score &lt;&lt; endl;\n}\n \nvoid updateScore(Player&amp; p, int delta) {\n    p.score += delta;\n}\nmain.cpp:\n#include &quot;player.h&quot;\n \nint main() {\n    Player player = createPlayer(&quot;Alice&quot;, 10);\n    printPlayer(player);\n    updateScore(player, 5);\n    printPlayer(player);\n    return 0;\n}\nDividere il codice in tre file è la prassi consigliata nei progetti di media o grande dimensione, perché migliora la leggibilità, la manutenibilità e la riusabilità. Ecco cosa succede in dettaglio:\n1. Il file .h (header)\nContiene:\n\nLe dichiarazioni delle funzioni.\nLe definizioni delle struct/class.\nInclude solo ciò che serve per rendere visibile l’interfaccia (senza logica interna).\n\nScopo:\n\nFunziona come un contratto tra chi scrive il codice e chi lo usa.\nViene incluso (tramite #include) nei file .cpp che ne hanno bisogno.\n\nIl #ifndef/#define/#endif serve a evitare inclusioni multiple, che genererebbero errori di compilazione.\n2. Il file .cpp associato all’header\nContiene:\n\nL’implementazione delle funzioni dichiarate nel file .h.\nInclude il file header corrispondente.\n\nScopo:\n\nSeparare la logica dall’interfaccia.\nEvita duplicazioni inutili di codice.\n\n3. Il file main.cpp\nContiene:\n\nLa funzione main() e la logica del programma.\nInclude solo gli header necessari (non i .cpp!).\n\nScopo:\n\nUsare le funzioni definite altrove come “mattoni” per costruire l’applicazione.\n\nCome avviene la compilazione\nI file .cpp vengono compilati separatamente e poi collegati (linkati) in un unico eseguibile.\ng++ main.cpp player.cpp -o main\nQui il compilatore:\n\nLegge main.cpp e vede le funzioni dichiarate in player.h.\nTrova la loro implementazione in player.cpp.\nCompila entrambi e li collega per formare l’eseguibile main.\n\nEsercizi\n\n\n                  \n                  Esercizi \n                  \n                \n\n\nProva a modificare gli esercizi che hai svolto nel capitolo 4 eliminando i copia incolla trasformandoli in funzioni.\n[[#Capitolo 4 Strutture Dati di Base#Esercizi]]\n\n\n\nCapitolo 6: Input/Output da file\nIntroduzione\nLa gestione dei file in C++ è possibile grazie alla libreria &lt;fstream&gt;, che fornisce classi specifiche per interagire con file di testo o binari:\n\nifstream: per leggere dati da un file.\nofstream: per scrivere dati su un file.\nfstream: per operazioni sia di lettura che di scrittura.\n\n\nScrittura su un File\nPer scrivere su un file utilizziamo la classe ofstream.\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\n \nint main() {\n    ofstream file_output(&quot;esempio.txt&quot;); // Apre il file in modalità scrittura\n \n    if (file_output.is_open()) {\n        file_output &lt;&lt; &quot;Ciao, questo è un esempio di scrittura su file.\\n&quot;;\n        file_output &lt;&lt; &quot;Questa è la seconda riga.&quot; &lt;&lt; endl;\n        file_output.close(); // Chiude il file\n        cout &lt;&lt; &quot;Scrittura completata!&quot; &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; &quot;Errore nell&#039;apertura del file.&quot; &lt;&lt; endl;\n    }\n \n    return 0;\n}\n\nLettura da un File\nPer leggere dati da un file utilizziamo la classe ifstream.\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\n \nint main() {\n    ifstream file_input(&quot;esempio.txt&quot;); // Apre il file in modalità lettura\n    string riga;\n \n    if (file_input.is_open()) {\n        while (getline(file_input, riga)) { // Legge il file riga per riga\n            cout &lt;&lt; riga &lt;&lt; endl;\n        }\n        file_input.close(); // Chiude il file\n    } else {\n        cout &lt;&lt; &quot;Errore nell&#039;apertura del file.&quot; &lt;&lt; endl;\n    }\n \n    return 0;\n}\n\nOperazioni di Lettura e Scrittura con fstream\nLa classe fstream permette sia la lettura che la scrittura su un file.\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\n \nint main() {\n    fstream file(&quot;esempio.txt&quot;, ios::in | ios::out | ios::app); // Lettura, scrittura, append\n \n    if (file.is_open()) {\n        file &lt;&lt; &quot;Nuova riga aggiunta con fstream.\\n&quot;;\n        file.seekg(0); // Riporta il cursore all&#039;inizio del file\n        string riga;\n \n        cout &lt;&lt; &quot;Contenuto del file:&quot; &lt;&lt; endl;\n        while (getline(file, riga)) {\n            cout &lt;&lt; riga &lt;&lt; endl;\n        }\n \n        file.close();\n    } else {\n        cout &lt;&lt; &quot;Errore nell&#039;apertura del file.&quot; &lt;&lt; endl;\n    }\n \n    return 0;\n}\nTipologie di lettura\nNell’esempio di lettura da file abbiamo letto il file riga per riga, ma posso anche essere più granulare, leggendo parola per parola o carattere per carattere.\nLettura parola per parola con &gt;&gt;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt;\nusing namespace std;\n \nint main() {\n    ifstream inputFile(&quot;esempio.txt&quot;);\n    string parola;\n \n    if (inputFile.is_open()) {\n        while (inputFile &gt;&gt; parola) {\n            cout &lt;&lt; parola &lt;&lt; endl; // Stampa ogni parola\n        }\n        inputFile.close();\n    } else {\n        cout &lt;&lt; &quot;Errore nell&#039;apertura del file.&quot; &lt;&lt; endl;\n    }\n \n    return 0;\n}\n \nQuesto metodo mi permette anche di estrarre dei dati dal file e salvarlo in variabili (con svariati casi d’uso, tra cui il salvataggio dei dati permanente anche dopo la chiusura del processo)\nLettura di dati strutturati da un file\nSupponiamo di avere un file studenti.txt con il seguente contenuto:\nMario Rossi 18\nLuisa Verdi 20\nGiovanni Bianchi 22\n\nOgni riga rappresenta uno studente, con nome, cognome e età. Vogliamo leggere questi dati e stamparli a video.\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt;\nusing namespace std;\n \nint main() {\n    ifstream inputFile(&quot;studenti.txt&quot;);\n    string nome, cognome;\n    int eta;\n \n    if (inputFile.is_open()) {\n        while (inputFile &gt;&gt; nome &gt;&gt; cognome &gt;&gt; eta) {\n            // Stampa i dati letti\n            cout &lt;&lt; &quot;Nome: &quot; &lt;&lt; nome &lt;&lt; &quot;, Cognome: &quot; &lt;&lt; cognome &lt;&lt; &quot;, Età: &quot; &lt;&lt; eta &lt;&lt; endl;\n        }\n        inputFile.close();\n    } else {\n        cout &lt;&lt; &quot;Errore nell&#039;apertura del file.&quot; &lt;&lt; endl;\n    }\n \n    return 0;\n}\nOutput:\nNome: Mario, Cognome: Rossi, Età: 18\nNome: Luisa, Cognome: Verdi, Età: 20\nNome: Giovanni, Cognome: Bianchi, Età: 22\n\n\n\nStruttura del file:\n\nIl file studenti.txt contiene dati organizzati in modo che ogni riga abbia tre valori separati da spazi: nome, cognome, e età.\n\n\n\nLettura con &gt;&gt;:\n\nL’operatore &gt;&gt; legge i dati dal file e li salva nelle variabili corrispondenti.\nDopo aver letto una riga completa (nome, cognome, età), il ciclo while passa alla riga successiva.\n\n\n\nCasi d’uso:\n\nQuesto metodo è utile per caricare dati strutturati (es. database semplici, configurazioni).\nI dati rimangono disponibili anche dopo la chiusura del programma, poiché salvati nel file.\n\n\n\nLettura carattere per carattere con get\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\n \nint main() {\n    ifstream inputFile(&quot;esempio.txt&quot;);\n    char carattere;\n \n    if (inputFile.is_open()) {\n        while (inputFile.get(carattere)) {\n            cout &lt;&lt; carattere &lt;&lt; endl; // Stampa ogni carattere\n        }\n        inputFile.close();\n    } else {\n        cout &lt;&lt; &quot;Errore nell&#039;apertura del file.&quot; &lt;&lt; endl;\n    }\n \n    return 0;\n}\n \n\nFunzionalità di fstream\nAbbiamo visto solo le funzionalità principali di fstream, ma qui ne hai un elenco completo per sperimentare con le varie funzioni.\nApertura e Chiusura dei File\n\n\nopen()\n\n\nApre un file con un percorso specifico e una modalità (opzionale).\n\n\nSintassi: fileStream.open(&quot;path&quot;, modalità);\n\n\nEsempio:\nifstream inputFile;\ninputFile.open(&quot;dati.txt&quot;);\n\n\n\n\nclose()\n\n\nChiude il file aperto.\n\n\nSintassi: fileStream.close();\n\n\nEsempio:\ninputFile.close();\n\n\n\n\nis_open()\n\n\nRestituisce true se il file è aperto correttamente, false altrimenti.\n\n\nSintassi: fileStream.is_open();\n\n\nEsempio:\nif (!inputFile.is_open()) {\n    cout &lt;&lt; &quot;Errore nell&#039;apertura del file.&quot; &lt;&lt; endl;\n}\n\n\n\n\nModalità di Apertura (Flags)\nLe modalità di apertura possono essere combinate con l’operatore | per definire il comportamento del file:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModalitàDescrizioneios::inApertura in modalità lettura (default per ifstream).ios::outApertura in modalità scrittura (default per ofstream).ios::appApre il file in modalità append (scrive alla fine senza sovrascrivere).ios::truncCancella il contenuto del file se esiste (default per ofstream).ios::binaryApre il file in modalità binaria.ios::ateApre il file e posiziona il puntatore alla fine, ma consente di leggere o scrivere.\nEsempio di combinazione:\nofstream outputFile(&quot;dati.txt&quot;, ios::out | ios::app); // Scrive in append\n\nOperazioni di Lettura\n\n\noperatore &gt;&gt;\n\n\nLegge una parola dal file e la salva in una variabile.\n\n\nEsempio:\nstring parola;\ninputFile &gt;&gt; parola;\n\n\n\n\ngetline()\n\n\nLegge una riga intera dal file.\n\n\nSintassi: getline(fileStream, stringa);\n\n\nEsempio:\nstring linea;\ngetline(inputFile, linea);\n\n\n\n\nget()\n\n\nLegge un carattere dal file.\n\n\nSintassi: fileStream.get(carattere);\n\n\nEsempio:\nchar c;\ninputFile.get(c);\n\n\n\n\neof()\n\n\nRestituisce true se è stata raggiunta la fine del file.\n\n\nSintassi: fileStream.eof();\n\n\nEsempio:\n// leggi parole finché non finisci il file\nwhile (!inputFile.eof()) {\n    inputFile &gt;&gt; parola;\n}\n\n\n\n\n\nOperazioni di Scrittura\n\noperatore &lt;&lt;\n\n\nScrive dati nel file.\n\n\nEsempio:\noutputFile &lt;&lt; &quot;Testo di esempio.&quot; &lt;&lt; endl;\n\n\n\n\n\nGestione dello Stato dello Stream\n\n\nfail()\n\n\nRestituisce true se si è verificato un errore nel file.\n\n\nSintassi: fileStream.fail();\n\n\nEsempio:\nif (inputFile.fail()) {\n    cout &lt;&lt; &quot;Errore nella lettura del file.&quot; &lt;&lt; endl;\n}\n\n\n\n\nclear()\n\n\nResetta lo stato dello stream (utile dopo un errore).\n\n\nSintassi: fileStream.clear();\n\n\nEsempio:\ninputFile.clear();\n\n\n\n\n\nGestione dei Puntatori nel File\n\n\ntellg()\n\n\nRestituisce la posizione corrente del puntatore di lettura (in byte).\n\n\nSintassi: fileStream.tellg();\n\n\nEsempio:\ncout &lt;&lt; &quot;Posizione corrente: &quot; &lt;&lt; inputFile.tellg() &lt;&lt; endl;\n\n\n\n\ntellp()\n\n\nRestituisce la posizione corrente del puntatore di scrittura (in byte).\n\n\nSintassi: fileStream.tellp();\n\n\nEsempio:\ncout &lt;&lt; &quot;Posizione corrente: &quot; &lt;&lt; outputFile.tellp() &lt;&lt; endl;\n\n\n\n\nseekg()\n\n\nSposta il puntatore di lettura a una posizione specifica.\n\n\nSintassi: fileStream.seekg(posizione);\n\n\nEsempio:\ninputFile.seekg(0, ios::beg); // Torna all&#039;inizio del file\n\n\n\n\nseekp()\n\n\nSposta il puntatore di scrittura a una posizione specifica.\n\n\nSintassi: fileStream.seekp(posizione);\n\n\nEsempio:\noutputFile.seekp(0, ios::end); // Posiziona alla fine del file\n\n\n\n\n\nTabella Riassuntiva\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMetodo/FunzioneDescrizioneopen()Apre un file con un percorso specifico.close()Chiude il file.is_open()Verifica se il file è aperto.operator&gt;&gt;Legge dati dal file.getline()Legge una riga intera dal file.get()Legge un carattere dal file.operator&lt;&lt;Scrive dati nel file.eof()Controlla se è stato raggiunto il fine file.fail()Verifica se un’operazione sul file è fallita.clear()Resetta lo stato dello stream.tellg()Restituisce la posizione corrente di lettura.tellp()Restituisce la posizione corrente di scrittura.seekg()Sposta il puntatore di lettura.seekp()Sposta il puntatore di scrittura.\nEsercizi\n\n\n                  \n                  Esercizi \n                  \n                \n\n\n\nCalcolo della media da un file\n\nScrivi un programma che legge un file chiamato numeri.txt contenente una lista di numeri interi e calcola la loro media.\nRequisiti:\n\nLeggere i numeri da un file.\nCalcolare e stampare la media.\n\nEsempio di file numeri.txt:\n\n\n\n\n10 20 30 40 50\n\n**Output atteso**:\n\n\nLa media è: 30\n\n---\n\n2. **Conteggio delle parole**\n\nScrivi un programma che legge un file chiamato `testo.txt` e conta il numero totale di parole nel file.\n\n**Requisiti**:\n\n- Utilizza l&#039;operatore `&gt;&gt;` per leggere parola per parola.\n- Stampa il numero totale di parole.\n\n**Esempio di file `testo.txt`**:\n\n\nBenvenuto al corso di programmazione in C++.\n\n**Output atteso**:\n\n\nNumero totale di parole: 6\n\n---\n\n3. **Analisi di frequenza delle parole**\n\nScrivi un programma che legge un file chiamato `testo.txt` e stampa il numero di volte che ogni parola appare.\n\n**Requisiti**:\n\n- Utilizza un array di struct per memorizzare ogni parola e il suo conteggio.\n- Gestisce il caso in cui la stessa parola appaia più volte.\n\n**Esempio di file `testo.txt`**:\n\n\nC++ è potente. C++ è divertente.\n\n**Output atteso**:\n\n\nC++: 2\nè: 2\npotente: 1\ndivertente: 1\n\n---\n\n4. **Gestione di un elenco di studenti**\n\nScrivi un programma che legge un file `studenti.txt` contenente i dati di più studenti (nome, cognome, età) e permette di:\n\n1. Visualizzare tutti gli studenti.\n2. Aggiungere un nuovo studente.\n3. Salvare i dati aggiornati nel file.\n\n**Requisiti**:\n\n- Utilizza una `struct` per rappresentare ogni studente.\n- Carica i dati dal file all&#039;avvio e li salva al termine.\n\n**Esempio di file `studenti.txt`**:\n\n\nMario Rossi 18\nLuisa Verdi 20\nGiovanni Bianchi 22\n\n**Esempio di interazione**:\n\n\n\nVisualizza studenti\nAggiungi studente\nEsci\nScegli un’opzione: 1\n\nMario Rossi, Età: 18\nLuisa Verdi, Età: 20\nGiovanni Bianchi, Età: 22\nScegli un’opzione: 2\nInserisci nome: Anna\nInserisci cognome: Neri\nInserisci età: 19\n\n---\n\n5. **Ricerca di un prodotto in un inventario**\n\nScrivi un programma che legge un file `inventario.txt` contenente informazioni sui prodotti di un negozio (nome, quantità, prezzo unitario) e permette di:\n\n1. Cercare un prodotto per nome e visualizzarne i dettagli.\n2. Calcolare il valore totale dell&#039;inventario.\n\n**Requisiti**:\n\n- Utilizza una `struct` per rappresentare i prodotti.\n- Gestisce sia la ricerca che il calcolo del valore totale.\n\n**Esempio di file `inventario.txt`**:\n\n\nLaptop 5 899.99\nSmartphone 10 499.99\nTablet 7 299.99\n\n**Esempio di interazione**:\n\n\n\nCerca prodotto\nCalcola valore totale\nEsci\nScegli un’opzione: 1\n\nInserisci il nome del prodotto: Smartphone\nDettagli: Smartphone, Quantità: 10, Prezzo unitario: 499.99\nScegli un’opzione: 2\nValore totale dell’inventario: 14999.60\n\n---\n\n\n6. **Trasforma in maiuscolo**\n\nScrivi un programma che legge un file `originale.txt` e crea un nuovo file `modificato.txt` con tutte le lettere convertite in maiuscolo.\n\n**Requisiti**:\n\n- Utilizza la funzione `toupper()` per convertire i caratteri.\n- Copia il contenuto riga per riga.\n\n**Esempio di file `originale.txt`**:\n\n\nC++ è fantastico.\nAdoro programmare in C++.\n\n**File `modificato.txt`**:\n\n\nC++ È FANTASTICO.\nADORO PROGRAMMARE IN C++.\n\n---\n\n7. **Crittografia di un file**\n\nScrivi un programma che legge un file `testo.txt`, applica una semplice crittografia sostituendo ogni carattere con il successivo nella tabella ASCII, e salva il risultato in un file `crittografato.txt`.\n\n**Requisiti**:\n\n- Gestisce la lettura e scrittura carattere per carattere.\n- Permette di crittografare e decrittografare il file.\n\n**Esempio di file `testo.txt`**:\n\n\nCiao, mondo!\n\n**File `crittografato.txt`**:\n\n\nDjbp-!nppep”\n\n\nCapitolo 7: Gestione della Memoria dinamica e puntatori\nIntroduzione\nA differenza di altri linguaggi ad alto livello, C++ permette il controllo esplicito della memoria, in quanto il programmatore può allocare e deallocare manualmente la memoria utilizzando strumenti dedicati come new e delete.\nLayout della memoria nei programmi C++\n\nLa memoria di un programma C++ o C è organizzata in diversi segmenti, come raffigurato nell’immagine:\n\n\nSegmento di testo:\n\nContiene le istruzioni eseguibili.\nÈ spesso in sola lettura e condivisibile tra processi.\n\nint main() {\n    return 0; // Questa istruzione risiede nel segmento di testo.\n}\n\n\nSegmento dati inizializzati:\n\nContiene variabili globali e statiche inizializzate.\nDiviso in aree di sola lettura e lettura-scrittura.\n\nint global_var = 10; // Memorizzata nel segmento dati inizializzati (area lettura-scrittura).\nconst char message[] = &quot;Hello&quot;; // Memorizzata nell&#039;area di sola lettura.\n\n\nSegmento dati non inizializzati (BSS):\n\nContiene variabili globali e statiche non inizializzate o inizializzate a zero.\n\nstatic int uninit_static; // Memorizzata nel segmento BSS e inizializzata automaticamente a 0.\nint uninit_global;        // Memorizzata nel segmento BSS.\n\n\nHeap:\n\nUtilizzato per allocazione dinamica della memoria.\nCresce verso indirizzi di memoria superiori.\n\nint main() {\n    int* ptr = new int[10]; // Allocazione dinamica nello heap.\n    delete[] ptr; // Libera la memoria allocata.\n    return 0;\n}\n\n\nStack:\n\nUtilizzato per variabili locali e dati relativi alle chiamate di funzione.\nCresce verso indirizzi di memoria inferiori.\n\nint main() {\n    int local_var = 5; // Memorizzata nello stack.\n    return 0;\n}\n\n\n\nStack vs Heap\nAndiamo a vedere meglio nel dettaglio come si comportano stack e heap.\nLo Stack\nLo stack è una parte della memoria progettata per gestire le chiamate di funzione e le variabili locali. Ogni volta che una funzione viene chiamata, il programma crea un “frame” nello stack che contiene tutte le informazioni necessarie per quella funzione: i parametri passati, le variabili locali e l’indirizzo di ritorno. Questo processo è automatico e trasparente per il programmatore.\nImmagina lo stack come una pila di fogli: ogni nuovo foglio rappresenta una funzione chiamata, e quando la funzione termina, il foglio in cima viene rimosso. Questa organizzazione è chiamata Last In, First Out (LIFO).\nLo stack è estremamente veloce, ma ha un limite fisso di dimensioni. Un eccesso di utilizzo dello stack, come in ricorsioni profonde o allocazioni locali di grandi dimensioni, può causare uno stack overflow, con conseguente crash del programma.\nvoid esempio() {\n    int variabile_local = 42; // Allocata nello stack.\n}\nHeap\nL’ heap, al contrario, è una regione della memoria dedicata all’allocazione dinamica. In C++, l’allocazione nello heap viene gestita attraverso gli operatori new e delete, che sostituiscono le funzioni malloc e free di C.\nImmagina lo heap come un vasto magazzino: puoi prendere spazio per conservare dati, ma devi ricordarti di restituirlo. Questo sistema offre una grande flessibilità, ma può portare a memory leak se dimentichi di liberare la memoria allocata.\nint main() {\n    int* heap_variable = new int; // Allocata nello heap.\n    *heap_variable = 42;\n    delete heap_variable; // Liberazione della memoria.\n    return 0;\n}\nIn questo caso, la variabile heap_variable è allocata nello heap e rimane disponibile fino a quando non viene esplicitamente liberata con delete.\nPuntatori\nNegli esempi abbiamo visto dei tipi di dato con l’asterisco. Questi si chiamano puntatori. Un puntatore è una variabile che memorizza l’indirizzo di memoria di un’altra variabile. I puntatori mi servono per creare strutture dati più complesse e dinamiche memorizzandole nell’heap.\nDichiarazione e Uso dei Puntatori\ntipo_dato *nome_puntatore;\n\nL’operatore * indica che la variabile è un puntatore.\nL’operatore &amp; restituisce l’indirizzo di memoria di una variabile.\n\nEsempio:\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int variabile = 10;       // Variabile normale\n    int *puntatore = &amp;variabile; // Puntatore alla variabile\n \n    cout &lt;&lt; &quot;Valore della variabile: &quot; &lt;&lt; variabile &lt;&lt; endl;\n    cout &lt;&lt; &quot;Indirizzo della variabile: &quot; &lt;&lt; puntatore &lt;&lt; endl;\n    cout &lt;&lt; &quot;Valore puntato dal puntatore: &quot; &lt;&lt; *puntatore &lt;&lt; endl;\n \n    return 0;\n}\nOutput:\nValore della variabile: 10  \nIndirizzo della variabile: 0x7ffeea8b1c4c  \nValore puntato dal puntatore: 10\n\n\n\n                  \n                  Nota \n                  \n                \n\n\nCome vedi nell’esempio, il puntatore senza asterisco mi restituisce l’indirizzo di memoria a cui sta puntando, mentre con l’asterisco mi restituisce il valore contenuto.\n\n\n\n\nNavigazione manuale nella memoria\nCon i puntatori posso navigare manualmente all’interno della memoria:\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int array[3] = {10, 20, 30};\n    int *p = array; // Puntatore al primo elemento\n \n    cout &lt;&lt; &quot;Indirizzo del primo elemento: &quot; &lt;&lt; p &lt;&lt; &quot;, Valore: &quot; &lt;&lt; *p &lt;&lt; endl; // 10\n    p++;\n    cout &lt;&lt; &quot;Indirizzo dopo incremento: &quot; &lt;&lt; p &lt;&lt; &quot;, Valore: &quot; &lt;&lt; *p &lt;&lt; endl; // 20\n \n    p++;\n    cout &lt;&lt; &quot;Indirizzo dopo ulteriore incremento: &quot; &lt;&lt; p &lt;&lt; &quot;, Valore: &quot; &lt;&lt; *p &lt;&lt; endl; // 30\n \n    return 0;\n}\n \nL’output sarà una cosa simile a questa:\nIndirizzo del primo elemento: 0x7ffee0f6c800, Valore: 10\nIndirizzo dopo incremento: 0x7ffee0f6c804, Valore: 20\nIndirizzo dopo ulteriore incremento: 0x7ffee0f6c808, Valore: 30\n\n\n\n                  \n                  Nota \n                  \n                \n\n\nCome notiamo chiaramente dall’output, l’incremento del valore di memoria corrisponde alla dimensione del tipo di dato. Quindi incrementando un puntatore a un intero, incremento il valore in memoria di 4 byte passando all’intero successivo.\n\n\n\n\nPassaggio di Puntatori alle Funzioni\nI puntatori permettono di modificare direttamente le variabili originali all’interno di una funzione.  Questo equivale a passare la variabile per riferimento con &amp;.\nEsempio:\n#include &lt;iostream&gt;\nusing namespace std;\n \nvoid incrementa(int *p) {\n    (*p)++;\n}\n \nint main() {\n    int numero = 5;\n    cout &lt;&lt; &quot;Prima della funzione: &quot; &lt;&lt; numero &lt;&lt; endl;\n \n    incrementa(&amp;numero); // Passaggio dell&#039;indirizzo\n \n    cout &lt;&lt; &quot;Dopo la funzione: &quot; &lt;&lt; numero &lt;&lt; endl;\n    return 0;\n}\nOutput:\nPrima della funzione: 5  \nDopo la funzione: 6\n\n\nAllocazione Dinamica della Memoria\nL’allocazione dinamica permette di riservare memoria nello heap durante l’esecuzione del programma utilizzando gli operatori new e delete.\nOperatore new\nAlloca dinamicamente memoria e restituisce un puntatore all’area allocata.\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int *p = new int; // Allocazione dinamica di un intero\n    *p = 42;\n \n    cout &lt;&lt; &quot;Valore allocato: &quot; &lt;&lt; *p &lt;&lt; endl;\n \n    delete p; // Deallocazione della memoria\n    return 0;\n}\nAllocazione di un Array Dinamico\n#include &lt;iostream&gt;\nusing namespace std;\n \nint main() {\n    int n;\n    cout &lt;&lt; &quot;Inserisci la dimensione dell&#039;array: &quot;;\n    cin &gt;&gt; n;\n \n    int *array = new int[n]; // Allocazione dinamica di un array\n \n    for (int i = 0; i &lt; n; i++) {\n        array[i] = i * 2; // Inizializzazione\n    }\n \n    cout &lt;&lt; &quot;Valori nell&#039;array: &quot;;\n    for (int i = 0; i &lt; n; i++) {\n        cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n \n    delete[] array; // Deallocazione della memoria\n    return 0;\n}\n\n\n                  \n                  Nota \n                  \n                \n\n\nLinguaggi di programmazione come Java, hanno un sistema chiamato Garbage Collector che libera automaticamente la memoria dinamica quando non serve, per cui gli oggetti creati dinamicamente liberano in modo automatico la memoria. C++ non ha questo sistema, quindi devo sempre ricordarmi di liberare la memoria con delete a meno che non utilizzo classi predefinite che sono già implementate per liberare la memoria.\n\n\n\nCapitolo 8: Strutture dati dinamiche di base\nOra che sappiamo come funziona la gestione della memoria, possiamo provare a costruire due nuove strutture dati che servono come base a strutture più complesse, i vector e le liste. Dopo aver creato la nostra versione personale, vediamo come utilizzare direttamente le librerie di C++ che le implementano.\nVector\nOra che sappiamo come funziona la gestione della memoria e gli array dinamici, possiamo capire come funziona la classe vector in C++, e utilizzarla senza dover implementarne il codice.\nIntroduzione\nIn C++, il vector è una struttura dati della Standard Template Library (STL) che rappresenta un array dinamico. È progettato per offrire una gestione flessibile della memoria e funzionalità avanzate come la possibilità di ridimensionamento automatico, iterazione e accesso sicuro.\nUn vector utilizza un’area di memoria allocata dinamicamente (sullo heap) per memorizzare i suoi elementi. Quando la dimensione (size) del vector supera la sua capacità (capacity), il vector rialloca un blocco di memoria più grande, copia gli elementi esistenti e dealloca la memoria precedente.\n\nCapacità e Dimensione:\n\nLa dimensione (size) è il numero di elementi attualmente memorizzati nel vector.\nLa capacità (capacity) è lo spazio totale riservato in memoria. La riallocazione avviene quando la dimensione supera la capacità.\n\n\nRiallocazione:\n\nDurante la riallocazione, il vector alloca un nuovo blocco di memoria con una capacità maggiore (solitamente raddoppiata) e copia i dati esistenti nel nuovo blocco.\n\n\n\n\nMetodi Principali di std::vector\n\nInserimento di elementi:\n\npush_back(value): Aggiunge un elemento alla fine del vector.\nemplace_back(args...): Costruisce un elemento direttamente nella posizione finale.\n\n\nRimozione di elementi:\n\npop_back(): Rimuove l’ultimo elemento.\nerase(iterator): Rimuove un elemento specificato o un intervallo di elementi.\nclear(): Rimuove tutti gli elementi.\n\n\nAccesso agli elementi:\n\noperator[]: Accesso diretto tramite indice.\nat(index): Accesso con controllo dei limiti (lancia un’eccezione se l’indice è fuori dal range).\n\n\nDimensione e Capacità:\n\nsize(): Restituisce il numero di elementi attualmente contenuti.\ncapacity(): Restituisce la capacità allocata.\nresize(new_size): Modifica la dimensione del vector.\nreserve(new_capacity): Riserva memoria per almeno new_capacity elementi.\n\n\nIterazione:\n\nIteratori (begin(), end(), rbegin(), rend()): Permettono di scorrere gli elementi del vector.\n\n\n\n\nEsempio di Utilizzo di std::vector\nEcco un esempio che illustra le funzionalità principali di un std::vector:\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n \nint main() {\n    vector&lt;int&gt; vec; // Dichiarazione di un vector di interi\n \n    // Aggiunta di elementi\n    vec.push_back(10);\n    vec.push_back(20);\n    vec.push_back(30);\n \n    // Visualizza gli elementi\n    cout &lt;&lt; &quot;Elementi nel vector:&quot; &lt;&lt; endl;\n    for (int i = 0; i &lt; vec.size(); ++i) {\n        cout &lt;&lt; &quot;Index &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; vec[i] &lt;&lt; endl;\n    }\n \n    // Modifica di un elemento\n    vec[1] = 50;\n    cout &lt;&lt; &quot;Dopo modifica: &quot; &lt;&lt; vec[1] &lt;&lt; endl;\n \n    // Rimozione dell&#039;ultimo elemento\n    vec.pop_back();\n    cout &lt;&lt; &quot;Dopo pop_back, dimensione: &quot; &lt;&lt; vec.size() &lt;&lt; endl;\n \n    // Informazioni sulla capacità\n    cout &lt;&lt; &quot;Capacità attuale: &quot; &lt;&lt; vec.capacity() &lt;&lt; endl;\n \n    return 0;\n}\n\nEsempio di Riallocazione\nQuesto esempio mostra come la capacità del vector cambia quando vengono aggiunti nuovi elementi:\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n \nint main() {\n    vector&lt;int&gt; vec;\n \n    cout &lt;&lt; &quot;Capacità iniziale: &quot; &lt;&lt; vec.capacity() &lt;&lt; endl;\n \n    for (int i = 0; i &lt; 10; ++i) {\n        vec.push_back(i);\n        cout &lt;&lt; &quot;Aggiunto &quot; &lt;&lt; i &lt;&lt; &quot;, Capacità: &quot; &lt;&lt; vec.capacity() &lt;&lt; &quot;, Dimensione: &quot; &lt;&lt; vec.size() &lt;&lt; endl;\n    }\n \n    return 0;\n}\n\nConclusione\nIl std::vector è uno strumento potente per la gestione dinamica della memoria in C++. La sua facilità d’uso e le funzionalità avanzate lo rendono una delle scelte principali per lavorare con array dinamici in C++ moderno.\nEsercizi\n\n\n                  \n                  Esercizi \n                  \n                \n\n\n\nImplementazione di un vector:\nOra che sappiamo come funziona la classe vector e che funzionalità deve avere, proviamo a implementarne uno nostro. Il vector così creato deve avere almeno le funzionalità di base per funzionare. Più funzionalità riesco ad aggiungere e meglio è.\nRubrica telefonica:\nImplementare le funzioni che compongono una libreria per la memorizzazione e gestione di una rubrica telefonica utilizzando struct e std::vector. Oltre alla definizione delle funzioni e dei tipi richiesti per la libreria, dovete, naturalmente, scrivere un programma per testare le funzioni man mano che le implementate.\n\nSUGGERIMENTO: Per scrivere i programmi intermedi per testare le funzioni prodotte fino ad un certo punto, potete modificare sempre lo stesso main, commentando i pezzi che non vi servono più perché avete testato in maniera soddisfacente la funzione a cui fanno riferimento; però non cancellate, perché se poi dovete fare modifiche alle funzioni precedenti o vi accorgete di un caso che non avete provato, così vi trovate ancora il codice di test pronto, basta togliere i commenti.\nPer quanto riguarda l’input dei dati su cui provare le chiamate di funzione, potete fare lettura da input (più facile, ma ci mettete più tempo a far girare il programma) oppure da file (richiede più sforzo la prima volta, ma vi permette di ripetere i test molto rapidamente e senza ulteriore fatica).]\n\n\nDefinire una struct Contact_Str contenente almeno i campi Name, Surname, PhoneNumber (di un tipo opportuno).\n\n\nCreare un tipo vettore di contatti dandogli il nome PhoneBook, usando:\ntypedef std::vector&lt;Contact_Str&gt; PhoneBook;\n\n\nScrivere la funzione:\nvoid add(PhoneBook&amp; B, string surname, string name, int phoneNumber);\nper aggiungere un contatto C in coda alla rubrica B.\n\n\nScrivere la funzione:\nvoid print(const PhoneBook&amp; B);\nper stampare il contenuto della rubrica B.\n\n\nScrivere una funzione:\nvoid sortSurnames(PhoneBook&amp; B);\nche, data una rubrica, ordini alfabeticamente gli elementi in essa contenuti rispetto al campo Surname.\n\n\nScrivere una funzione:\nint FindPos(const PhoneBook&amp; r, string S);\nche, utilizzando la ricerca binaria, abbia il seguente comportamento:\n\nSe nella rubrica esiste un contatto C il cui campo C.Surname è uguale all’argomento S, allora restituisca l’indice di tale contatto nella rubrica (ossia nel vettore).\nSe nella rubrica non esiste un contatto C il cui campo C.Surname è uguale all’argomento S, allora restituisca l’indice del contatto che sarebbe quello immediatamente precedente in ordine alfabetico.\nSUGGERIMENTO: Ricordate che la ricerca binaria assume che il vettore sia ordinato.\n\n\n\nScrivere una funzione:\nvoid Shift_PhoneBook(PhoneBook&amp; B, int pos);\nche incrementa di un elemento la dimensione del vettore B e poi sposta a destra di un elemento tutti gli elementi a partire dalla posizione pos + 1.\n\n\nScrivere la funzione:\nbool add_ord(PhoneBook&amp; B, string surname, string name, int phoneNumber);\nche inserisce il nuovo contatto nella rubrica nella posizione giusta rispetto all’ordine alfabetico.\nSUGGERIMENTO: Assumendo che la rubrica sia ordinata, usare la funzione FindPos per ottenere la posizione immediatamente precedente a quella in cui il contatto andrebbe inserito, seguita dalle funzioni Shift_PhoneBook e una assegnazione.\n\n\nRendere il programma interattivo:\nOra potete rendere il programma interattivo, ad esempio utilizzando uno switch per accedere alle varie funzioni e gestire la rubrica.\n\n\n\n\n\n\nListe\nOra che abbiamo approfondito i vector, possiamo passare a un’altra struttura dati dinamica fondamentale: le liste. Le liste forniscono una flessibilità maggiore rispetto ai vector in alcuni scenari, come l’inserimento e la rimozione di elementi in posizioni arbitrarie, grazie al loro design basato sui nodi concatenati.\nIn C++, possiamo implementare le liste manualmente o utilizzare la classe list della Standard Template Library (STL), che rappresenta una lista doppiamente concatenata.\n\nIntroduzione alle Liste\nUna lista è composta da nodi collegati tra loro e un puntatore al primo nodo chiamato testa. Ogni nodo contiene:\n\nUn valore (o dato).\nUn puntatore al nodo successivo (e, nel caso delle liste doppiamente concatenate, anche al nodo precedente).\n\nIn C++ il singolo nodo viene rappresentato da questa struct:\n\nstruct cell {\n    int valore;\n    cell* next;\n};\nGrazie a questa struttura, le liste mi permettono di allocare un singolo nodo e aggiungerlo, senza dover riall:\n\nInserire o rimuovere elementi frequentemente.\nEvitare la riallocazione e il ridimensionamento automatico come nei vector, essendo un’operazione particolarmente pesante.\n\n\nMetodi Principali di std::list\n\n\nInserimento di elementi:\n\npush_back(value): Aggiunge un elemento alla fine della lista.\npush_front(value): Aggiunge un elemento all’inizio della lista.\ninsert(iterator, value): Inserisce un elemento in una posizione specifica.\n\n\n\nRimozione di elementi:\n\npop_back(): Rimuove l’ultimo elemento.\npop_front(): Rimuove il primo elemento.\nerase(iterator): Rimuove un elemento in una posizione specifica.\nremove(value): Rimuove tutte le occorrenze di un valore.\n\n\n\nAccesso e Iterazione:\n\nbegin(), end(): Restituiscono un iteratore agli estremi della lista.\nrbegin(), rend(): Iteratori inversi per scorrere la lista al contrario.\n\n\n\nManipolazione della lista:\n\nsize(): Restituisce il numero di elementi.\nempty(): Verifica se la lista è vuota.\nclear(): Rimuove tutti gli elementi.\nsort(): Ordina la lista.\nreverse(): Inverte l’ordine degli elementi.\n\n\n\n\nEsempio di Utilizzo di list\nEcco un esempio che mostra come utilizzare alcune funzionalità principali di list:\n#include &lt;iostream&gt;\n#include &lt;list&gt;\nusing namespace std;\n \nint main() {\n    list&lt;int&gt; lista; // Dichiarazione di una lista di interi\n \n    // Inserimento di elementi\n    lista.push_back(10);\n    lista.push_front(5);\n    lista.push_back(20);\n \n    // Stampa degli elementi\n    cout &lt;&lt; &quot;Elementi nella lista: &quot;;\n    for (int valore : lista) {\n        cout &lt;&lt; valore &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n \n    // Rimozione di un elemento\n    lista.remove(10);\n \n    // Stampa dopo rimozione\n    cout &lt;&lt; &quot;Dopo rimozione: &quot;;\n    for (int valore : lista) {\n        cout &lt;&lt; valore &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n \n    // Ordinamento e inversione\n    lista.push_back(15);\n    lista.sort();\n    lista.reverse();\n \n    // Stampa dopo ordinamento\n    cout &lt;&lt; &quot;Dopo ordinamento e inversione: &quot;;\n    for (int valore : lista) {\n        cout &lt;&lt; valore &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n \n    return 0;\n}\nOutput:\nElementi nella lista: 5 10 20 \nDopo rimozione: 5 20 \nDopo ordinamento e inversione: 20 15 5 \n\n\n\n                  \n                  Nota \n                  \n                \n\n\nIn questo esempio hai visto il costrutto for (int valore : lista). Questo costrutto si chiama “for each” (“per ogni”), ed è un costrutto ad alto livello di astrazione che mi permette di scorrere direttamente gli elementi all’interno di una struttura dati come una lista, senza utilizzare esplicitamente i contatori. Ad ogni iterazione, valore conterrà direttamente il valore all’indice attuale. In italiano si tradurrebbe in per ogni &quot;valore&quot; in &quot;lista&quot;\n\n\n\n\nImplementazione Manuale di una Lista  Semplice\nPer comprendere meglio il funzionamento delle liste, possiamo implementarne una manualmente. In questo caso implementiamo una lista semplice, ovvero una lista in cui collego un elemento al prossimo (e non anche al precedente come accade nelle liste implementate in list).\nIn questo esempio mancano volutamente alcune funzioni, che dovrai implementare da solo per comprendere il funzionamento delle liste.\n#include &lt;iostream&gt;\nusing namespace std;\n \n// Struttura di una cella della lista\nstruct cell {\n    int value;   // Valore memorizzato\n    cell* next;  // Puntatore alla cella successiva\n};\n \n// Funzione per creare una nuova cella\ncell* createCell(int value) {\n    cell* newCell = new cell; // Allocazione dinamica\n    newCell-&gt;value = value;\n    newCell-&gt;next = nullptr;\n    return newCell;\n}\n \n// Funzione per aggiungere una cella all&#039;inizio\nvoid addFront(cell*&amp; head, int value) {\n    cell* newCell = createCell(value); // Crea una nuova cella\n    newCell-&gt;next = head;              // Collegala alla testa attuale\n    head = newCell;                    // Aggiorna la testa\n}\n \n// TODO Funzione per aggiungere una cella alla fine\n \n// TODO Funzione per stampare la lista\n \n \n// TODO Funzione per rimuovere una cella con un valore specifico\n \n// Funzione per liberare tutta la memoria della lista\nvoid deleteList(cell*&amp; head) {\n    while (head != nullptr) {\n        cell* temp = head;\n        head = head-&gt;next;\n        delete temp;\n    }\n}\n \nint main() {\n\t// TODO\n    return 0;\n}\n \n \n\n\n                  \n                  Esercizi \n                  \n                \n\n\n\nImplementazione manuale di una lista semplice:\nUtilizzando come base il codice qui sopra, cerca di capire e spiegare come funzionano le funzioni già esistenti e crea un main per testarle. Dopodiché aggiungi le funzioni mancanti marcate con TODO.\n\n\n\n\n\nVector o lista?\nLa scelta tra vector e list dipende dalle esigenze specifiche del programma e dal comportamento desiderato in termini di accesso ai dati, inserimenti/rimozioni e performance. Ecco una guida per capire quando utilizzare uno o l’altro.\n\nQuando usare un vector\nVantaggi principali dei vector:\n\nAccesso rapido agli elementi: Grazie alla struttura contigua in memoria, è possibile accedere direttamente a qualsiasi elemento in tempo costante O(1).\nEfficienza per iterazioni e operazioni sequenziali: Poiché i dati sono memorizzati in modo contiguo, i vector beneficiano della località spaziale, migliorando le prestazioni della cache.\n\nQuando scegliere un vector:\n\n\nAccesso casuale frequente:\n\nSe hai bisogno di accedere frequentemente a elementi specifici usando un indice.\nEsempio: Un array di posizioni di un gioco in cui spesso accedi a elementi specifici.\n\n\n\nInserimenti e rimozioni principalmente alla fine:\n\nOperazioni come push_back e pop_back sono molto efficienti.\n\n\n\nDataset relativamente stabile:\n\nSe il dataset ha pochi inserimenti o rimozioni frequenti (soprattutto non nel mezzo), un vector è più efficiente.\n\n\n\nUso intensivo della memoria:\n\nI vector hanno un overhead di memoria molto basso rispetto alle liste, poiché non hanno bisogno di puntatori aggiuntivi per collegare i nodi.\n\n\n\n\nQuando usare una list\nVantaggi principali delle liste:\n\nInserimento e rimozione rapidi ovunque: Grazie alla loro struttura basata su nodi, le liste permettono di aggiungere o rimuovere elementi in qualsiasi posizione in tempo costante se hai un iteratore valido.\nRiorganizzazione semplice: Operazioni come ordinamento, unione o spostamento di elementi tra liste sono molto efficienti.\n\nQuando scegliere una lista:\n\n\nInserimenti e rimozioni frequenti in posizioni arbitrarie:\n\nSe devi aggiungere o rimuovere elementi in posizioni arbitrarie frequentemente.\n\n\n\nUso intensivo di iterazioni complesse:\n\nSe devi inserire o rimuovere elementi durante un’iterazione su una lista, le liste sono più sicure da usare rispetto ai vector (gli iteratori di una lista rimangono validi dopo inserimenti o rimozioni, salvo nei punti interessati).\n\n\n\nOrdine e spostamenti importanti:\n\nSe devi spesso riordinare o unire liste, ad esempio con list::sort() o list::merge().\n\n\n\nMemoria non contigua:\n\nSe la memoria del sistema è frammentata e non puoi permetterti di allocare grandi blocchi contigui come quelli necessari ai vector.\n\n\n\n\nTabella riassuntiva\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCaratteristicastd::vectorstd::listAccesso casualeVeloceLentoInserimento/rimozioneAlla fineOvunqueIterazione sequenzialeMolto veloceLenta (a causa della località spaziale)Uso di memoriaEfficiente (contiguo)Maggiore overhead (puntatori aggiuntivi)RiallocazioneNecessaria se supera la capacitàNon necessariaOrdinamentoInefficiente (richiede copia)Efficiente (modifica diretta)Cache localityBuonaScarsaStabilità degli iteratoriInvalidati da inserimenti/rimozioniStabili (salvo nodo interessato)\nRegola generale\n\nUsa un std::vector per la maggior parte delle applicazioni, in particolare se le operazioni principali riguardano accesso casuale o inserimenti/rimozioni alla fine.\nUsa una std::list solo se devi fare molte operazioni di inserimento/rimozione in posizioni arbitrarie o hai bisogno di manipolare gli elementi in un ordine specifico frequentemente.\n\nConclusione\nQueste erano le due strutture di base più comuni, che ti permettono di capire come funzionano strutture più complesse come gli alberi o i grafi. Queste strutture più complesse dati non sono oggetto di questo corso.\nConclusione\nQuesta dispensa ha offerto un percorso per apprendere e approfondire i concetti fondamentali della programmazione in C++. Grazie a queste basi potrai affrontare argomenti più complessi anche con altri linguaggi di programmazione, come la programmazione orientata agli oggetti, gli algoritmi e strutture dati più avanzate come alberi e grafi, programmazione multithread, librerie e framework per progetti complessi e specifici."},"Argomenti/Algoritmi/Pattern-scansioni":{"slug":"Argomenti/Algoritmi/Pattern-scansioni","filePath":"Argomenti/Algoritmi/Pattern scansioni.md","title":"Pattern scansioni","links":[],"tags":[],"content":"Un pattern (uno “schema”) può essere definito come “una soluzione progettuale generale ad un problema ricorrente” [3].\nUn pattern elementare è un pattern adatto ai novizi per aiutarli ad apprendere concetti fondamentali di programmazione [4].\nGli studenti, tramite la lettura, il tracciamento, il completamento, o la risoluzione di svariate istanze di diversi e variegati problemi accomunati da uno schema risolutivo comune, possono imparare questi pattern e applicarli poi in contesti nuovi ma risolubili con lo stesso schema di soluzione.\nNon si tratta tanto di insegnare il pattern in astratto, quanto di farlo osservare (e “nominarlo”) esplicitamente in istanze concrete di sua applicazione.\nScansioni lineari\nSi tratta di scansioni in cui processiamo tutti gli elementi di una collezione, avendo modo di sapere a priori (possibilmente in tempo costante) quanti elementi ci sono o quando siamo arrivati alla fine.\nDunque possono essere utilizzati su collezioni iterabili (es. for e in s: print(e)) o su collezioni indicizzabili (es. for i in range(len(s)): print(s[i])\nScansione lineare semplice\nSi tratta di scansioni in cui le singole iterazioni forniscono parti del risultato.\nCon iteratore\nper (ogni) e in c:\n   processa e\n\nCon indici\nper i che varia tra i valori estremi degli indici di c: # (es tra 0 e len(c))\n   processa c[i]\n   incrementa o decrementa i\n\nCon indici e while\ni = uno dei valori estremi di c\nfinché i minore di uno dei valori estremi degli indici di c: # (es tra 0 e len(c))\n   processa c[i]\n   incrementa o decrementa i\n\nEsempio. Scrivere una funzione che stampa a video, su linee separate, tutti gli elementi di una collezione\n#con iteratore\ndef stampa_it(c):\n  for e in c:\n    print(e)\n\nl = [1, 3, 5]\nstampa_it(l)\nt = (&#039;M&#039;, &#039;F&#039;, &#039;X&#039;)\nstampa_it(t)\nd = {&#039;Michael&#039;, &#039;Stefano&#039;, &#039;Simone&#039;, &#039;Elisa&#039;}\nstampa_it(d) #notare che non è ordinato ma posso enumerarlo e quindi iterarlo\n\n#con indice\ndef stampa_in(c):\n  for i in range(len(c)):\n    print(c[i])\n\nstampa_in(l)\nstampa_in(t)\n#stampa_in(d) #insiemi non sono ordinati e non indicizzabili\n\nEsempio. Scrivere una funzione che stampa a video, su linee separate, le lettere di una stringa passata come parametro in ordine inverso.\ndef inversione(s):\n  for i in range(len(s), 0, -1): # i varia tra len(s) (compreso) e 0 (escluso): [len(s), 0[\n    print(s[i-1]) #mentre gli indici del vettore variano tra ]len(s), 0], per questo devo fare i-1\n\ninversione(&#039;ciao&#039;)\n\nEsempio. Scrivere una funzione Python che stampa a video, su linee separate, le vocali di una stringa passata come parametro.\ndef stampa_vocale(s):\n  vocali = &#039;aeiouAEIOU&#039;\n  for l in s:\n    if l in vocali:\n      print(l)\n\nstampa_vocale(&#039;ciao&#039;)\n\nPython permette di iterare sugli elementi di una stringa con il costrutto for (for c in s).\nIn alternativa possiamo accedere a ciascun carattere con il suo indice\ndef stampa_vocale(s):\n  vocali = &#039;aeiouAEIOU&#039;\n  for i in range(len(s)): #range(len(s)) indica [0, len(s)[\n    if s[i] in vocali:\n      print(s[i])\n\nstampa_vocale(&#039;ciao&#039;)\n\nScansione lineare con accumulo\nSi tratta di una scansione in cui iterare serve a preparare approssimazioni successive del risultato.\naccumulatore = elemento neutro #(es. 0 se somma, 1 se prodotto, collezione vuota se collezione, stringa vuota, True o False...)\nper ogni e in c:\n   se e soddisfa un requisito: #(potrebbe anche non servire)\n      accumulatore += valore da accumulare\noutput di accumulatore\n\n(Banale costruire la versione con indici, lavorando su c[i] invece che su e)\nEsempio. Scrivere una funzione che restituisce la lunghezza di una sequenza, senza utilizzare il metodo built-in di Python len().\ndef lunghezza(seq):\n  accumulatore = 0\n  for e in seq:\n    accumulatore += 1\n  return accumulatore\n\nprint(lunghezza(&#039;ciao&#039;))\n\nEsempio. Scrivere una funzione che stampa a video il numero di vocali di una stringa passata come parametro.\ndef stampa_n_vocali(s):\n  vocali = &#039;aeiouAEIOU&#039; # si potrebbe voler considerare anche le vocali accentate\n  n_vocali = 0\n  for l in s:\n    if l in vocali:\n      n_vocali += 1\n  print(&#039;Ci sono &#039; + str(n_vocali) + &#039; vocali nella stringa &#039; + s)\n\nstampa_n_vocali(&#039;ciao&#039;)\n\nEsempio. Scrivere una funzione Python che restituisce una stringa contenente le vocali di una stringa passata come parametro.\ndef vocali(s):\n  vocali=&#039;aeiouAEIOU&#039;\n  vocali_in_s = &#039;&#039;\n  for lettera in s:\n    if lettera in vocali:\n      vocali_in_s = vocali_in_s + lettera\n  return vocali_in_s\n\nprint(vocali(&#039;ciao&#039;))\n\nRicerca Lineare\nRicerca lineare certa\nCerchiamo un elemento e (per esempio in una successione di numeri, oppure in una sequenza o collezione c) che soddisfa un certo requisito. Ci fermiamo quando lo troviamo.\nCon iteratore\nper (ogni) e in c:\n   se e soddisfa il requisito:\n      azione in caso di ritrovamento\n      esci dal ciclo\n\nCon indici\nper i tra gli indici estremi di c:\n  se c[i] soddisfa il requisito:\n     azione in caso di ritrovamento\n     esci dal ciclo\n  incrementa i\n\nCon while\ni = 0\nfinché i &lt; lunghezza(c):\n   se c[i] soddisfa il requisito:\n     azione in caso di ritrovamento\n     esci dal ciclo\n   incrementa i\n\nCon while, unendo le condizioni\ni = 0\nfinché i &lt; lunghezza(c) e c[i] non soddisfa il requisito:\n   incrementa i\nazione in caso di ritrovamento\n\nPer quest’ultimo caso, si assume che il linguaggio di programmazione usi la valutazione lazy (“a corto circuito”) delle espressioni booleane: es. se il primo degli operandi di un AND è falso, non si valuta il secondo (e si restituisce False); allo stesso modo se il primo degli operandi di un OR è vero, non si valuta il secondo (e si restituisce True).\nSenza questa assuzione, nel caso in cui i == lunghezza(c), continuando a valutare l’espressione nel “finché”, si prova ad accedere a c[i], che sarà fuori dal range della collezione (i cui indici vadano da 0 a lunghezza(c)-1)\nEsempio. Definire una funzione Python che restituisce True se un elemento (fornito come parametro) si trova in una collezione (fornita come parametro). Servirsi di un ciclo che processa gli elementi della collezione, fornendo una strategia per l’uscita dal ciclo nel caso l’elemento obiettivo della ricerca venga trovato prima del termine della scansione.\ndef ricerca_lineare(elem , seq):\n  for e in seq:\n    if e == elem:\n      return True\n\nRicerca lineare incerta\nCerchiamo un elemento e (per esempio in una successione di numeri, oppure in una sequenza o collezione c) che soddisfa un certo requisito. Dobbiamo gestire il caso particolare in cui l’elemento non sia presente.\nCon iteratore\nper (ogni) e in c:\n   se e soddisfa il requisito: \n      azione in caso di ritrovamento\n      esci dal ciclo\nazione in caso di *mancato* ritrovamento\n\nCon indici\nper i tra gli indici estremi di c:\n  se c[i] soddisfa il requisito:\n     azione in caso di ritrovamento\n     esci dal ciclo\n  incrementa i\nazione in caso di *mancato* ritrovamento\n\nCon while\ni = 0\nfinché i &lt; lunghezza(c):\n   se c[i] soddisfa il requisito:\n     azione in caso di ritrovamento\n     esci dal ciclo\n   incrementa i\nazione in caso di *mancato* ritrovamento\n\nCon while, unendo le condizioni\ni = 0\nfinché i &lt; lunghezza(c) e c[i] non soddisfa il requisito:\n   incrementa i\nse i != lunghezza(c): \n   azione in caso di ritrovamento\naltrimenti:\n   azione in caso di *mancato* ritrovamento\n\nNB: Si assume la valutazione “lazy”…\nEsempio. Modificare la soluzione precedente in modo da gestire il caso in cui l’obiettivo della ricerca non venga trovato nella collezione, trattandolo come un caso particolare.\ndef ricerca_lineare(elem, seq):\n  for e in seq:\n    if e == elem:\n      return True\n  return False\n\nAnalogamente, una possibile soluzione che utilizza il costrutto while sarà così definita:\ndef ricerca_lineare_while(elem, seq):\n  i = 0\n  while i &lt; len(seq):\n    if seq[i] == elem:\n      return True\n    i += 1\n  return False\n\nO, più compattamente:\ndef ricerca_lineare_while(elem, seq):\n  i = 0\n  while i &lt; len(seq) and seq[i] != elem:\n    i += 1\n  return i != len(seq)\n\nEsempio. Scrivere una funzione che restituisce True se il numero n passato come parametro è primo, e False altrimenti.\nSi tratta dell’algoritmo “ovvio”, e corrisponde alla ricerca di un divisore per n tra i numeri minori di n.\ndef primo(n): #supponiamo n&gt;1\n  for i in range(2,n): #in realtà basta arrivare a sqrt(n)\n    if n % i == 0: # n è divisibile per i\n      return False #trovato un divisore diverso da 1 e se stesso\n  return True #non ho trovato divisori\n\nScansioni e ricerche “interattive”\nIn questi casi la lunghezza della collezione non è conosciuta a priori, e l’utente fornisce gli elementi uno alla volta\nScansione lineare (semplice o con accumulo) fino all’arrivo di una sentinella\nVogliamo leggere e processare tutti i valori inseriti uno alla volta dall’utente, finché non viene inserito uno specifico valore, che chiamiamo sentinella.\nleggi valore\nfinché valore != sentinella:\n  processa valore\n  leggi valore\n\nEsempio. Scrivere un programma che richiede in input i voti (da 1 a 10) di uno studente, li stampa (scansione semplice), li somma (scansione con accumulo) e termina quando l’utente inserisce il numero 0.\nsomma = 0\nvoto = int(input(&quot;Inserisci un voto (intero, da 1 a 10): &quot;))\nwhile voto!= 0:\n  print(voto)\n  somma += voto\n  voto = int(input(&quot;Inserisci un voto (intero, da 1 a 10): &quot;))\n\nLettura in input fino a che non si riceve il valore desiderato\nChiedo in input all’utente un valore con specifici vincoli e lo richiedo finché non ottengo un valore “valido”.\nleggi valore\nfinché valore non valido:\n  stampa &quot;Non valido&quot;\n  leggi valore\n\nEsempio. Scrivere un programma che chiede all’utente di inserire un voto. Il programma verifica che sia compreso tra 1 e 10 (estremi inclusi): se non lo è, richiede nuovamente l’inserimento e continua così finché non viene inserito un voto “valido”.\n  voto = float(input(&quot;Inserisci un voto (da 1 a 10): &quot;))\n  while (voto &lt; 1 or voto &gt; 10):\n    print(&quot;Il voto deve essere compreso tra 1 e 10&quot;)\n    voto = float(input(&quot;Inserisci un voto (da 1 a 10): &quot;))\n\nAlternative\nSe non si vuole duplicare il codice dell’input, al posto della prima lettura (quella fuori dal while) si può assegnare a valore un valore sicuramente non valido (es. voto = 0 nell’ultimo esempio; adattabile anche al penultimo), di modo che il ciclo while venga eseguito sicuramente almeno la prima volta.\nNei linguaggi che lo permettono (non Python) è possibile in alternativa usare il costrutto do... while.\nUn’altra possibilità è quella di usare le eccezioni.\nEsempio. Scrivere un programma che chiede all’utente di inserire un intero, e continua a chiederlo finché non lo ottiene.\nx = None\nwhile x is None:\n    try:\n        x = int(input(&#039;Dammi un intero: &#039;))\n    except ValueError:\n        print(&#039;Volevo un intero, e tu non me lo hai dato.&#039;)\nprint(&quot;Grazie di avermi dato l&#039;intero&quot;, x)\n\nEsercizio\n\nPer ogni pattern, individuare un esempio (diverso da quelli già presentati e possibilmente non troppo ovvio) di applicazione del pattern, e scrivere il codice Python corrispondente.\n\nRiferimenti Bibliografici\n\nOwen Astrachan &amp; Eugene Wallingford - Loop Patterns\nPhilip Guo - Python Tutor\nWikipdia - Design pattern\nMichael J. Clancy and Marcia C. Linn. 1999. Patterns and pedagogy. SIGCSE Bull. 31, 1\n\nGrazie a Simone Martini e Stefano Pio Zingaro per i contributi al miglioramento di questa pagina"},"Argomenti/Algoritmi/Progetti/Progetto-gioco-scratch":{"slug":"Argomenti/Algoritmi/Progetti/Progetto-gioco-scratch","filePath":"Argomenti/Algoritmi/Progetti/Progetto gioco scratch.md","title":"Progetto gioco scratch","links":[],"tags":[],"content":"Introduzione\nQuesto progetto finale rappresenta un percorso completo in Scratch, integrando gradualmente le funzionalità apprese in esercitazioni precedenti. Ogni step è dedicato all’implementazione di una meccanica specifica, mentre lo step finale prevede la realizzazione di un gioco completo che includa tutte le meccaniche sviluppate. L’obiettivo è guidarvi passo dopo passo verso la creazione di un videogioco originale, consolidando al tempo stesso le competenze di programmazione visuale. Il progetto al termine di tutti gli step sarà oggetto di valutazione.\nStep 1: Movimento, input e animazioni\nInizierete costruendo le fondamenta del vostro gioco. Dovrete creare uno sprite principale (il personaggio controllato dal giocatore) e l’ambiente base in cui si muoverà. Imparerete a programmare il movimento utilizzando i tasti direzionali e farete in modo che il gioco inizi cliccando sulla bandiera verde.\nPer rendere il personaggio più realistico e dinamico, creerete più costumi da alternare durante il movimento, simulando un’animazione. Infine, introdurrete l’uso degli eventi per far reagire lo sprite agli input da tastiera e mouse.\nStep 2: Collezionabili\nIn questo step aggiungerete elementi che il giocatore dovrà raccogliere per ottenere punti. Imparerete a creare sprite che rappresentano oggetti collezionabili (es. monete, stelle, ecc.) e li farete apparire in posizioni casuali sullo schermo.\nAttraverso le variabili, terrete traccia del punteggio e del tempo. Quando il personaggio entra in contatto con uno di questi oggetti, il sistema dovrà rilevarlo e reagire: il punteggio aumenterà, si sentirà un suono e l’oggetto sparirà o cambierà posizione.\nStep 3: Platforming e ostacoli\nOra passerete alla creazione di un vero e proprio livello platform. Imparerete a simulare la gravità, permettendo al personaggio di saltare e cadere in modo realistico.\nCostruirete un ambiente con piattaforme, muri e ostacoli che il giocatore dovrà superare. Imposterete il rilevamento delle collisioni per evitare che il personaggio attraversi gli oggetti solidi e per rendere credibile l’interazione con l’ambiente.\nStep 4: Nemici e proiettili\nIl gioco si arricchirà introducendo nemici e la possibilità di combatterli. Imparerete a creare nemici che si muovono da soli o secondo percorsi definiti. Programmarete cosa succede quando il giocatore li tocca: potrebbe perdere una vita, sentire un suono o tornare all’inizio del livello.\nPotrete anche permettere al personaggio di attaccare, creando un sistema di proiettili con i cloni. I proiettili dovranno muoversi nella direzione corretta, colpire i nemici e farli sparire, aumentando il punteggio.\nStep 5: Power-up\nI power-up, come invincibilità temporanea o salto potenziato, cambieranno momentaneamente le abilità del personaggio. Imparerete a programmarli usando variabili per regolarne durata e attivazione.\nStep 6: Avventura interattiva\nIn questo step il gioco diventerà più narrativo e interattivo. Dividerete il gioco in scene o livelli distinti, ognuno con una parte di storia o una sfida diversa. Potrete inserire dialoghi o scelte multiple che influenzano lo svolgimento del gioco.\nGestirete il passaggio tra le scene usando broadcast e variabili, e userete i cloni per creare personaggi secondari o nemici senza duplicare manualmente tutto. Questo renderà il vostro gioco più ricco e coinvolgente.\nInserirete anche checkpoint: luoghi in cui il gioco salva i progressi del giocatore. Se perde, potrà ripartire da lì invece che dall’inizio. Userete i messaggi broadcast per gestire questi passaggi in modo ordinato.\nStep Finale: Progetto completo\nInfine, realizzerete un gioco personale e completo che unisca tutte le meccaniche imparate. Dedicherete del tempo alla progettazione: definirete l’obiettivo, la storia, la struttura dei livelli, gli elementi grafici e sonori.\nImplementerete ogni parte del gioco con cura, ottimizzando i codici e risolvendo eventuali errori. Una parte importante sarà testare il gioco con i compagni, raccogliere suggerimenti e migliorarlo prima della presentazione finale."},"Argomenti/Algoritmi/Progetti/Videogioco-(programmazione-imperativa-fino-a-funzioni)":{"slug":"Argomenti/Algoritmi/Progetti/Videogioco-(programmazione-imperativa-fino-a-funzioni)","filePath":"Argomenti/Algoritmi/Progetti/Videogioco (programmazione imperativa fino a funzioni).md","title":"Videogioco (programmazione imperativa fino a funzioni)","links":[],"tags":[],"content":"Progetto C++ – “Crea il tuo videogioco”\nObiettivo:\nOgni gruppo deve progettare e realizzare un videogioco testuale o semigrafico (basato su console) in linguaggio C++, rispettando vincoli tecnici comuni. Il tipo di gioco è libero (es. gestionale, quiz, combattimento, labirinto, simulazione…), ma deve essere originale e progettato dal gruppo.\nRequisiti tecnici obbligatori\nIl progetto deve includere tutti i seguenti elementi:\n\nUtilizzo sensato e coerente delle struct, per rappresentare entità significative del gioco (es. giocatore, nemico, oggetto, livello…). Le struct devono essere progettate con più campi e utilizzate attivamente nella logica del gioco.\nFunzioni personalizzate, con:\n\npassaggio di parametri\nreturn di valori (dove opportuno)\nalmeno una funzione che modifichi strutture tramite riferimento o puntatore\nIl programma deve essere correttamente modularizzato, con funzioni che suddividono in modo logico le parti del gioco\n\n\nUso di array statici o matrici\n\nper gestire entità multiple (es. nemici, inventario, mappa…)\n\n\nStrutture di controllo del flusso (SCF):\n\nif/else, switch, for/while, input validati\n\n\nMenù interattivo per guidare l’utente nelle azioni del gioco\nGestione di input e output da console, in modo chiaro e leggibile\nControllo degli errori (es. input scorretto, scelte impossibili…)\nIl gioco deve avere un buon grado di complessità, sia nella struttura che nelle regole di gioco\nUtilizzare solo le competenze apprese in classe: non sarà possibile utilizzare strutture dati non viste in classe, come ad esempio gli array dinamici (classe vector).\n\nSuggerimenti\n\nLe matrici sono comode per rappresentare griglie di gioco, mappe, dungeon…\nUsa le struct per modellare entità principali come personaggi, nemici, oggetti o missioni.\nUsa array di struct per gestire più entità dello stesso tipo (es. inventario, squadra, livello).\nOrganizza il codice in funzioni distinte per: inizializzazione, gestione input, logica di gioco, stampa dello stato.\nValuta l’uso di una matrice per gestire la posizione dei personaggi o ostacoli.\nPrevedi livelli di difficoltà, condizioni di vittoria/sconfitta, punteggi o statistiche per aumentare la profondità del gioco.\nAnche un gioco semplice può diventare interessante se ben rifinito e completo.\n\nMateriale da consegnare\n\nCodice C++ ben strutturato, indentato e commentato nei punti chiave\nRelazione tecnica:\n\nDescrizione del gioco e delle regole con le relative istruzioni\nSpiegazione della struttura del codice e delle funzioni\nDivisione del lavoro e responsabilità\n\n\n\nValutazione\n\nQualità tecnica e funzionamento del gioco\nAderenza ai vincoli tecnici\nQualità del codice sorgente\nChiarezza e cura della relazione\nOriginalità e complessità (senza bisogno di grafica)\nIl docente potrebbe chiedere una breve discussione orale per confermare che il gruppo abbia effettivamente lavorato\n\nOrganizzazione dei gruppi e distribuzione del voto\n\nI gruppi sono composti da 3-4 studenti, formati in base al livello degli studenti sulla base dei risultati ottenuti nelle verifiche precedenti, questo per evitare trascinamenti e per incentivare l’intero gruppo a lavorare sodo per acquisire le competenze richieste.\nIl voto finale del gruppo andrà moltiplicato per il numero dei componenti e i membri dovranno distribuire i punti tra loro, giustificando la scelta nella relazione tecnica.\nNon è possibile specializzare i membri del gruppo in task troppo specifici (ad esempio: scrivere solo la relazione, occuparsi della grafica ecc…). Ogni componente deve contribuire in tutti gli aspetti tecnici del progetto, soprattutto quelli obbligatori.\nIl docente deciderà comunque come distribuire i voti sulla base della discussione orale, a prescindere da quanto scritto nelle relazioni.\n"},"Argomenti/Algoritmi/Ruoli-delle-variabili":{"slug":"Argomenti/Algoritmi/Ruoli-delle-variabili","filePath":"Argomenti/Algoritmi/Ruoli delle variabili.md","title":"Ruoli delle variabili","links":[],"tags":[],"content":"Gli studi sui ruoli delle variabili sono di Jorma Sajaniemi e colleghi.\nQuesta pagina (redatta dai docenti dell’Università degli Studi di Bologna) è ispirata al materiale presente qui.\nI ruoli delle variabili sono usi tipici dei che le variabili hanno nei programmi.\nSecondo i ricercatori che li propongono, i seguenti ruoli coprono il 99% dei programmi semplici.\nNon suggeriamo di insegnare i ruoli in astratto, quanto di farli osservare (e nominarli) esplicitamente quando si incontrano istanze concrete della loro applicazione.\nMaggiori informazioni sull’uso dei ruoli nella didattica può essere trovato qui.\nNB: svolgere gli esercizi di completamento indicati sotto ciascun ruolo solo dopo aver letto tutti i ruoli.\nValore fissato\nUna variabile assume il ruolo di “valore fissato” se il suo valore non viene modificato a runtime, dopo l’inizializzazione.\npigreco = 3.14\nr = float(input(&quot;Inserisci il raggio:&quot;))\nvol = (4/3)*pigreco*(r**3)\nprint(&quot;Il volume della sfera è&quot;, vol)\n\nSia la variabile pigreco che r sono dei valori fissati\nLa variabile vol è ___\nCosa fa il programma? ____\nContatore o Indice\nIl contatore/indice serve per scorrere una succesisone di vaori in modo sistematico. Può anche essere usato per contare o come indice di un array/lista.\nn = int(input(&quot;Di che numero vuoi la tabellina?:&quot;))\nfattore = 0\nwhile fattore &lt; 11:\n    print(n,&quot;x&quot;,fattore,&quot;=&quot;,n*fattore)\n    fattore += 1\n\nLa variabile fattore è un contatore/indice.\nLa variabile n è ___\nCosa fa il programma? ____\nValore più recente\nUna variabile è un valore più recente se contiene il più recente valore che posseggo di una certa sequenza o input.\nvoto = float(input(&quot;Inserisci un voto (da 1 a 10): &quot;))\nwhile (voto &lt; 1 or voto &gt; 10):\n    print(&quot;Il voto deve essere compreso tra 1 e 10&quot;)\n    voto = float(input(&quot;Inserisci un voto (da 1 a 10): &quot;))\nprint(voto)\n\nLa variabile voto è un valore più recente.\nCosa fa il programma? ____\nValore più desiderato\nSi tratta del “miglior” valore che ho trovato fino a questo momento.\nL = [3, 1, 4, 10, 2, 7]\nmassimo = L[0]\nfor e in L[1:]:\n    if e &gt; massimo:\n        massimo = e\nprint(&quot;Massimo: &quot;, massimo)\n\nLa variabile massimo è un valore più desiderato.\nLa variabile L è ___\nLa variabile e è ___\nCosa fa il programma? ____\nAccumulatore\nUn accumulatore accumula tutti i valori che ho trovato fino a questo momento. Solitamente, va inizializzato con l’elemento neutro dell’operazione di accumulazione (es. 0 se somma, 1 se prodotto, collezione vuota se collezione, stringa vuota, True o False…).\ns = 0\nn = 0\ni = int(input(&quot;Pioggia caduta: &quot;))\nwhile i != 99999:\n    if i &gt;= 0:\n        s += i\n        n += 1\n    i = int(input(&quot;Pioggia caduta: &quot;))\n\nif n&gt;0:\n    print(&quot;Media di pioggia caduta:&quot;, s/n)\nelse:\n    print(&quot;Nessun dato&quot;)\n\nLa variabile s è un accumulatore.\nLa variabile n è ___\nLa variabile i è ___\nPrecedente\nUna variabile è un precedente se contiene il valore di un’altra variabile nel momento in cui quest’ultima assume un nuovo valore (e dunque ricorda il valore precedente di quest’ultima)\n#Da un&#039;idea di Dario Malchiodi\nprev_fibo = 0\nfibo = 1\nconta = 2\nwhile fibo &lt; 4000000:\n   c = prev_fibo + fibo\n   prev_fibo = fibo\n   fibo = c\n   conta += 1\nprint(conta)\n\nLa variabile prev_fibo è un precedente della variabile fibo\nLa variabile conta è __\nLa variabile c è __\nCosa fa il programma? ____\nFlag unidirezionale\nUn flag unidirezionale è un booleano che può essere cambiata una sola volta, dopodiché non può più essere riportata al suo valore originale (è “write once”).\ns = &quot;Michael Lodi&quot;\nspazio = False\nvocali = 0\nfor c in s:\n    if c in &quot;aeiouAEIOU&quot;:\n        vocali += 1\n    elif c == &quot; &quot;:\n        spazio = True\nprint(&quot;La stringa&quot;, s, &quot;contiene&quot;, vocali, &quot;vocali.&quot;)\nif spazio:\n    print(&quot;La stringa&quot;, s, &quot;contiene almeno uno spazio&quot;)\n\nLa variabile spazio è un flag unidirezionale\nLa variabile vocali è ___\nLa variabile c è ___\nLa variabile s è ___\nCosa fa il programma? ____\nTemporanea\nUna variabile è temporanea se il suo valore è utilizzato soltanto per un breve periodo di tempo [e solo per calcoli intermedi], come ad esempio lo scambio di variabili. Si usa anche per ragioni di efficienza (memorizzare un valore che andrebbe ricalcolato più volte) o per rendere più leggibile un programma.\nM = [[1,2,3],[4,5,6]]\nMT = []\nr = len(M)\nif r != 0:\n    c = len(M[0])\n    for i in range(c): \n        col = [] \n        for j in range(r): \n            col.append(M[j][i])\n        MT.append(col)\nprint(MT)\n\nLe variabili r e c sono variabli temporanee\nLe variabili r e c sono anche ____\nLe variabili MT e col sono ___\nLa variabile col è anche ___\nLe variabili i e j sono ___\nCosa fa il programma? ____\nAttraversatore\nUn attraversatore serve per scorrere gli elementi di una struttura dati (ad esempio in un “foreach”)\nclass Nodo:\n    def __init__(self, valore=None, succ=None):\n        self.valore = valore\n        self.succ = succ\n    def __str__(self):\n        return str(self.valore)\n\nLL = Nodo(1, Nodo(2, Nodo(3)))\n\np = LL\nwhile p is not None:\n    print(p, end = &quot; &quot;)\n    p = p.succ\nprint()\n\nLa variabile p è un attraversatore\nLa variabile LL è ___\nCosa fa il programma? ____\nAltri ruoli, che non studiamo oggi, sono:\nOrganizer\nSi tratta sostanzailmente di strutture dati ausiliarie (es. liste) usate per riorganizzare elementi dopo l’inizializzazione\nContainer\nStruttura dati ausiliaria in cui gli elementi possono essere aggiunti e rimossi (es. pila)"},"Argomenti/Bool/Dispensa-sull'algebra-di-Boole-e-circuiti-logici":{"slug":"Argomenti/Bool/Dispensa-sull'algebra-di-Boole-e-circuiti-logici","filePath":"Argomenti/Bool/Dispensa sull'algebra di Boole e circuiti logici.md","title":"Dispensa sull'algebra di Boole e circuiti logici","links":[],"tags":[],"content":"\n\n                  \n                  Autore \n                  \n                \n\n\nProf. Davide Daffonchio\n\n\n\nIndice\n \nIntroduzione di base\nL’algebra booleana, fondamentale in matematica, informatica, elettronica e in molte altre discipline, si basa sul concetto di valori di verità assoluti: vero (1) o falso (0). Questa sezione introduttiva esplora le proposizioni semplici e composte, offrendo una base per comprendere come queste possano essere combinate tra loro.\nProposizioni Semplici\nUna proposizione semplice è un’affermazione che può essere chiaramente identificata come vera o falsa. Non contiene altre proposizioni al suo interno e rappresenta l’unità fondamentale dell’algebra booleana. Ad esempio, l’affermazione “Piove” è una proposizione semplice perché può essere soltanto vera o falsa.\nProposizioni Composte\nUna proposizione composta si forma combinando due o più proposizioni semplici tramite operatori logici. Queste proposizioni mostrano relazioni più complesse e il loro valore di verità dipende dai valori delle proposizioni semplici che le compongono. Esempi di proposizioni composte includono affermazioni come “Piove e fa freddo” o “Fa caldo o è nuvoloso”, dove “e” e “o” sono operatori logici.\nTabelle di Verità\nLe tabelle di verità sono strumenti essenziali nell’algebra booleana per determinare il valore di verità di proposizioni composte in base a tutti i possibili valori delle proposizioni semplici. Per ogni operatore logico, si può costruire una tabella di verità che mostra il risultato della combinazione di valori di verità.\nOperatori Logici Fondamentali\nPer combinare le proposizioni, si usano vari operatori logici. Ecco i più comuni:\n\n\nAND (Congiunzione) ∧: Indica che entrambe le proposizioni devono essere vere affinché l’intera proposizione composta sia vera. Simbolo comunemente usato: ∧. Esempio: Se consideriamo due proposizioni, A: “Piove” e B: “È nuvoloso”, l’operatore AND combina le due proposizioni nella forma A ∧ B: “Piove ed è nuvoloso”. Questa proposizione composta è vera solo se sia A che B sono vere allo stesso tempo.\nLa congiunzione tra due proposizioni è vera solo se entrambe le proposizioni sono vere.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABA ∧ B111100010000\n\n\nOR (Disgiunzione) ∨: Indica che almeno una delle proposizioni deve essere vera affinché l’intera proposizione composta sia vera. Simbolo comunemente usato: ∨. Esempio: Utilizzando le stesse proposizioni A e B, l’operatore OR le combina nella forma A ∨ B: “Piove o è nuvoloso”. Questa proposizione composta è vera se almeno una tra A e B è vera. Quindi, anche se non piove ma è nuvoloso, o viceversa, la proposizione composta risulta vera.\nLa disgiunzione tra due proposizioni è vera se almeno una delle due proposizioni è vera.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABA ∨ B111101011000\n\n\nNOT (Negazione) ¬: Inverte il valore di verità di una proposizione. Se applicato a una proposizione vera, la rende falsa, e viceversa. Simbolo comunemente usato: ¬. Esempio: Prendendo la proposizione A: “Piove”, l’operatore NOT la inverte nella forma ¬A: “Non piove”. Se la proposizione originale A è vera (cioè, piove), allora ¬A è falsa, e viceversa.\nLa negazione inverte il valore di verità di una proposizione.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA¬A1001\n\nXOR (Disgiunzione Esclusiva) ⊕: Valuta l’esclusività tra due proposizioni. Se una proposizione è vera e l’altra è falsa, allora l’XOR restituisce vero; se entrambe sono vere o entrambe sono false, restituisce falso. È l’operatore logico che esprime l’idea di “o l’una o l’altra, ma non entrambe”. Simbolo comunemente usato: ⊕. Esempio: Per le proposizioni A e B, l’operatore XOR le combina nella forma A ⊕ B: “Piove o è nuvoloso, ma non entrambi”. Questa proposizione composta è vera solo se esattamente una tra A e B è vera. Se sia A che B sono vere (cioè, piove ed è nuvoloso allo stesso tempo) o se entrambe sono false (non piove e non è nuvoloso), allora la proposizione composta risulta falsa.\nLa disgiunzione esclusiva tra due proposizioni è vera solo se esattamente una delle due proposizioni è vera.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABA XOR B110101011000\nLa comprensione delle proposizioni semplici e composte, insieme all’uso degli operatori logici, costituisce la base dell’algebra booleana. Questo framework concettuale permette di analizzare e costruire ragionamenti complessi, essenziale non solo in ambito accademico ma anche in molte applicazioni pratiche, dalla programmazione alla progettazione di circuiti elettronici.\nRappresentazioni alternative degli operatori logici\nGli operatori logici di base possono essere rappresentati in vari modi, inclusi i simboli standard usati nell’algebra booleana e nella progettazione dei circuiti. Un modo alternativo, spesso utilizzato in contesti accademici e nei testi, fa uso di notazioni più “verbali” o simboli matematici comuni. Ecco come si possono rappresentare gli operatori logici di base in questo modo alternativo:\n\nAND (Congiunzione)\n\nSimbolo Standard: ∧\nModo Alternativo: A \\cdot B o semplicemente AB\n\n\nOR (Disgiunzione)\n\nSimbolo Standard: ∨\nModo Alternativo: A + B\n\n\nNOT (Negazione)\n\nSimbolo Standard: ¬A\nModo Alternativo: \\overline{A}\n\n\nXOR (Disgiunzione Esclusiva)\n\nSimbolo Standard: ⊕\n\n\n\nQuesti simboli alternativi, specialmente per AND e OR, sono comunemente usati nella matematica e nell’ingegneria per rappresentare le operazioni logiche in modo più compatto, specialmente quando si lavora con espressioni algebriche o nella progettazione di circuiti. Da adesso in avanti useremo questa convenzione.\n\n## Introduzione alle Proposizioni Composte Complesse\n### Definizione\nUna proposizione composta complessa è un&#039;affermazione che si forma combinando due o più proposizioni semplici attraverso l&#039;uso di operatori logici. La complessità di una proposizione composta può variare significativamente: può spaziare da una semplice combinazione di due proposizioni a intricate espressioni che includono diverse proposizioni e operatori annidati.\nA differenza delle proposizioni semplici, che esprimono affermazioni dirette e non divisibili, le proposizioni composte complesse combinano multiple proposizioni semplici e operatori logici per formare affermazioni che possono esprimere concetti più dettagliati e situazioni più sfumate. Queste strutture consentono di modellare e analizzare situazioni del mondo reale in termini binari di vero e falso, rendendole strumenti potenti nella matematica, nell&#039;informatica, nella filosofia, e in molte altre discipline.\nNella programmazione, per esempio, consentono di implementare controlli logici avanzati. Nell&#039;ambito della progettazione di circuiti elettronici, sono utilizzate per definire il comportamento di circuiti logici complessi. In matematica e logica, facilitano la costruzione di dimostrazioni formali e l&#039;analisi di argomentazioni.\n### Struttura e Interpretazione\nLa struttura di una proposizione composta complessa è determinata dall&#039;ordine e dalla combinazione degli operatori logici utilizzati. La precedenza degli operatori stabilisce quale parte dell&#039;espressione deve essere valutata per prima.\nQuando si tratta di proposizioni composte più complesse, la costruzione delle loro tabelle di verità richiede un approccio sistematico. Queste proposizioni possono includere diverse combinazioni di operatori logici e proposizioni semplici. La chiave per analizzarle efficacemente è comprendere e applicare le regole di precedenza degli operatori.\nRegole di Precedenza degli Operatori\nLe regole di precedenza degli operatori determinano l’ordine in cui vengono valutati gli operatori in una proposizione composta. Ecco l’ordine dalla più alta alla più bassa precedenza:\n\n\nNOT: Ha la precedenza più alta perché modifica direttamente il valore di verità della proposizione a cui è applicato.\n\n\nAND: Viene valutato dopo il NOT, poiché rappresenta l’intersezione di verità tra proposizioni.\n\n\nOR: Ha una precedenza inferiore all’AND, poiché rappresenta l’unione di verità tra proposizioni.\n\n\nXOR: Solitamente ha la stessa precedenza dell’OR, ma l’ordine specifico può dipendere dalla convenzione adottata. È importante chiarire questa regola nel contesto in cui si lavora.\n\n\nParentesi: Come in matematica, le parentesi possono essere utilizzate per alterare l’ordine di valutazione standard. Qualsiasi operazione racchiusa tra parentesi ha la precedenza su quelle esterne.\n\n\nSchematizzazione dei Passaggi per la Costruzione di Tabelle di Verità\nPer costruire la tabella di verità di una proposizione composta in modo efficiente, devo seguire in ordine i seguenti passaggi:\n\n\nIdentificare tutte le proposizioni semplici coinvolte e gli operatori. Assegnare a ogni proposizione semplice una lettera (ad es., A, B, C).\n\n\nDeterminare il numero di righe della tabella. Questo sarà (2^n), dove (n) è il numero di proposizioni semplici distinte. Ogni riga rappresenta una possibile combinazione di verità per le proposizioni semplici.\n\n\nElencare tutte le combinazioni possibili di valori di verità per le proposizioni semplici nelle prime colonne della tabella. Per fare questo, si seguono i seguenti passaggi:\n\nNella prima colonna, scrivo vero nella prima metà delle righe e falso nella seconda metà.\nLe colonne successive, vanno riempite tenendo conto della colonna precedente, dimezzando nuovamente le righe in cui mettere vero o falso. Ad esempio se nella prima colonna ci sono 4V e 4F, nella seconda ci saranno 2V 2F 2V 2F e nella terza V F V F V F V F.\n\n\n\nScomporre la proposizione composta nei suoi componenti, seguendo le regole di precedenza degli operatori. Per ciascun sotto-componente che non è una proposizione semplice, aggiungere una colonna nella tabella di verità.\n\n\nCalcolare il valore di verità di ogni sotto-componente per ogni combinazione di valori di verità, seguendo le regole di precedenza.\n\n\nDeterminare il valore di verità della proposizione composta, basandosi sui valori calcolati per i suoi sotto-componenti.\n\n\nEsempio di Applicazione\nPer illustrare l’applicazione delle regole di precedenza degli operatori in una proposizione composta complessa, consideriamo l’esempio seguente:\nA + B  \\overline C\nL’esempio mostra un caso in cui, nonostante l’operatore OR (+) appaia prima dell’AND ( \\cdot ) e della negazione ( \\overline C ) nella sequenza dell’espressione, la congiunzione AND e la negazione hanno comunque la precedenza sulla disgiunzione OR a causa delle regole di precedenza degli operatori. Seguiamo i passaggi per analizzare questa espressione:\n\nIdentificare tutte le proposizioni semplici coinvolte: A, B, C.\nDeterminare il numero di righe della tabella di verità, che sarà 2^n, dove n è il numero di proposizioni semplici distinte. Per A, B, e C, avremo 2^3 = 8 righe.\nElencare tutte le combinazioni possibili di valori di verità per A, B, e C nelle prime colonne della tabella di verità sfruttando la regola detta in precedenza.\nScomporre l’espressione complessa secondo le regole di precedenza degli operatori. Anche se l’OR appare per primo, calcoliamo prima \\overline C, poi B \\overline C, e infine uniamo il risultato con A usando +.\nCalcolare il valore di verità di ogni sotto-componente per ogni combinazione di valori di verità.\nDeterminare il valore di verità dell’espressione complessa per ogni combinazione, basandosi sui valori calcolati per i suoi sotto-componenti.\n\nQuesto approccio evidenzia l’importanza della precedenza degli operatori, dimostrando che, nonostante la presenza fisica precedente dell’operatore OR nell’espressione, l’AND (e le operazioni di negazione ad esso associate) deve essere valutato per primo. Questo esempio dovrebbe aiutare a capire che le regole di precedenza sono cruciali per determinare l’ordine corretto in cui vengono eseguite le operazioni in espressioni logiche composte complesse.\nEcco la tabella di verità per l’espressione, che illustra come vengono calcolati i valori di verità per ogni combinazione delle proposizioni semplici A, B, e C:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABC\\overline CB \\overline CA + B \\overline C111001110111101001100101011000010111001000000100\nNella tabella, i valori 1 e 0 rappresentano rispettivamente il vero e il falso. La colonna \\overline C mostra il risultato della negazione di C. La colonna B \\overline C calcola la congiunzione di B e \\overline C, evidenziando la precedenza dell’operatore AND su OR e della negazione ( \\overline C) su AND. Infine, la colonna A + (B \\overline C) mostra il valore di verità dell’intera espressione, combinando A con il risultato di B \\overline C tramite l’operatore OR, che riflette correttamente le regole di precedenza degli operatori nella valutazione dell’espressione.\n\n## Porte logiche e circuiti logici\nLe porte logiche sono i componenti fondamentali dei circuiti elettronici digitali, usati per eseguire operazioni logiche di base su segnali binari. Ogni tipo di porta logica corrisponde a un operatore logico fondamentale e può essere utilizzato per costruire circuiti logici complessi che eseguono funzioni di elaborazione dell&#039;informazione.\nTipi di Porte Logiche\n\n\nAND Gate: Realizza l’operazione di congiunzione logica. Produce un output alto (1) solo se tutti gli input sono alti (1).\n\n\n\nOR Gate: Realizza l’operazione di disgiunzione logica. Produce un output alto (1) se almeno uno degli input è alto (1).\n\n\n\nNOT Gate (Inverter): Realizza l’operazione di negazione logica. Inverte lo stato dell’input; se l’input è alto (1), l’output sarà basso (0), e viceversa.\n\n\n\nNAND Gate: Una combinazione di una porta AND seguita da una porta NOT. Produce un output basso (0) solo se tutti gli input sono alti (1).\n\n\n\nNOR Gate: Una combinazione di una porta OR seguita da una porta NOT. Produce un output alto (1) solo se tutti gli input sono bassi (0).\n\n\n\nXOR Gate: Realizza l’operazione di disgiunzione esclusiva. Produce un output alto (1) solo se gli input sono diversi tra loro.\n\n\n\nXNOR Gate: L’inverso della porta XOR. Produce un output alto (1) solo se tutti gli input sono uguali.\n\n\n\nCostruzione di Circuiti Logici\nI circuiti logici utilizzano combinazioni di queste porte per eseguire funzioni complesse. Per esempio, un circuito sommatore può essere costruito usando porte XOR, AND e OR per sommare due bit e produrre una somma e un eventuale riporto. Questi circuiti formano la base della logica computazionale utilizzata nei computer e in altri dispositivi elettronici digitali.\nApplicazioni Pratiche\n\nElaborazione dei Dati: I circuiti logici sono impiegati in tutte le forme di elaborazione dei dati digitali, dai microprocessori ai computer.\nMemoria: Le porte logiche sono usate per costruire circuiti di memoria che immagazzinano informazioni binarie.\nControllo: Utilizzate in sistemi di controllo per automazione e robotica, dove le decisioni logiche determinano il comportamento del sistema.\n\n\n### Esempio di espressioni logiche\n![[circuiti.png]]\n![[esercizio_circuiti.png|400x400]]\nApplicazione della logica booleana e dei circuiti logici in contesti reali\nUtilizzo dello XOR in crittografia\nIntroduzione\nL’operazione XOR è centrale in molti sistemi crittografici grazie alla sua capacità di combinare dati in modo reversibile. In crittografia, l’uso dell’XOR permette di fondere il testo in chiaro con una chiave (o keystream) in modo che l’operazione di cifratura e decifratura sia identica, semplificando così i processi di protezione dei dati.\nProprietà rilevanti\nLe proprietà che rendono l’XOR particolarmente utile in crittografia sono:\n\nInvertibilità: La stessa operazione viene usata per cifrare e decifrare; infatti, applicare l’XOR due volte con la stessa chiave restituisce il dato originale (A XOR B XOR B = A).\nCommutatività e associatività: Consentono di combinare più operazioni di XOR senza preoccuparsi dell’ordine, facilitando la progettazione di algoritmi crittografici.\n\nApplicazioni nei cifrari a flusso\nNei cifrari a flusso il testo in chiaro viene cifrato combinandolo bit a bit con un keystream generato da un algoritmo pseudocasuale. L’operazione base è:\nciphertext = plaintext XOR keystream\n\nLa decifratura avviene applicando nuovamente l’XOR con lo stesso keystream, recuperando il testo in chiaro. La sicurezza di questi sistemi dipende fortemente dalla qualità e dalla segretezza del keystream. Se il keystream è prevedibile o viene riutilizzato, l’intero sistema diventa vulnerabile a vari attacchi.\nIl One-Time Pad\nIl One-Time Pad è un esempio ideale di cifratura mediante XOR:\n\nChiave casuale e unica: La chiave è lunga quanto il messaggio, totalmente casuale e usata una sola volta.\nSicurezza teorica: Se i requisiti sono rispettati, il One-Time Pad è matematicamente inoppugnabile.\nLa formula utilizzata è identica a quella dei cifrari a flusso, ma la garanzia della sicurezza risiede nella perfetta casualità e nell’unicità della chiave.\n\nEsempi pratici\nConsideriamo un semplice esempio di cifratura mediante XOR:\nTesto in chiaro (in binario):\n10101010\n\nChiave (in binario):\n11001100\n\nCifratura (bit a bit):\n10101010  \nXOR 11001100  \n-----------\n01100110\n\nPer decifrare, si applica l’operazione XOR tra il testo cifrato e la stessa chiave, ottenendo nuovamente il testo in chiaro grazie alla proprietà di auto-inversione.\nCriticità e limiti\nL’uso dell’XOR in crittografia presenta vantaggi notevoli in termini di efficienza computazionale e semplicità. Tuttavia, emergono alcune criticità:\n\nRiutilizzo della chiave: In sistemi dove la chiave (o keystream) viene usata più di una volta, l’analisi di coppie di messaggi cifrati può portare a rivelare informazioni sul testo in chiaro.\nQualità del keystream: Un keystream non sufficientemente casuale può essere sfruttato tramite attacchi statistici o di criptoanalisi per recuperare la chiave o il testo originale.\nAttacchi noti: Tecniche come l’attacco al keystream riutilizzato (nota anche come “two-time pad”) sfruttano la linearità dell’operazione XOR per individuare pattern e dedurre dati sensibili.\n\nMultiplexer (MUX)\nUn multiplexer (abbreviato in MUX) è un circuito logico combinatorio che seleziona uno tra molteplici ingressi e lo indirizza verso una singola uscita. Questa selezione è governata da specifici segnali di controllo, detti linee di selezione.\nImmaginalo come un interruttore elettronico: in base a un comando (le linee di selezione), decide quale ingresso “passare” all’uscita.\nCome Funziona?\n\nIngressi: 2^n ingressi (A, B, C, D), che rappresentano i dati tra cui scegliere.\nLinee di selezione: n linee di selezione (P_1, P_2) che servono per indicare quale ingresso attivare.\nUscita: L’uscita (Y) è il valore dell’ingresso selezionato.\n\n\nMultiplexer 2-a-1\n\nUn multiplexer 2-a-1 è il tipo più semplice di multiplexer. Ha:\n\n2 ingressi: A e B,\n1 linea di selezione: P, che decide quale dei dati in ingresso viene inviato all’uscita,\n1 uscita: Y, che rappresenta l’ingresso selezionato.\n\nSchema Logico del MUX 2-a-1\nLa funzione logica del MUX 2-a-1 è:\nY=A \\cdot P + B \\cdot \\overline{P}\n\nQuando P = 0, l’uscita è uguale a B.\nQuando P = 1, l’uscita è uguale a A.\n\nTabella della Verità del MUX 2-a-1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLinea di selezione PIngresso AIngresso BUscita Y00000011010001111000101011011111\n\nMultiplexer 4-a-1\n\nUn multiplexer 4-a-1:\n\nHa 4 ingressi (A, B, C, D).\nHa 2 linee di selezione (P_1 e P_2) per scegliere uno degli ingressi.\nHa 1 uscita (Y).\n\nLe linee di selezione determinano quale ingresso passa all’uscita:\n\nSe P_1 = 0 e P_2 = 0, l’ingresso A viene inviato all’uscita.\nSe P_1 = 0 e P_2 = 1, viene inviato B.\nSe P_1 = 1 e P_2 = 0, l’ingresso C viene inviato all’uscita.\nSe P_1 = 1 e P_2 = 1, l’ingresso D viene inviato all’uscita.\n\nEspressione logica del MUX 4 a 1\nL’espressione logica del MUX 4 a 1 è dunque:\nY = A \\cdot \\overline{P_1} \\cdot \\overline{P_2} + B \\cdot \\overline{P_1} \\cdot P_2 + C \\cdot P_1 \\cdot \\overline{P_2} + D \\cdot P_1 \\cdot P_2\nTabella di verità\nEcco la tabella di verità per un MUX 4 a 1:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nP_1P_2ABCDY (uscita)00AXXXA01XBXXB10XXCXC11XXXDD\n\nX indica che quel valore è irrilevante, poiché non influisce sull’uscita.\n\nAltri multiplexer\nPosso creare multiplexer con un qualunque numero di dati in ingresso, ricordando di avere n linee di selezione e 2^n linee di dati.\nSommatore binario\n\n\n                  \n                  Fonte \n                  \n                \n\n\nwww.edutecnica.it/sistemi/sommatori/sommatori.htm\n\n\n\nIntroduzione\nL’addizione è la più elementare delle operazioni aritmetiche; l’addizione è più o meno la sola cosa che i computer fanno. L’unico problema è riuscire a costruire qualcosa che produca delle somme col sistema binario, dato che tutte le macchine sono basate su questo sistema numerico.\nSommare numeri binari è più o meno come sommare numeri decimali. Per sommare due numeri come 245 e 673, si scompone il problema in passi più semplici. Ogni passo richiede soltanto di sommare una coppia di cifre decimali. In questo esempio si comincerebbe con 5 più 3, e così via.\nI sommatori binari sono reti combinatorie che ricevono in ingresso n bit degli addendi da sommare e generano in uscita i bit della somma binaria con il relativo riporto. Si tratta, dunque, di un tipico esempio di rete combinatoria con ingressi multipli e uscite multiple, strutturata in modo da seguire il meccanismo secondo cui avviene la somma binaria.\nTipi di sommatori\nIntroduciamo, pertanto, i due blocchi funzionali fondamentali che sono:\n\nSemi4 binario (HA - Half Adder): senza riporto in ingresso.\nSommatore binario (FA - Full Adder): con riporto in ingresso.\n\nCircuito Semisommatore (HA)\nLa differenza tra la somma in decimale e la somma in binario è che per quest’ultimo sistema lo schema per la somma è molto più semplice:\n0 + 0 = 0\n0 + 1 = 1\n1 + 0 = 1\n1 + 1 = 0 con riporto di 1\nQuesta logica corrisponde alla tabella della verità della porta XOR (a parte la questione del riporto che deve essere risolta).\n\nPer gestire anche il riporto, questo circuito deve essere modificato in modo da risolvere la seguente tabella della verità:\n\n\nA e B sono i bit da sommare.\nS è il bit della somma.\nC è il bit del riporto.\n\nAbbiamo così costruito il semisommatore o Half-Adder.\nCircuito Sommatore (FA)\nIl dispositivo creato si chiama semi-sommatore (half-adder). Questo nome deriva dal fatto che per ottenere la somma completa (full-adder) tra due numeri di più cifre, oltre ai bit dello stesso ordine occorre sommare anche il riporto eventualmente ottenuto dai due bit di ordine immediatamente inferiore.\n\nIngressi: i due bit A e B da sommarsi e il riporto C.\nUscite: il bit di somma e il riporto per il sommatore successivo.\n\n\nDalla tabella di verità è possibile dedurre la funzione logica della somma eseguita di questo circuito combinatorio:\nS = \\overline{A} \\, \\overline{B} \\, C_i + \\overline{A} B \\, \\overline{C_i} + A \\, \\overline{B} \\, \\overline{C_i} + A B C_i\nS = C_i (\\overline{A} \\, \\overline{B} + A B) + \\overline{C_i} (\\overline{A} B + A \\, \\overline{B})\nS = C_i \\, \\overline{(A \\oplus B)} + \\overline{C_i} \\, (A \\oplus B)\nS = (A \\oplus B) \\oplus C_i\nmentre la funzione logica del riporto è la seguente:\nC_o = \\overline{A} B C_i + A \\overline{B} C_i + A B \\overline{C_i} + A B C_i\nC_o = C_i (\\overline{A} B + A \\overline{B}) + A B (\\overline{C_i} + C_i)\nC_o = C_i (A \\oplus B) + A B\nSommatore Parallelo\nQuando si vogliono sommare numeri di più bit ciascuno, il metodo più semplice è quello di realizzare un sommatore parallelo.\n\nQuesto viene costruito mettendo in cascata tanti Full Adder (FA) quanti sono i bit di ciascun numero binario da sommare.\nSe utilizziamo numeri di 4 bit (nibble), i quattro bit di ciascun numero vengono presentati simultaneamente all’ingresso del sommatore parallelo. Nel caso migliore, la somma avviene simultaneamente se non ci sono riporti. Nel caso peggiore, invece, in cui ad ogni somma corrisponde un riporto, si avrà che questo bit traslerà dal primo HA a tutti gli altri FA fino all’ultimo.\nQuesto è uno schema completo di un sommatore a 4 bit che usa solo porte elementari ed in cui i numeri da sommare sono individuati dalle posizioni degli otto deviatori:\n\nIn questo circuito manca il riporto finale che va in overflow.\nMinimizzazioni\nMinimizzazioni algebriche\nIntroduzione\nLa minimizzazione è un processo che mi permette di ottimizzare i circuiti logici in termini di costi, spazio e prestazioni.\nQuesto processo consiste nel trovare un circuito che abbia una tabella di verità equivalente a quello che sto minimizzando che sia però ottimizzato al massimo in termini di dimensioni (in pratica ottenere una espressione logica equivalente semplificata che utilizzi meno porte logiche).\nAd esempio l’espressione Y =\\overline A \\cdot(A+B)+\\overline C+BC\npuò essere semplificata in Y = B+\\overline C.\nQuesto perché entrambe le espressioni hanno la stessa tabella di verità:\nY =\\overline A \\cdot(A+B)+\\overline C+BC\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABC¬AA+B¬A⋅(A+B)¬C¬A⋅(A+B)+¬CBCY00010011010011000000010111110101111101111000101101101010000011001011011110100011Y = B+\\overline C\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBC¬CB+¬C00110100101111010011010010111101Come notiamo, il secondo circuito, pur essendo equivalente al primo, utilizza un ingresso in meno e molte meno porte logiche.\nMa come ottengo la seconda espressione?\nPosso semplificare una qualunque espressione logica grazie ai teoremi e alle proprietà dell’algebra di Boole.\nTeoremi e proprietà dell’algebra di Boole\nQuesto insieme di proprietà e teoremi di base posso utilizzarlo per minimizzare una qualunque espressione logica.\n\n\nProprietà Commutativa\n\nA + B = B + A\nA \\cdot B = B \\cdot A\n\n\n\nProprietà Associativa\n\n(A + B) + C = A + (B + C)\n(A \\cdot B) \\cdot C = A \\cdot (B \\cdot C)\n\n\n\nProprietà Distributiva\n\n\nAB+AC=A(B+C)\n\n\n(A+B)(A+C) = A+BC\nDimostrazione:\nAA + AC + AB + BC = AA + A(B + C) + BC\nma \\quad AA = A \\quad quindi\nA + A(B + C) + BC \\quad cioè\nA \\left[ 1 + (B + C) \\right] + BC\nma \\quad 1 + (B + C) = 1 \\quad quindi\n(A + B)(A + C) = A + BC\n\n\n\n\nTeorema dell’Annullamento (elemento assorbente)\n\nA \\cdot 0 = 0\nA + 1 = 1\n\n\n\nTeorema dell’Identità (elemento neutro)\n\nA \\cdot 1 = A\nA + 0 = A\n\n\n\nTeorema dei Complementi\n\nA \\cdot \\overline{A} = 0\nA + \\overline{A} = 1\n\n\n\nTeorema dell’Idempotenza\n\nA \\cdot A = A\nA + A = A\n\n\n\nPrimo Teorema dell’Assorbimento\n\n\nA + AB = A\n\n\nA\\cdot(A+B)=A\nDimostrazione:\nA + AB = A(1 + B) = A \\cdot 1 = A\nmentre\nA(A + B) = AA + AB =\n= A + AB = A(1 + B) = A \\cdot 1 = A\n\n\n\n\nSecondo Teorema dell’Assorbimento\n\n\nA+\\overline AB=A+B\nDimostrazione:\nA + B = A + B(A + \\overline{A}) = A + AB + \\overline{A}B\n= A(1 + B) + \\overline{A}B = A + \\overline{A}B\n\n\n\n\nTeorema dell’Involuzione (o della doppia negazione)\n\n\\overline{\\overline{A}} = A\n\n\n\nTeoremi di De Morgan\n\n\\overline{A \\cdot B} = \\overline{A} + \\overline{B}\n\\overline{A + B} = \\overline{A} \\cdot \\overline{B}\n\n\n\nEsempio\nProviamo ad applicare i teoremi per minimizzare l’espressione che abbiamo visto nell’esempio prima, ovvero dimostrare che \\overline A \\cdot(A+B)+\\overline C+BC = B+\\overline C, mostrando per ogni passaggio i teoremi e le proprietà utilizzate.\n\\overline A \\cdot (A+B)+\\overline C+BC =\n= \\overline AA+\\overline AB+\\overline C+BC = svolta moltiplicazione\n= \\overline AB+\\overline C+BC= per il teorema dei complementi\n= \\overline AB+\\overline C+B= per il secondo teorema dell’assorbimento\n=B+\\overline C per il primo teorema dell’assorbimento\nMappe di Karnough\nLe mappe di Karnough (o Karnaugh maps, K-map) sono uno strumento grafico per la semplificazione delle espressioni booleane. Ogni mappa è una tabella che rappresenta visivamente tutte le combinazioni possibili dei valori delle variabili di ingresso.\nLa disposizione delle celle segue l’ordine del Gray code, in modo che celle adiacenti differiscano per una sola variabile, facilitando l’individuazione di gruppi di 1 adiacenti.\nSono particolarmente comode in quanto sono più veloci da utilizzare rispetto alle classiche minimizzazioni algebriche, ma solo se:\n\nConosco a priori i valori di verità dell’espressione o li posso facilmente calcolare\nNon ho espressioni troppo complesse (di solito fino a 4 proposizioni)\n\nProcedura operativa per l’uso delle mappe di Karnough\n\nIdentificare le variabili\nConta quante variabili ha la funzione booleana e assegna un simbolo a ciascuna (es. A, B, C…).\nDisegnare la mappa\nCostruisci una tabella con 2^n celle. Usa intestazioni in Gray code per garantire che celle adiacenti differiscano per una sola variabile.\nCompilare la mappa\nInserisci in ciascuna cella il valore della funzione:\n\n1 se la funzione è vera in quella combinazione\n0 se è falsa\nX se la combinazione è “non importa” (don’t care), cioè può essere considerata sia 0 sia 1 a seconda della comodità nella minimizzazione.\n\n\nIndividuare i raggruppamenti di 1\n\nCerca gruppi di 1 adiacenti in potenze di 2 (1, 2, 4, 8…).\nPuoi includere le celle con X nei gruppi, trattandole come 1 se servono a ottenere gruppi più grandi e una forma più semplice.\nOgni gruppo deve essere il più grande possibile.\nI gruppi possono sovrapporsi: uno stesso 1 (o X) può appartenere a più gruppi.\nPuoi raggruppare celle ai bordi opposti della mappa (adiacenza toroidale).\n\n\nScrivere i prodotti semplificati\nPer ciascun gruppo:\n\nIndividua quali variabili rimangono costanti nel gruppo.\nSe una variabile ha valore 1 costante, si scrive con la lettera normale (es. A).\nSe una variabile ha valore 0 costante, si scrive negata (es. ¬A).\nLe variabili che cambiano non si scrivono.\nCombina le variabili costanti con l’operazione AND (·).\n\n\nCombinare i prodotti\nSomma (OR, indicato con +) tutti i prodotti ottenuti dai gruppi per formare l’espressione minimizzata.\n\nEsempi\nFonte immagini: www.youtube.com/watch - Elisabetta Vannucchi\n2 variabili\n\n3 variabili\n\n4 variabili\n\n\n\n\n                  \n                  Nota \n                  \n                \n\n\nAlcune forme che ottengo in realtà non sono davvero minimizzate, posso ancora fare dei raccoglimenti per utilizzare meno porte logiche.\n\n\n"},"Argomenti/Bool/Esercizi/Eserciziario-minimizzazioni":{"slug":"Argomenti/Bool/Esercizi/Eserciziario-minimizzazioni","filePath":"Argomenti/Bool/Esercizi/Eserciziario minimizzazioni.md","title":"Eserciziario minimizzazioni","links":[],"tags":[],"content":"Esercizio 1\n\\overline A \\cdot (A+B)+\\overline C+BC=B+\\overline C\nEsercizio 2\n\\overline {A+A \\overline B+CD}=\\overline A (\\overline C+ \\overline D)\nEsercizio 3\n\\overline B \\cdot \\overline C+ AB \\overline C=\\overline B \\cdot \\overline C+ A \\overline C\nEsercizio 4\n\\overline A \\cdot \\overline B \\cdot \\overline C+ A \\cdot \\overline B \\cdot \\overline C+\\overline A \\cdot B \\cdot \\overline C+A \\cdot B \\cdot \\overline C=\\overline C\nEsercizio 5\n\\overline{\\overline{AB}+C \\overline D}=AB \\overline C+ABD\nEsercizio 6\nA \\overline BC+\\overline A \\ \\overline C D+ A \\overline C=A \\overline B+ A \\overline C+\\overline CD\nEsercizio 7\nBC\\overline D+CD+A \\overline B C \\overline D+ \\overline A \\overline BC=C\nEsercizio 8\n\\overline{\\overline A + ABC}=A(\\overline B + \\overline C)\nEsercizio 9\n(A+B)(A+\\overline B)=A\nEsercizio 10\nC+B \\cdot \\overline{A+B} \\cdot \\overline{\\overline A \\cdot \\overline C}+B=C+B\nEsercizio 11\n\\overline{ABC + A} + B=\\overline A + B\nEsercizio 12\n(A+B+\\overline C+D)(A+\\overline B+ \\overline C+ D)(A+\\overline B+ \\overline C+ \\overline D)=A+\\overline C+ D \\overline B\nEsercizio 13\n\\overline{\\overline{A+C}+\\overline A+ \\overline B}+\\overline{BC+\\overline B \\ \\overline C+AB+\\overline A \\ \\overline B}=A \\overline B+ \\overline A B+\\overline A C"},"Argomenti/Bool/Esercizi/Tabelle-di-verità":{"slug":"Argomenti/Bool/Esercizi/Tabelle-di-verità","filePath":"Argomenti/Bool/Esercizi/Tabelle di verità.md","title":"Tabelle di verità","links":[],"tags":[],"content":"Compito 1\n\\overline{A+B} \\cdot C + B\n\\overline{\\overline ABC}+B+AC\n(\\overline A \\ \\overline B+DC+\\overline{ABC})\\cdot C"},"Argomenti/Bool/Interrogazioni-di-recupero":{"slug":"Argomenti/Bool/Interrogazioni-di-recupero","filePath":"Argomenti/Bool/Interrogazioni di recupero.md","title":"Interrogazioni di recupero","links":[],"tags":[],"content":"Barbetta 7-\n\nSa fare la minimizzazione se guidato, soprattutto con de morgan\nsa che per dimostrare equivalenza va fatta tabella di verità\nsa costruire una tabella di verità\nnon conosce bene le precedenze con la negazione totale\nlento a conoscere come funzionano and e or\nnon serve il circuito per dimostrare\nfatica a ragionare anche su cose ovvie\n"},"Argomenti/Bool/Proprietà-e-teoremi-dell'Algebra-di-Boole":{"slug":"Argomenti/Bool/Proprietà-e-teoremi-dell'Algebra-di-Boole","filePath":"Argomenti/Bool/Proprietà e teoremi dell'Algebra di Boole.md","title":"Proprietà e teoremi dell'Algebra di Boole","links":["Argomenti/Bool/Dispensa-sull'algebra-di-Boole-e-circuiti-logici"],"tags":[],"content":"Transclude of Dispensa-sull&#039;algebra-di-Boole-e-circuiti-logici#teoremi-e-proprietà-dellalgebra-di-boole"},"Argomenti/Circuiti-elettrici/Appunti-su-circuiti-elettrici":{"slug":"Argomenti/Circuiti-elettrici/Appunti-su-circuiti-elettrici","filePath":"Argomenti/Circuiti elettrici/Appunti su circuiti elettrici.md","title":"Appunti su circuiti elettrici","links":[],"tags":[],"content":"Fonti:\n\nwww.youtube.com/@StepbyStepFisica\nwww.youmath.it/lezioni/fisica/elettricita/4920-leggi-di-kirchhoff.html\n\nIntroduzione\n⚡ Potenziale e superfici equipotenziali\n\nIl potenziale è come l’altezza o profondità creata dalle cariche elettriche.\nSe una carica si muove restando sempre alla stessa altezza, non cambia potenziale.\nQuesto percorso si chiama superficie equipotenziale.\n\nMetafora: correre sul bordo di una piscina senza salire o scendere.\n\n\nAnche se sembra una linea, in realtà in 3D è una superficie.\nEsempio: una carica che gira intorno a un’altra carica a distanza costante.\n\n\n✨ A cosa servono le superfici equipotenziali?\n\nAiutano a fare disegni più semplici.\nViste dall’alto si capiscono subito i dislivelli.\nSono sempre perpendicolari al campo elettrico:\n\nCampo e superfici formano angoli di 90° ovunque.\n\n\nFinché le cariche si muovono su una superficie equipotenziale:\n\nIl campo elettrico non compie lavoro.\nL’energia per muoversi viene solo da chi si sposta.\n\n\n\n\n🧊 Conduttori e isolanti\n\nNei conduttori, le cariche:\n\nRestano solo sulla superficie.\nSi distribuiscono per avere tutto allo stesso potenziale.\nMetafora: una festa in piscina dove tutti si vergognano e rimangono sul bordo.\n\n\nSe si collegano due conduttori:\n\nLe cariche si spostano subito finché i potenziali diventano uguali.\n\n\nNegli isolanti, invece:\n\nLe cariche possono stare anche all’interno.\nMetafora: tutti fanno acqua zumba dentro la piscina.\n\n\nOgni conduttore ha una capacità, cioè quanta carica può accumulare:\nC = \\frac{Q}{V}\n\nC = capacità.\nQ = carica.\nV = potenziale.\n\n\nL’unità di misura: Farad.\n\n\n🛠️ Esempio con la statua e il bastone\n\nStatua di bronzo: capacità = 80.000 F.\nBastone del nonno: capacità = 20.000 F, caricato con 5.000 C.\nPotenziale del bastone:\nV = \\frac{Q}{C} = \\frac{5.000}{20.000} = 0,25 V\n\nQuando bastone e statua si toccano:\n\nDiventano un unico conduttore.\nLe cariche si ridistribuiscono.\nLa statua avrà 4 volte la carica del bastone (perché ha 4 volte la capacità).\nCariche finali:\n\nBastone: 1.000 C.\nStatua: 4.000 C.\n\n\nPotenziale finale:\nV = \\frac{Q}{C} = \\frac{4.000}{80.000} = 0,05 V\n\n\n\nSe il potenziale misurato è diverso, significa che la capacità reale era un’altra.\n\n\n🪓 Le punte dei conduttori\n\nNelle punte, la carica si concentra di più.\nMetafora: sembra che ci sia più gente ammassata anche se la lunghezza è uguale.\nQui il campo elettrico è più intenso.\n\n\n🏛️ I condensatori\n\nDue conduttori si chiamano armature.\nInsieme formano un condensatore.\nEsempio: due piastre parallele.\nMetafora: due piscine vicine dove ognuno fa la sua festa.\nUn condensatore:\n\nAccumula cariche opposte (+Q e –Q) sulle armature.\nLa capacità si calcola:\nC = \\frac{Q}{\\Delta V}\n\nΔV = differenza di potenziale tra le due piastre.\n\n\nIl campo elettrico tra le piastre:\nE = \\frac{\\sigma}{\\varepsilon_0}\ncon σ = densità di carica.\n\n\n🧮 Capacità di un condensatore piano\n\nFormula:\nC = \\varepsilon_0 \\varepsilon_r \\frac{A}{d}\n\nA = area delle piastre.\nd = distanza tra le piastre.\nε₀ = costante dielettrica del vuoto.\nεᵣ = costante dielettrica del materiale tra le piastre.\n\n\nMetafora:\n\nPiastre più grandi = più gente alla festa.\nPiastre più vicine = festa più intensa.\nMettere un materiale tra le piastre è come alzare una siepe: aumenta la capacità.\n\n\n\n\n💡 Energia nei condensatori\n\nQuando accumulano cariche, immagazzinano energia potenziale elettrica:\nU = \\frac{1}{2} Q \\Delta V\n\nDensità di energia (indipendente dalle dimensioni):\nu = \\frac{1}{2} \\varepsilon_0 \\varepsilon_r E^2\n\nSi usa per confrontare condensatori grandi e piccoli.\n\n\n\nCorrente\n⚡ Corrente elettrica\n\nSe le cariche si muovono, parliamo di corrente.\n\nOgni carica in movimento è una corrente (anche un singolo elettrone in un atomo).\nQui consideriamo cariche che si muovono nei fili.\n\n\n\n\n💧 Metafora dell’acqua nel lavandino\n\nNon basta che le cariche si muovano a caso.\n\nServe uno spostamento complessivo in una direzione.\n\n\nCome l’acqua in un lavandino:\n\nSe l’acqua crea vortici ma non scende nel tubo → non scorre.\nSe levi il tappo, l’acqua si muove in una direzione → corrente.\n\n\nI fili sono i tubi, le cariche sono l’acqua.\n\n\n🔢 Corrente nei circuiti\n\nCorrente = portata di un fiume: quanta carica passa in un punto al secondo.\nFormula:\nI = \\frac{\\Delta Q}{\\Delta t}\n\nUnità di misura: Ampere (A).\n\n\n↔️ Convenzione del verso\n\nAll’inizio si pensava che a muoversi fossero cariche positive.\nPoi si è scoperto che sono gli elettroni negativi.\nDi conseguenza:\n\nLa corrente teorica scorre in un verso.\nGli elettroni si muovono nel verso opposto.\n\n\nAncora oggi si fa finta che si muovano cariche positive.\n\n\n🪵 Il filo non è vuoto\n\nIl filo è come un torrente di montagna pieno di ostacoli (ioni positivi).\nLe cariche non riescono ad andare dritte:\n\nContinuano a schiantarsi qua e là.\nSi muovono avanti lentamente.\n\n\nMetafora dei tizi bendati che corrono in un bosco:\n\nSi agitano ovunque e sbattono contro tutto.\nSe guardi quanto procedono avanti, è pochissimo.\n\n\nVelocità di deriva:\n\nSpostamento medio in avanti.\nMolto più lenta della velocità di agitazione. (circa un centimetro al secondo)\nFormula:\nv_d = \\frac{I}{e \\cdot A \\cdot n}\ndove:\n\ne = 1,6 \\times 10^{-19} C (carica dell’elettrone)\nA = sezione trasversale del filo\nn = densità di elettroni\n\n\n\n\n\n\n💡 Perché la lampadina si accende subito\n\nNon bisogna immaginare elettroni fermi all’interruttore in attesa di partire.\nTutto il filo è già pieno di elettroni.\nPremendo il pulsante si manda un segnale (“correre!”) che si propaga molto veloce.\nLa lampadina si accende grazie agli elettroni già vicini.\n\n\n🔋 Generatore e differenza di potenziale\n\nCome una pompa dell’acqua che spinge il flusso.\nNei circuiti la “pompa” è il generatore o la batteria.\n\nSimbolo: sbarra lunga (+), sbarra corta (–).\n\n\nLa corrente convenzionale va dal più al meno.\nLa batteria crea una differenza di potenziale (= altezza per l’acqua).\nSe non ci fosse differenza di potenziale:\n\nCome avere un tubo piatto → l’acqua non scorre.\nGli elettroni sarebbero fermi.\n\n\nLa differenza di potenziale si chiama forza elettromotrice (f.e.m.).\n\nSi misura in Volt.\nNon è una forza, nonostante il nome.\n\n\nTra generatori in conflitto:\n\nVince quello con la f.e.m. maggiore.\n\n\n\n\n⚡ Tipi di generatori\n\nGeneratori di tensione:\n\nMantengono costante la differenza di potenziale.\nLa corrente si adegua.\n\n\nGeneratori di corrente:\n\nMantengono costante la corrente.\nRegolano la tensione.\n\n\n\n\n🔀 Corrente continua e alternata\n\nModalità continua:\n\nf.e.m. o corrente costante.\n\n\nModalità alternata:\n\nf.e.m. e corrente fluttuano.\nCome un tubo dell’acqua in cui si generano onde.\n\n\nEsempio:\n\nLa presa di corrente di casa → corrente alternata.\n\n\n\nResistenze e leggi di Ohm\n🌊 Circuiti elettrici e resistenze\nNella puntata precedente si era detto che i circuiti sono come tubi dell’acqua, dove il flusso si chiama corrente, e l’acqua corrisponde alle cariche elettriche.\nTra gli elementi principali dei circuiti c’è il generatore, che è come una pompa: crea una differenza di potenziale e fa muovere le cariche “verso l’alto”. Ma se le cariche salgono, poi devono anche “scendere”.\n\n⚙️ Il resistore: la cascatella con il mulino\nCi sono componenti che fanno “scendere” le cariche creando una differenza di potenziale negativa.\nIl più importante è il resistore, che si disegna con il simbolo a zig-zag.\nUn resistore si può immaginare come un mulino o una turbina nel condotto:\n\nL’acqua (le cariche) cade e incontra resistenza, facendo girare il mulino.\nDopo aver ceduto energia, il liquido continua a scorrere.\nAllo stesso modo, il resistore è una “cascatella” che alimenta qualcosa: una lampadina, un microfono, un robot assassino, qualsiasi dispositivo elettrico.\n\n\n📏 Resistenza\nLa resistenza misura quanto il resistore ostacola la corrente.\nSi indica con la lettera R e si misura in Ohm (Ω), in onore di Ohm che formulò le due leggi fondamentali.\nLa prima legge di Ohm dice:\nI = \\frac{\\Delta V}{R}\noppure, se preferite:\n\\Delta V = I \\times R\nInterpretazione con la metafora:\n\nPiù alto è il salto dell’acqua (ΔV), più veloce scorre (I).\nPiù “pesante” è il mulino (R), più lenta è la corrente.\nEsempio:\nUn resistore con tensione di 10 V e resistenza di 20 Ω:\n\nI = \\frac{10}{20} = 0,5\\text{ A}\n\n🧱 Cosa determina la resistenza di un resistore?\nLa resistenza dipende:\n\nDal materiale (come se il mulino fosse di pietra o di legno).\nDalle dimensioni.\nLa formula generale è:\n\nR = \\rho \\frac{L}{A}\nDove:\n\nρ (rho) = resistività (caratteristica del materiale, trovabile nelle tabelle).\n\nPiù alta la resistività, più difficile il passaggio della corrente.\nLa resistività aumenta con la temperatura (es. smartphone al sole: resistenza cresce e il telefono smette di funzionare bene).\n\n\nL = lunghezza del resistore.\n\nPiù lungo il “torrente con rapide”, più fatica fanno le cariche.\n\n\nA = area della sezione del filo.\n\nUn fiume largo = più facile evitare gli scogli.\nSe il fiume è stretto, è più facile che le cariche si scontrino.\nPer i fili circolari:\n\nA = \\pi r^2\n\n\n\n🛠️ Semplificazione dei circuiti\nI circuiti possono essere semplificati sostituendo gruppi di resistori con uno equivalente.\nCi sono due casi principali:\n1️⃣ Resistori in serie\n\nSono collegati uno dopo l’altro, senza ramificazioni.\nHanno tutti la stessa corrente, ma differenze di potenziale diverse.\nMetafora: cascatelle una dopo l’altra nello stesso fiume.\nResistenza equivalente:\nR_{eq} = R_1 + R_2 + \\ldots\n\n\n\n2️⃣ Resistori in parallelo\n\nSono collegati fianco a fianco, con entrambe le estremità in comune.\nTutti hanno la stessa differenza di potenziale, ma correnti diverse.\nMetafora: più tubi paralleli che scendono della stessa altezza.\nResistenza equivalente:\n\\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2}\nSe ci sono solo due resistori:\nR_{eq} = \\frac{R_1 \\cdot R_2}{R_1 + R_2}\n\n\n\n🧩 Esempio di semplificazione di un circuito complesso\nStrategia:\n\nIndividuare quali resistori sono in serie e quali in parallelo.\nSemplificarli un passo alla volta.\nRipetere finché rimane un solo resistore equivalente.\nEsempio pratico (semplificato):\n\n\nResistori 1 e 2: in serie → sostituiti con R12 = R1 + R2.\nResistori 4 e 5: in serie → R45 = R4 + R5.\nResistori 7 e 8: in parallelo → R78 = (R7×R8)/(R7+R8).\nPoi R45 e R3 risultano in parallelo → R345.\nR6, R78 e R9 in serie → R6789.\nInfine, i tre resistori rimasti in serie → resistenza totale = somma.\nAlla fine si ottiene un unico resistore equivalente, che semplifica l’analisi del circuito.\n\n\nLeggi di Kirchhoff\n🔄 Leggi di Kirchhoff\n1️⃣ Legge dei Nodi\n\nUn nodo è un punto dove un filo si divide o si unisce (come una rotonda nei tubi dell’acqua).\nLa legge dice:\n\nLa somma delle correnti che entrano in un nodo è uguale alla somma di quelle che escono.\n\n\nMetafora:\n\nSe quattro cariche arrivano al bivio, se ne devono andare in totale quattro, distribuite come vuoi.\n\n\n\n\n\n2️⃣ Legge delle Maglie\n\nUna maglia è un percorso chiuso (un giro completo nel “parco acquatico per cariche elettriche”).\n\nLa legge dice:\n\nLa somma di tutti i ΔV in una maglia è zero.\n\n\nMetafora:\n\nSe fai un giro chiuso passando per salite (generatore) e discese (resistenze), alla fine devi tornare allo stesso “livello”.\nSegni dei ΔV:\n\n\nPercorri un resistore seguendo la corrente → ΔV negativo.\nPercorri un generatore dalla parte del + al – → ΔV positivo.\nSe vai contro corrente, inverti i segni.\n\n\n🧮 Come si usano insieme\nCombinando:\n\nLeggi dei Nodi\nLeggi delle Maglie\nLegge di Ohm (ΔV = I·R)\nSi crea il sistema di Kirchhoff:\nScrivi tante equazioni quante sono le incognite (le correnti).\nEsempio:\n\nCircuito con 2 nodi e 3 maglie.\nNon serve usarle tutte: alcune si possono scartare (es. un nodo uguale all’altro scritto al contrario).\nSi conservano solo 1 nodo e 2 maglie.\n\n\nA questo punto trasformi i ΔV usando Ohm:\n\nΔV₁ = I₁·R₁\nΔV₂ = I₂·R₂\necc.\n\n\nRisolvi il sistema e trovi le correnti.\n\n\n🌡️ Effetto Joule\nQuando la corrente passa in un resistore:\n\nGli elettroni urtano gli ioni fermi.\nPiù sono veloci, più gli ioni si agitano e si surriscaldano.\nQuesto calore si chiama Effetto Joule.\nFormula del calore prodotto:\n\nQ = R \\cdot I^2 \\cdot \\Delta t\nPotenza dissipata:\nP = R \\cdot I^2\nEsempi:\n\nIl phon.\nLo smartphone bollente dopo un’ora su TikTok.\nIl PC del cugino che gira come un trattore a carbone.\n\n\n🏆 Circuiti con più generatori\nA volte neppure Kirchhoff basta:\n\nIn un circuito con più generatori non si capisce a colpo d’occhio il verso delle correnti.\nEsempio:\n\nGeneratore 1 spinge a destra.\nGeneratore 2 spinge a sinistra.\n\n\nLegge di Sovrapposizione:\n\nSpegni tutti i generatori tranne uno.\nRisolvi con Kirchhoff.\nRipeti con gli altri generatori, uno alla volta.\nSovrapponi le correnti trovate sommandole.\nCosì risolvi anche i circuiti più difficili.\n\n\n\n\n✨ Riassunto degli strumenti a disposizione\n\nOhm: per calcolare tensioni e correnti nei resistori.\nKirchhoff:\n\nNodi → correnti in entrata = correnti in uscita.\nMaglie → somma dei ΔV = 0.\n\n\nSovrapposizione:\n\nDivide e conquista i circuiti con più generatori.\n\n\nEffetto Joule:\n\nSpiega perché le resistenze scaldano.\n\n\n\nCircuiti RC\n⚡ Condensatori nei circuiti\nAbbiamo già visto che i circuiti sono come tubi pieni di acqua (cariche):\n\nGeneratori = pompe che spingono l’acqua su.\nResistori = cascatelle/dislivelli.\nCondensatori = due grossi contenitori (armature).\n\n\n🪣 Metafora del doppio contenitore\n\nQuando il condensatore è scarico:\n\nPrimo contenitore vuoto.\nSecondo pieno.\n\n\nDurante la carica:\n\nIl generatore trasferisce acqua da un pilone all’altro.\nL’acqua totale resta sempre la stessa.\n\n\nQuando il condensatore è carico:\n\nPrimo pieno.\nSecondo vuoto.\nCarica del condensatore Q = acqua nel primo pilone.\n\n\nSe il pilone è vuoto: condensatore scarico.\nSe è pieno: condensatore carico al massimo.\n\n\n🧮 Relazione carica-potenziale-capacità\n\nDelta V (altezza del pilone) = tensione.\nCapacità C = dimensione della base.\nPiù grande la capacità → più carica può entrare.\nFormula:\n\nQ = C \\cdot \\Delta V\n\nCome il volume d’acqua = base × altezza.\n\n\n🟰 Serie e parallelo\nI condensatori si possono collegare in serie o parallelo:\n🔹 Serie:\n\nStessa carica Q su tutti.\nΔV diversi.\nCapacità equivalente:\n\n\\frac{1}{C_{eq}} = \\frac{1}{C_1} + \\frac{1}{C_2}\n(se solo 2 condensatori, anche:\nC_{eq} = \\frac{C_1 \\cdot C_2}{C_1 + C_2}\n🔹 Parallelo:\n\nStessa ΔV su tutti.\nCapacità equivalente:\nC_{eq} = C_1 + C_2\nNota: Le formule sono l’opposto di quelle dei resistori.\n\n\n🚫 Passaggio di carica attraverso un condensatore\n\nTra le due armature non passa corrente.\nIl generatore sposta carica da un’armatura all’altra:\n\nAll’inizio: corrente massima (acqua che scorre).\nAlla fine: corrente zero (i piloni non si riempiono più).\n\n\nProcesso di carica del condensatore.\n\n\n⏳ Carica del condensatore (Circuito RC)\n🔸 Andamento della carica Q(t):\nQ(t) = C \\cdot \\text{f.e.m.} \\cdot \\left(1 - e^{-t/\\tau}\\right)\n🔸 Andamento della corrente I(t):\nI(t) = \\frac{\\text{f.e.m.}}{R} \\cdot e^{-t/\\tau}\n\nτ = costante di tempo = R × C\n\nIndica quanto velocemente si carica.\nDopo ~5τ il condensatore è praticamente carico.\n\n\n\n\n🔄 Scarica del condensatore\n\nSi stacca il generatore.\nIl condensatore rilascia la carica all’altra armatura.\n🔸 Andamento della carica Q(t):\n\nQ(t) = Q_0 \\cdot e^{-t/\\tau}\n🔸 Andamento della corrente I(t):\nI(t) = \\frac{V_0}{R} \\cdot e^{-t/\\tau}\n\nAll’inizio: corrente massima.\nAlla fine: corrente zero.\n\n\n⏱️ Perché studiarli?\n\nI circuiti RC funzionano come orologi elettronici:\n\nImpostano un tempo preciso per caricare/scaricare.\n\n\nApplicazioni:\n\nFlash fotografici.\nPacemaker.\nTemporizzatori nei circuiti elettronici.\n\n\n\n\n🎯 Riassunto delle formule chiave\n\nCarica durante la carica:\nQ(t) = C \\cdot V \\cdot \\left(1 - e^{-t/\\tau}\\right)\n\nCorrente durante la carica:\nI(t) = \\frac{V}{R} \\cdot e^{-t/\\tau}\n\nCarica durante la scarica:\nQ(t) = Q_0 \\cdot e^{-t/\\tau}\n\nCorrente durante la scarica:\nI(t) = \\frac{V_0}{R} \\cdot e^{-t/\\tau}\n\n"},"Argomenti/Cybersecurity-e-Ethical-hacking/Basi-di-crittografia":{"slug":"Argomenti/Cybersecurity-e-Ethical-hacking/Basi-di-crittografia","filePath":"Argomenti/Cybersecurity e Ethical hacking/Basi di crittografia.md","title":"Basi di crittografia","links":[],"tags":[],"content":"Introduzione\nLa sicurezza informatica è un aspetto cruciale dello sviluppo e del mantenimento di applicazioni web. Una delle sue fondamenta è la crittografia, la scienza e l’arte di cifrare e decifrare le informazioni. Questa dispensa, basata sulla sezione di crittografia di WebGoat, esplora diverse tecniche di crittografia ampiamente adottate nelle applicazioni web. Attraverso la comprensione e l’applicazione di questi concetti, gli sviluppatori possono rafforzare significativamente la sicurezza delle loro applicazioni.\nTecniche di codifica e crittografia\nL’obiettivo principale di questa dispensa è fornire una comprensione approfondita delle seguenti tecniche crittografiche, evidenziando la loro importanza e applicazione pratica in contesti reali:\n\n\nEncoding: La trasformazione di dati in un altro formato tramite un metodo conosciuto, che può essere facilmente invertito. L’encoding non offre sicurezza ma è spesso utilizzato per preparare i dati per il trasferimento o l’archiviazione.\n\n\nHashing: La conversione di dati in un breve messaggio digest che rappresenta univocamente il contenuto originale. Gli algoritmi di hashing sono progettati in modo che, anche un minimo cambiamento nei dati di input, produca un digest completamente diverso. Questa tecnica è fondamentale per la verifica dell’integrità dei dati e la memorizzazione sicura delle password.\n\n\nEncryption: La cifratura dei dati in modo che possano essere letti solo da chi possiede la chiave di decifratura corrispondente. L’encryption può essere simmetrica, dove la stessa chiave è usata per cifrare e decifrare, o asimmetrica, che utilizza una coppia di chiavi pubblica e privata.\n\n\nSigning: L’utilizzo di algoritmi di firma digitale per verificare l’autenticità e l’integrità di un messaggio o documento. La firma digitale garantisce che il messaggio non sia stato alterato dopo essere stato firmato.\n\n\nKeystores: Database sicuri utilizzati per conservare chiavi crittografiche e certificati. Sono essenziali per la gestione delle chiavi in applicazioni e infrastrutture IT.\n\n\nSecurity defaults: Le impostazioni predefinite di sicurezza che sono configurate per proteggere le applicazioni e i sistemi. Comprendere e implementare questi default è vitale per prevenire vulnerabilità comuni.\n\n\nPost quantum crypto: L’esplorazione di tecniche crittografiche resistenti agli attacchi da parte di computer quantistici. Questo campo sta guadagnando importanza man mano che la tecnologia quantistica evolve.\n\n\nDopo aver esplorato ciascuna tecnica, verranno proposti vari Esercizi pratici. Questi esercizi sono progettati per rafforzare la comprensione teorica attraverso l’applicazione pratica, consentendo agli utenti di sperimentare direttamente con le tecniche di crittografia in un ambiente controllato come WebGoat.\nEncoding\nEncoding Base64\nDescrizione\nL’Encoding Base64 è un metodo per codificare dati binari (come immagini, file audio, o qualsiasi altro tipo di dato che non sia testo) in una stringa di caratteri ASCII che è più facilmente manipolabile e trasmissibile su sistemi che gestiscono solo testo. Questo è particolarmente utile in contesti web, dove il trasferimento di dati deve avvenire attraverso protocolli che supportano primariamente testo.\nL’encoding Base64 è una tecnica usata per convertire dati binari o testo in un formato composto solo da caratteri stampabili. È comunemente utilizzato in applicazioni web per trasferire dati binari come immagini in forma di stringa. Ecco come funziona l’encoding Base64 e un esempio pratico.\nFunzionamento dell’Encoding Base64\n\nDividi i Dati in Byte: I dati di input vengono divisi in gruppi di byte.\nConverti in Bit: Ogni byte è rappresentato da 8 bit.\nRaggruppa i Bit in Gruppi da 6: I bit vengono raggruppati in blocchi da 6. Se i bit non sono sufficienti per formare un gruppo da 6, si aggiungono zeri alla fine.\nConverti in Valori Decimali: Ogni gruppo da 6 bit viene convertito in un valore decimale, da 0 a 63.\nAggiungi Padding se Necessario: Se il numero totale di bit non è divisibile per 6, si aggiunge il padding ’=’ alla stringa codificata per assicurare che la sua lunghezza sia un multiplo di 4.\nMappa con la Tabella Base64: I valori decimali vengono mappati a un carattere specifico nella tabella Base64, che contiene lettere maiuscole e minuscole (A-Za-z), numeri (0-9), più (+), slash (/) e, in alcuni casi, il carattere uguale (=) per il padding.\n\nEsempio Pratico\nPrendiamo la stringa “Hi” come esempio. Questa volta, la dimensione della stringa causerà l’uso del padding nel risultato finale dell’encoding Base64.\n\nConverti in Bit: La stringa “Hi” corrisponde ai valori ASCII 72 e 105. In bit:\n\nH (72) → 01001000\ni (105) → 01101001\n\n\nRaggruppa i Bit in Gruppi da 6: Unendo i bit si ottiene 0100100001101001, che diviso in gruppi da 6 bit diventa 010010 000110 1001.\nAggiungi Zeri per Completare: L’ultimo gruppo “1001” ha solo 4 bit, quindi aggiungiamo due zeri per formare un gruppo da 6 bit: 100100.\nConverti in Valori Decimali: Convertendo questi gruppi in decimali si ottiene 18, 6, 36.\nMappa con la Tabella Base64 e Aggiungi Padding: Utilizzando la tabella Base64, i valori 18, 6, 36 corrispondono rispettivamente ai caratteri U, G, k. Poiché il risultato finale non è un multiplo di 4, aggiungiamo un carattere ’=’ per il padding.\nRisultato con Padding: La stringa “Hi” codificata in Base64 è SGk=.\n\nAutenticazione Base\nL’Autenticazione Base è un semplice meccanismo di autenticazione HTTP, dove l’ID utente e la password vengono concatenati con un carattere ”:”, codificati in Base64, e inviati nel header della richiesta HTTP. Questo metodo è considerato insicuro se utilizzato su una connessione non crittografata, come HTTP, poiché la stringa codificata in Base64 può essere facilmente decodificata da un attaccante.\nEsempio di Autenticazione Base:\n\nLe credenziali myuser:mypassword vengono codificate in Base64, risultando in bXl1c2VyOm15cGFzc3dvcmQ=.\nQuesta stringa codificata viene poi inclusa nell’header HTTP in una richiesta di autenticazione: Authorization: Basic bXl1c2VyOm15cGFzc3dvcmQ=.\n\nImportanza di TLS/HTTPS:\nPer proteggere le credenziali inviate tramite Autenticazione Base, è essenziale utilizzare TLS (Transport Layer Security), noto anche come HTTPS quando si tratta di comunicazioni web. Questo assicura che i dati trasmessi tra il client e il server siano crittografati e quindi protetti da intercettazioni.\nRitornando alla lezione di WebGoat, l’obiettivo è comprendere non solo come implementare queste tecniche, ma anche riconoscere le loro limitazioni e i contesti in cui possono essere applicate in modo sicuro. Procediamo ora con l’esplorazione delle altre tecniche crittografiche menzionate nella lezione.\nXOR Encoding\nDescrizione\nTalvolta l’encoding è utilizzato come semplice tecnica di offuscamento per la memorizzazione delle password. Ad esempio, l’IBM WebSphere Application Server utilizza una specifica implementazione dell’XOR encoding per memorizzare le password nei file di configurazione. IBM raccomanda di proteggere l’accesso a questi file e di sostituire l’encoding XOR di default con una propria crittografia personalizzata. Tuttavia, quando queste raccomandazioni non vengono seguite, tali impostazioni di default possono diventare una vulnerabilità.\nEsercizio: XOR Encoding\nPer applicare quanto appreso, si consideri la sfida di decodificare stringhe codificate utilizzando questi metodi, in particolare l’XOR encoding. Questo tipo di esercizio pratica la capacità di analizzare e invertire tecniche di encoding semplici, una competenza utile nella valutazione della sicurezza delle applicazioni web.\nPer affrontare e risolvere un esercizio di decodifica XOR, come quello menzionato precedentemente, è cruciale comprendere come funziona l’encoding XOR e quali strumenti o tecniche possiamo utilizzare per invertire il processo. Supponendo che la chiave XOR sia il carattere underscore (_) (ovvero la vecchia chiave di default dei sistemi IBM WebSphere), possiamo procedere con la decodifica.\nCome Funziona l’XOR Encoding\nL’XOR (exclusive OR) è un’operazione logica che confronta due bit, producendo un risultato di 1 solo se i bit confrontati sono diversi. Nell’encoding XOR, ogni byte di dati viene combinato con un byte di chiave mediante l’operazione XOR. Se la stessa chiave viene applicata nuovamente ai dati codificati, si ottiene il messaggio originale. Questo perché l’operazione XOR è reversibile:  (A \\oplus B \\oplus B = A)\nRisoluzione dell’Esercizio\nPer decodificare una stringa codificata con XOR utilizzando la chiave _ (che in ASCII è rappresentata dal valore decimale 95 o dal valore esadecimale 0x5F), seguiamo questi passi:\n\n\nDecodifica Base64: Poiché la stringa codificata {xor}Oz4rPj0+LDovPiwsKDAtOw== è in formato Base64, il primo passo è decodificarla per ottenere i byte originali sottoposti all’encoding XOR.\n\n\nApplicazione dell’XOR con la Chiave: Successivamente, applichiamo l’operazione XOR a ogni byte utilizzando come chiave il valore ASCII di _ (95 o 0x5F). Questo ci permette di invertire l’encoding e recuperare il testo originale.\n\n\nRicostruzione della Password: Dopo aver applicato l’XOR a tutti i byte, il risultato ottenuto sarà la password originale in chiaro.\n\n\nEcco un esempio di codice che esegue questi passi:\nimport base64\n \n# Decodifica della stringa XOR codificata da Base64\nencoded_password = &quot;Oz4rPj0+LDovPiwsKDAtOw==&quot;\nxor_encoded_bytes = base64.b64decode(encoded_password)\n \n# Applicazione dell&#039;XOR usando la chiave &#039;_&#039;\nxor_key = ord(&#039;_&#039;)  # Ottenimento del valore ASCII per &#039;_&#039;\ndecoded_bytes = bytes([byte ^ xor_key for byte in xor_encoded_bytes])\n \n# Conversione dei byte decodificati in stringa\ndecoded_password = decoded_bytes.decode(&#039;utf-8&#039;)\n \nprint(decoded_password)\nQuesto codice Python, seguendo i passi descritti, decodifica efficacemente la stringa XOR codificata, rivelandone il contenuto originale, assumendo che la chiave fornita e il contesto dell’esercizio siano corretti.\nAltri Tipi di Encoding\nOltre all’Encoding Base64, esistono diversi altri tipi di encoding utilizzati nelle applicazioni web per scopi specifici. Questi includono l’URL encoding, l’HTML encoding, UUEncode e l’XOR encoding. Ciascuno ha un ruolo importante nel trattamento e nella trasmissione sicura dei dati.\nURL Encoding\nL’URL encoding è frequentemente impiegato per l’invio di dati di form e parametri di richiesta al server. Poiché gli spazi non sono consentiti in un URL, questi vengono sostituiti con %20. Sostituzioni simili vengono applicate ad altri caratteri non alfanumerici per garantire che l’URL rimanga valido e interpretabile dai server web.\nHTML Encoding\nL’HTML encoding è utilizzato per garantire che il testo venga visualizzato nel browser così come è, senza essere interpretato come codice HTML. Questo previene potenziali attacchi come l’injection di codice, assicurando che stringhe come &lt;script&gt; vengano visualizzate come testo normale piuttosto che eseguite come script.\nUUEncode\nUUEncode, acronimo di Unix-to-Unix encoding, è stato utilizzato per l’invio di allegati via email. Questo metodo di encoding trasforma i file binari in un formato di testo ASCII, rendendoli trasmissibili attraverso sistemi che gestiscono solo testo.\nHashing\nHashing Puro\n\nChe cos’è? L’hashing è una tecnica (NON È un algoritmo crittografico) utilizzata principalmente per verificare se i dati originali sono stati modificati. Consiste nel generare un valore di hash (una sorta di “impronta digitale”) a partire dai dati originali usando tecniche crittografiche irreversibili. Questo significa che, data una stringa di input, è facile calcolare l’hash, ma è praticamente impossibile fare il processo inverso e ricavare i dati originali dall’hash.\nIrreversibilità: È un principio fondamentale dell’hashing che assicura che non si possa risalire ai dati originali partendo dall’hash.\nSensibilità ai cambiamenti: Se anche solo un byte dei dati originali cambia, l’hash risultante sarà completamente diverso. Questo rende l’hashing estremamente utile per verificare l’integrità dei dati.\n\nSicurezza\nAnche se l’hashing può sembrare sicuro perché è basato su tecniche crittografiche, non è una buona soluzione per la memorizzazione delle password. Il problema principale è che gli attaccanti possono utilizzare dizionari di password comuni (o meno comuni) e generare l’hash per ciascuna di queste password. Questi hash possono essere memorizzati in grandi database (conosciuti come “rainbow tables”).\nQuando un attaccante ottiene un hash dal database delle password, può semplicemente cercare questo hash nelle sue “rainbow tables” per trovare la password corrispondente, rendendo inutile l’hashing semplice.\nAlcuni algoritmi di hashing non dovrebbero più essere utilizzati, come MD5 e SHA-1, perché è possibile modificare il payload in modo che il risultato sia lo stesso hash. Questo processo richiede un’enorme potenza di calcolo, ma rimane un’opzione fattibile.\nPassword Complesse\nLe password complesse, che includono una combinazione di lettere maiuscole e minuscole, numeri e simboli, sono più difficili da indovinare o forzare attraverso attacchi di forza bruta. Questo perché l’insieme delle possibili combinazioni cresce esponenzialmente con l’aumento della lunghezza e della complessità della password, rendendo impraticabile l’attacco in termini di tempo e risorse computazionali richieste.\nFunzionamento delle Rainbow Tables\nIl principio dietro le Rainbow Tables si basa sulla riduzione delle password hashate a un formato più gestibile attraverso una serie di funzioni matematiche. Invece di memorizzare un hash per ogni possibile combinazione di password, le Rainbow Tables utilizzano una tecnica chiamata “riduzione” per convertire un hash in un’altra password, che viene poi nuovamente hashata e ridotta in un ciclo che continua per un numero definito di volte. Questo processo crea una catena di hash e password che termina con un hash finale. La tabella memorizza solo la password iniziale e l’hash finale di ogni catena, riducendo significativamente lo spazio di archiviazione necessario.\nUtilizzo delle Rainbow Tables\nQuando si cerca di decifrare un hash, si applica la funzione di riduzione all’hash e si verifica se il risultato è presente come un hash finale in qualche catena della tabella. Se non si trova, si hash il risultato, si applica nuovamente la riduzione, e si continua fino a trovare una corrispondenza o esaurire le catene. Una volta trovata una corrispondenza, si ricostruisce la catena dalla password iniziale per trovare la password che genera l’hash desiderato.\nLimitazioni e Contrasti\nLe Rainbow Tables sono molto potenti, ma hanno delle limitazioni:\n\nSale (Salt): L’uso di un “salt” unico per ogni password rende inefficaci le Rainbow Tables, poiché richiederebbe una tabella separata per ogni possibile salt.\nSpazio di Archiviazione: Nonostante siano un compromesso efficiente, le Rainbow Tables richiedono ancora una notevole quantità di spazio di archiviazione, soprattutto per coprire un ampio spettro di possibilità di password.\nTempo di Ricerca: Anche con una tabella ottimizzata, il tempo per trovare una corrispondenza può essere significativo, soprattutto per hash complessi o saltati.\n\nHash “Salati”\nOvviamente, le password in chiaro non dovrebbero mai essere memorizzate in un database. Lo stesso vale per gli hash puri. Il “Cheat Sheet” di OWASP sulla memorizzazione delle password spiega cosa dovrebbe essere utilizzato quando si devono memorizzare in modo sicuro informazioni relative alle password. L’aggiunta di un “sale” (salt) agli hash, ovvero una stringa di dati casuale unica per ogni password, rende molto più difficile l’uso di attacchi di tipo “rainbow table” per decifrare le password.\nUna Rainbow Table è una tecnica utilizzata per decifrare le password hashate, sfruttando un compromesso tra tempo e spazio per effettuare l’attacco. In sostanza, è un enorme database precalcolato di hash corrispondenti a possibili combinazioni di password. Questo metodo è particolarmente efficace contro sistemi di hash senza sale (salt), ovvero un valore aggiunto all’hashing per renderlo unico anche se due password sono identiche.\nPer mitigare questi attacchi, oltre all’uso di salt, si consiglia l’impiego di funzioni di hashing progettate specificamente per le password, come bcrypt, scrypt o Argon2, che sono resistenti agli attacchi di forza bruta e alle Rainbow Tables grazie alla loro natura computazionalmente intensiva e alla possibilità di configurare l’uso di risorse (CPU, memoria).\nEsercizio\nConsideriamo ora l’esercizio di Webgoat che riguarda la corrispondenza tra password e hash non salati. Dato il contesto educativo, l’esercizio mira a identificare quali password corrispondono a determinati hash. Tuttavia, senza un database di hash-precalcolati o senza conoscere l’algoritmo specifico utilizzato per generare gli hash, risolvere questo tipo di esercizio diventa un compito di forza bruta o di ricerca in database di hash noti.\nL’obiettivo dell’esercizio è dimostrare la vulnerabilità degli hash non salati e l’importanza di implementare pratiche di sicurezza avanzate, come l’utilizzo di hash salati e algoritmi di hashing sicuri.\nConclusione\nL’hashing gioca un ruolo cruciale nella sicurezza informatica, specialmente nella verifica dell’integrità dei dati e nella memorizzazione sicura delle password. Tuttavia, per garantire che l’hashing sia effettivamente sicuro, è essenziale adottare tecniche come l’uso di salt e algoritmi di hashing resistenti a collisioni e attacchi pre-immagine. Implementare queste pratiche migliora significativamente la sicurezza delle applicazioni web e protegge le informazioni sensibili degli utenti.\nContinuiamo la nostra dispensa sulla crittografia in WebGoat esplorando la crittografia simmetrica e asimmetrica, due concetti fondamentali per la sicurezza delle comunicazioni digitali.\nCrittografia\nCrittografia Simmetrica\nLa crittografia simmetrica si basa su un segreto condiviso utilizzato sia per la cifratura che per la decifratura dei dati. Ciò significa che entrambe le parti coinvolte nello scambio di informazioni segrete condividono la stessa chiave. Questo metodo di crittografia è efficiente e relativamente semplice da implementare per dati di grandi dimensioni, grazie alla minor complessità computazionale rispetto alla crittografia asimmetrica. Tuttavia, la sua principale sfida riguarda la sicura distribuzione della chiave simmetrica alle parti interessate.\nProtocolli di Esempio\n\n\nAES (Advanced Encryption Standard): È uno degli algoritmi di crittografia simmetrica più utilizzati e sicuri, adottato come standard dal governo degli Stati Uniti e in tutto il mondo per la protezione delle informazioni sensibili.\n\n\n3DES (Triple Data Encryption Standard): Anche se meno utilizzato rispetto ad AES a causa della sua minore efficienza e sicurezza, 3DES offre comunque un livello di sicurezza accettabile per alcune applicazioni.\n\n\nCrittografia Asimmetrica\nLa crittografia asimmetrica si basa su principi matematici che prevedono l’uso di una coppia di chiavi: una privata e una pubblica. La chiave privata deve essere protetta con estrema cura ed è conosciuta solo dalla parte che la detiene, mentre la chiave pubblica può essere liberamente distribuita. Ciò che è cifrato con la chiave privata può essere decifrato da chiunque abbia la chiave pubblica corrispondente, e viceversa.\nLe due chiavi sono matematicamente correlate ma non è fattibile dedurre la chiave privata avendo solo la chiave pubblica. Questo sistema consente di cifrare e decifrare messaggi, nonché di firmare digitalmente e verificare messaggi, garantendo sicurezza, autenticità e integrità dei dati.\nFunzionamento della Crittografia Asimmetrica\n\nGenerazione delle Chiavi: L’utente genera una coppia di chiavi. La chiave pubblica può essere liberamente distribuita, mentre la chiave privata deve rimanere segreta.\nCifratura: Per inviare un messaggio sicuro, il mittente cifra i dati utilizzando la chiave pubblica del destinatario. Una volta cifrato con la chiave pubblica, il messaggio può essere decifrato solo con la corrispondente chiave privata, garantendo che solo il destinatario possa leggerlo.\nDecifratura: Il destinatario utilizza la propria chiave privata per decifrare il messaggio.\n\nEsempio Pratico\nImmaginiamo che Alice voglia inviare un messaggio sicuro a Bob:\n\nGenerazione delle Chiavi: Bob genera una coppia di chiavi. Egli tiene segreta la sua chiave privata e condivide la sua chiave pubblica con Alice.\nCifratura del Messaggio: Alice vuole inviare il messaggio “Ciao Bob” in modo sicuro. Lei ottiene la chiave pubblica di Bob e utilizza questa chiave per cifrare il suo messaggio. Il messaggio cifrato apparirà come un insieme casuale di caratteri, incomprensibile per chiunque tranne che per Bob.\nInvio del Messaggio Cifrato: Alice invia il messaggio cifrato a Bob.\nDecifratura del Messaggio: Una volta ricevuto il messaggio cifrato, Bob utilizza la sua chiave privata per decifrarlo. Con la sua chiave privata, Bob può convertire il messaggio cifrato nel suo formato originale, “Ciao Bob”.\n\nSicurezza e Applicazioni\nLa crittografia asimmetrica è fondamentale per varie applicazioni di sicurezza, inclusi i protocolli di comunicazione sicura come HTTPS, la firma digitale di documenti e software, e gli scambi chiave sicuri per la crittografia simmetrica.\nUno degli aspetti più interessanti della crittografia asimmetrica è la possibilità di creare una firma digitale. Per fare ciò, il mittente può cifrare il messaggio (o un suo hash) con la propria chiave privata. Chiunque con la chiave pubblica del mittente può decifrare il messaggio, verificando così che il messaggio provenga effettivamente dal mittente e non sia stato modificato durante il trasporto.\nLa forza della crittografia asimmetrica risiede nella difficoltà di risolvere certi problemi matematici, come la fattorizzazione di grandi numeri primi, che è alla base di algoritmi come RSA, o la difficoltà di calcolare logaritmi discreti per algoritmi come ECC (Elliptic Curve Cryptography).\nProtocolli di Esempio\n\n\nRSA (Rivest-Shamir-Adleman): Uno dei primi algoritmi di crittografia asimmetrica e ancora tra i più diffusi, utilizzato per la sicurezza delle comunicazioni su Internet.\n\n\nDSA (Digital Signature Algorithm): Utilizzato principalmente per le firme digitali, garantisce l’autenticità e l’integrità dei messaggi.\n\n\nHTTPS e l’Uso Combinato di Chiavi Simmetriche e Asimmetriche\nQuando apriamo un browser e visitiamo un sito HTTPS, ecco in breve cosa succede:\n\n\nConnessione e Certificato: Il browser si connette al server e ottiene il certificato del server web.\n\n\nVerifica del Certificato: Il browser controlla se si fida dell’emittente del certificato verificando se il certificato dell’emittente è presente nel suo archivio fiduciario, gestito dagli aggiornamenti del sistema operativo e del browser, e in alcuni network aziendali, dall’azienda stessa.\n\n\nGenerazione e Cifratura della Chiave Simmetrica: Il browser genera byte casuali per creare una chiave simmetrica e la cifra con la chiave pubblica del server, in modo che solo il server possa decifrarla.\n\n\nScambio della Chiave Simmetrica: Al termine di questo processo, sia il browser che il server web utilizzano la chiave simmetrica scambiata (nel processo di scambio di chiavi asimmetriche) per cifrare e decifrare i messaggi inviati tra il browser e il server.\n\n\nLe chiavi simmetriche sono preferite per la cifratura di grandi quantità di dati e richiedono meno potenza di elaborazione, rendendo il processo più efficiente. Tuttavia, le informazioni fornite qui offrono solo una comprensione di base della crittografia. Per informazioni più dettagliate su questi argomenti, è consigliato consultare risorse specializzate su Internet.\nFirme Digitali\nLe firme digitali sono un meccanismo crittografico che consente di verificare l’autenticità e l’integrità di un messaggio o documento digitale. Funzionano utilizzando una coppia di chiavi asimmetriche: una privata per firmare e una pubblica per verificare la firma.\nCreazione di una Firma Digitale\n\n\nGenerazione dell’Hash: Inizia creando un hash dei dati utilizzando un algoritmo sicuro come SHA-256. Questo hash funge da rappresentazione univoca dei dati.\n\n\nCifratura dell’Hash: Cifra l’hash generato con la tua chiave privata RSA. Questo processo “firma” l’hash, legandolo alla tua identità digitale (la chiave privata).\n\n\n(Opzionale) Encoding Base64: Se necessario, puoi codificare in Base64 l’hash cifrato per facilitarne la trasmissione o l’inserimento in documenti.\n\n\nVerifica di una Firma Digitale\nPer verificare una firma digitale, il destinatario o verificatore deve:\n\n\nCalcolare l’hash dei dati originali utilizzando lo stesso algoritmo hash usato per la firma.\n\n\nDecifrare la firma (l’hash cifrato) utilizzando la chiave pubblica corrispondente alla chiave privata usata per firmare.\n\n\nConfrontare i due hash. Se corrispondono, la firma è valida e i dati non sono stati alterati.\n\n\nesercizio: Estrazione del Modulo e Firma\nPer l’esercizio specifico di determinare il modulo di una chiave RSA come stringa esadecimale e firmare tale stringa, ecco i passaggi generali che dovresti seguire utilizzando OpenSSL o strumenti simili:\n\n\nEstrazione del Modulo: Utilizza OpenSSL per estrarre il modulo dalla chiave privata RSA. Il comando di OpenSSL per fare ciò potrebbe assomigliare a questo:\nopenssl rsa -in private_key.pem -noout -modulus\nQuesto comando restituirà il modulo della chiave come stringa esadecimale.\n\n\nFirma del Modulo: Dopo aver ottenuto il modulo, il passo successivo è firmarlo utilizzando la stessa chiave privata. Per fare ciò, potresti usare un comando come:\nopenssl dgst -sha256 -sign private_key.pem -out signature.bin modulo.txt\nDove modulo.txt contiene il modulo esadecimale che vuoi firmare.\n\n\n(Opzionale) Encoding Base64 della Firma: Se necessario, puoi codificare la firma in Base64 con:\nopenssl base64 -in signature.bin -out signature_base64.txt\n\n\nLa sezione della nostra dispensa sulla crittografia in WebGoat ora esplora il concetto di keystore e truststore, nonché la gestione delle chiavi crittografiche e dei certificati. Questi concetti sono fondamentali per comprendere come le applicazioni web gestiscono la sicurezza delle comunicazioni e l’identità digitale.\nKeystore e Truststore\nUn keystore è un repository di chiavi crittografiche (chiavi private e certificati di chiavi pubbliche) utilizzato per la sicurezza in applicazioni e piattaforme. Il termine truststore viene spesso usato intercambiabilmente con keystore, ma di solito si riferisce a un keystore che contiene solo certificati fidati, ovvero certificati pubblici e informazioni sugli emittenti di certificati.\nKeystore Basati su File\nUn keystore basato su file memorizza le chiavi su un file system. È molto comune memorizzare i certificati pubblici in un keystore basato su file, soprattutto per applicazioni che necessitano di stabilire connessioni sicure, come l’HTTPS.\nKeystore in Database\nLe chiavi, e soprattutto i certificati pubblici, possono ovviamente essere memorizzati anche in un database. Questo approccio può offrire vantaggi in termini di gestione centralizzata e scalabilità.\nKeystore Hardware\nUn keystore hardware contiene le chiavi crittografiche in un dispositivo hardware dedicato. Questo è tipico di ambienti di alta sicurezza, dove è fondamentale che la chiave privata rimanga effettivamente privata. A differenza dei keystore basati su file o su database, è impossibile fare una copia del keystore per inviarla a un ambiente sconosciuto e non fidato.\nKeystore Gestiti in Sistemi Operativi, Browser e Altre Applicazioni\nQuando visiti un sito web e il browser indica che i certificati sono validi, significa che il certificato utilizzato per il sito web è stato emesso da un’autorità di certificazione fidata. La lista di queste autorità di certificazione è gestita e aggiornata regolarmente tramite aggiornamenti del browser, del sistema operativo e della Java Runtime Environment (JRE), che mantiene la propria lista nel file cacerts.\nControllo Extra dei Certificati dei Siti Web tramite Record DNS CAA\nPer prevenire connessioni di tipo man-in-the-middle, i browser moderni verificano anche i record DNS CAA per vedere se un certo emittente è autorizzato per un determinato sito web. Questo meccanismo aggiunge un ulteriore livello di verifica sull’autenticità e la legittimità dei certificati.\nCertificati Gratuiti da Let’s Encrypt\nLet’s Encrypt è un’autorità di certificazione gratuita, automatizzata e aperta che consente di creare certificati validi per i siti web controllati dagli utenti. Questo servizio stimola l’uso di certificati autorizzati e mira a ridurre l’uso di certificati auto-firmati su Internet. I certificati hanno una validità di 90 giorni e devono quindi essere rinnovati automaticamente, garantendo così che la prova di identità/proprietà avvenga frequentemente.\nConclusione\nLa gestione sicura delle chiavi crittografiche e dei certificati è essenziale per la protezione delle comunicazioni digitali e l’identità su Internet. Capire come funzionano keystore e truststore, insieme alla conoscenza di come le applicazioni e i browser gestiscono i certificati, è cruciale per gli sviluppatori di applicazioni web e per chiunque sia interessato alla sicurezza informatica. Questa conoscenza aiuta a garantire che le informazioni sensibili rimangano protette e che le comunicazioni digitali siano autentiche e sicure.\nContinuiamo la nostra dispensa sulla crittografia e la sicurezza in WebGoat, affrontando ora l’importanza di evitare configurazioni predefinite e l’uso sicuro delle chiavi e dei certificati.\nUso delle Configurazioni Predefinite\nUn problema significativo in molti sistemi è l’utilizzo di configurazioni predefinite, come username e password di default nei router, password predefinite per i keystores, modalità non cifrate di default, ecc. Queste configurazioni possono aprire la porta a vulnerabilità e attacchi informatici.\nJava cacerts\nHai mai cambiato la password del file cacerts di Java? Mettere una password su questo file ha delle implicazioni importanti, specialmente quando è necessario proteggere le autorità di certificazione fidate e impedire l’aggiunta troppo facile di certificati auto-firmati sconosciuti.\nProtezione della Chiave Privata id_rsa\nSe usi una chiave SSH per GitHub o altri siti, la lasci non cifrata sul tuo disco o persino sul tuo cloud drive? Per impostazione predefinita, la generazione di una coppia di chiavi SSH lascia la chiave privata non cifrata, il che la rende facile da usare. Tuttavia, è meglio cifrare la chiave per una maggiore sicurezza.\nUsername e Password SSH al Tuo Server\nQuando ottieni un server virtuale da un provider di hosting, ci sono di solito molte configurazioni predefinite non sicure. Una di queste è l’esecuzione di SSH sulla porta predefinita 22, che permette tentativi di accesso con username e password. Una delle prime cose da fare è modificare la configurazione per impedire l’accesso SSH come utente root e consentire l’accesso solo con una chiave SSH valida e sicura.\nesercizio\nQuesto esercizio illustra l’importanza di non lasciare segreti inaccessibili all’interno di immagini di container Docker. Recuperare il segreto e decifrare il messaggio sottolinea la necessità di pratiche sicure nella gestione delle chiavi e dei certificati.\nConclusione\nLa sicurezza delle configurazioni, la protezione delle chiavi private e la gestione attenta dei certificati sono aspetti fondamentali per mantenere sicure le applicazioni e i sistemi informatici. Evitare l’uso di impostazioni predefinite e adottare misure di sicurezza robuste può significativamente ridurre il rischio di violazioni e attacchi informatici. In WebGoat e in altri contesti di sicurezza informatica, comprendere e implementare queste pratiche è essenziale per sviluppatori, amministratori di sistema e professionisti della sicurezza IT.\nLa crittografia post-quantistica rappresenta un campo di ricerca fondamentale nell’era dell’informatica quantistica. I computer quantistici, grazie alla loro capacità di eseguire calcoli in modi che i computer classici non possono, pongono una minaccia significativa alla sicurezza delle attuali tecniche crittografiche. In particolare, algoritmi come RSA, ECC (Elliptic Curve Cryptography) e DH (Diffie-Hellman), largamente diffusi per la sicurezza delle comunicazioni digitali, potrebbero essere vulnerabili agli attacchi da parte di computer quantistici potenti.\nEra post quantistica\nImpatto dei Computer Quantistici\nI computer quantistici sfruttano principi della meccanica quantistica, come la sovrapposizione e l’intreccio, per processare informazioni in modi radicalmente nuovi. Questo li rende particolarmente efficaci nel risolvere problemi specifici, come la fattorizzazione di grandi numeri e la ricerca nel logaritmo discreto, che sono alla base della sicurezza di molti sistemi crittografici attuali.\nCrittografia Post-Quantistica\nLa crittografia post-quantistica si riferisce a tecniche crittografiche resistenti agli attacchi dei computer quantistici. Queste tecniche sono basate su problemi matematici ritenuti difficili da risolvere anche per i computer quantistici. L’obiettivo è garantire che le comunicazioni e i dati rimangano sicuri anche nell’era quantistica.\nTecniche Post-Quantistiche\nAlcuni degli approcci post-quantistici in esame includono:\n\n\nReticoli crittografici: Basati su problemi matematici derivanti dalla teoria dei reticoli che, al momento, non hanno soluzioni efficienti neanche su computer quantistici.\n\n\nCriptografia basata su codici: Sfrutta la difficoltà di decodificare certi tipi di codici correttori di errori.\n\n\nCrittosistemi multivariati: Basati sulla difficoltà di risolvere sistemi di equazioni polinomiali multivariate.\n\n\nHash-based cryptography: Utilizza funzioni hash per costruire sistemi crittografici, inclusi schemi di firma digitale resistenti agli attacchi quantistici.\n\n\nImplementazione\nNonostante la crittografia post-quantistica sia ancora in fase di ricerca e standardizzazione (con organismi come NIST che conducono il processo di standardizzazione), è importante iniziare a considerare l’integrazione di queste tecniche nelle infrastrutture IT esistenti. Questo permetterà di garantire una transizione fluida e sicura verso sistemi resistenti agli attacchi quantistici.\nConclusione\nLa minaccia rappresentata dai computer quantistici alla crittografia tradizionale è reale e imminente. Sebbene la tecnologia quantistica sia ancora in fase di sviluppo, il rischio che le informazioni cifrate oggi possano essere decifrate in futuro rende urgente l’adozione di tecniche crittografiche post-quantistiche. Prepararsi ora, adottando nuovi standard crittografici e valutando la sicurezza delle informazioni a lungo termine, è essenziale per proteggere la privacy e la sicurezza delle informazioni nell’era post-quantistica."},"Argomenti/Cybersecurity-e-Ethical-hacking/Cookie-Spoofing":{"slug":"Argomenti/Cybersecurity-e-Ethical-hacking/Cookie-Spoofing","filePath":"Argomenti/Cybersecurity e Ethical hacking/Cookie Spoofing.md","title":"Cookie Spoofing","links":[],"tags":[],"content":"Autenticazione tramite Cookie: Sicurezza e Meccanismi di Protezione\nDefinizione e Funzionamento\nI cookie di autenticazione sono strumenti utilizzati dai servizi che richiedono l’autenticazione degli utenti. Quando un utente accede a un’applicazione o sito web inserendo le proprie credenziali (nome utente e password), il server verifica tali credenziali. Se risultano valide, viene creata una sessione per quell’utente.\nOgni sessione viene identificata da un ID univoco di sessione. Questo ID viene inviato al client (tipicamente un browser) attraverso l’header HTTP Set-Cookie, che contiene il nome del cookie e il suo valore (cioè l’ID della sessione o un token di autenticazione crittograficamente sicuro). Il cookie viene quindi memorizzato lato client ed è incluso automaticamente nelle richieste successive al server.\nMemorizzazione e Rischi di Sicurezza\nIl cookie viene memorizzato sia lato client che lato server:\n\n\nLato client: il cookie viene salvato nel browser. In questo caso, può essere vulnerabile a:\n\n\nAttacchi Man-in-the-Middle (MitM), se la comunicazione non avviene tramite HTTPS.\n\n\nAttacchi Cross-Site Scripting (XSS), se un sito è vulnerabile e consente l’iniezione di codice JavaScript.\n\n\n\n\nLato server: spesso è associato a una struttura di dati che tiene traccia dello stato della sessione, oppure è validato tramite meccanismi stateless, come i JSON Web Token (JWT).\n\n\nAutenticazione Basata su Cookie\nUna volta in possesso di un cookie di autenticazione valido, un client può essere autenticato automaticamente dal server, senza dover ripetere l’inserimento delle credenziali. Questa caratteristica rende il cookie un elemento critico per la sicurezza del sistema di autenticazione.\nObiettivi di Sicurezza\nL’obiettivo primario è impedire che un utente malintenzionato possa indovinare o riprodurre il valore di un cookie valido, e quindi accedere come un altro utente. Ciò implica che l’algoritmo di generazione del cookie debba essere robusto e non prevedibile.\nRischi e Vettori di Attacco\n\n\nPrevedibilità dell’algoritmo: Se l’algoritmo di generazione dei cookie è semplice o utilizza una fonte di casualità debole, un attaccante potrebbe riuscire a predire o riprodurre un valore valido.\n\n\nFurto del cookie:\n\n\nTramite XSS: se un sito consente l’iniezione di script, un attaccante può leggere i cookie con document.cookie.\n\n\nTramite intercettazione del traffico: se non si usa HTTPS, i cookie possono essere intercettati in chiaro.\n\n\n\n\nMisure di Mitigazione\n\n\nAlgoritmi crittograficamente sicuri:\n\n\nUtilizzare generatori di numeri casuali crittograficamente sicuri (es. SecureRandom in Java, crypto.randomBytes in Node.js).\n\n\nUtilizzare meccanismi di firma o cifratura dei cookie, ad esempio mediante HMAC o JWT firmati.\n\n\n\n\nImpostazioni di sicurezza dei cookie:\n\n\nSecure: il cookie viene inviato solo su connessioni HTTPS.\n\n\nHttpOnly: il cookie non è accessibile tramite JavaScript lato client.\n\n\nSameSite: riduce il rischio di attacchi CSRF.\n\n\n\n\nScadenza e rotazione dei cookie:\n\n\nImpostare una durata limitata della sessione (timeout).\n\n\nRigenerare il cookie dopo eventi critici (es. autenticazione, cambio password).\n\n\nUtilizzare token di refresh per estendere in sicurezza una sessione.\n\n\n\n\nControlli lato server:\n\n\nValidare l’indirizzo IP o l’agente utente associato alla sessione.\n\n\nLimitare il numero di sessioni attive per utente.\n\n\n\n\nEsercizio webgoat\nProvando a fare il login si ottengono questi cookie di autenticazione:\nwebgoat webgoat -&gt; NjY2ZTQ0NmE3OTZhNDU1MTVhNDQ3NDYxNmY2NzYyNjU3Nw\nadmin admin -&gt; NjY2ZTQ0NmE3OTZhNDU1MTVhNDQ2ZTY5NmQ2NDYx\n\nDecodificando da base64 si ottiene:\n666e446a796a45515a4474616f67626577\n666e446a796a45515a446e696d6461\n\nChe convertito in ASCII diventa:\nfnDjyjEQZDnimda\nfnDjyjEQZDtaogbew\n\nCome si nota la radice è identica, mentre la seconda parte è il nome utente scritto al contrario. Sfruttando questa vulnerabilità possiamo entrare come l’utente tom invertendo il processo:\ntesto: fnDjyjEQZDmot\nascii hex: 666e446a796a45515a446d6f74\ntoken base64: NjY2ZTQ0NmE3OTZhNDU1MTVhNDQ2ZDZmNzQ\n\n"},"Argomenti/Cybersecurity-e-Ethical-hacking/Cross-Site-Scripting-(XSS)":{"slug":"Argomenti/Cybersecurity-e-Ethical-hacking/Cross-Site-Scripting-(XSS)","filePath":"Argomenti/Cybersecurity e Ethical hacking/Cross Site Scripting (XSS).md","title":"Cross Site Scripting (XSS)","links":[],"tags":[],"content":"Attacco\nCross-Site Scripting (XSS): Panoramica e Impatto\nIl Cross-Site Scripting, comunemente abbreviato in XSS, è un tipo di vulnerabilità di sicurezza tipicamente riscontrata nelle applicazioni web. Questo difetto permette agli aggressori di iniettare script dannosi all’interno di contenuti visualizzati da altri utenti. A differenza di altri attacchi web che mirano all’infrastruttura di un sito, l’XSS sfrutta la fiducia che un utente ripone in un determinato sito, rendendolo particolarmente pericoloso e diffuso.\nNatura delle Vulnerabilità XSS\nLa vulnerabilità XSS sorge quando un’applicazione include dati non affidabili in una nuova pagina web senza una valida convalida o escaping, o aggiorna una pagina web esistente con dati forniti dall’utente utilizzando un’API del browser che può creare HTML o JavaScript. L’XSS consente agli aggressori di eseguire script nel browser della vittima, che possono dirottare sessioni utente, deturpare siti web o reindirizzare l’utente verso siti malevoli.\nLa Prevalenza e il Significato dell’XSS\nNonostante sia ben compreso e prevenibile, l’XSS rimane il problema di sicurezza delle applicazioni web più diffuso. La sua persistenza può essere attribuita alla natura dinamica e complessa delle applicazioni web, che spesso non impiegano una valida convalida o sanitizzazione degli input. Le conseguenze degli attacchi XSS sono diventate più gravi con l’ascesa delle Rich Internet Applications (RIAs), dove funzioni privilegiate e dati sensibili diventano accessibili tramite JavaScript, rendendoli obiettivi primari per gli aggressori.\nEsempi di Attacchi XSS\n\n\nVettori di Attacco Base: Utilizzare la console JavaScript di un browser per eseguire script semplici come alert(&quot;Test XSS&quot;); o alert(document.cookie); mostra il meccanismo base dell’XSS. Questo può rivelare informazioni sensibili come i cookie di sessione.\n\n\nIniezione in Campi Dati: Iniettare un tag script, come &lt;script&gt;alert(&quot;Test XSS&quot;)&lt;/script&gt;, in un campo dati che viene poi renderizzato dal browser, dimostra un comune vettore di attacco in cui lo script dell’aggressore viene eseguito come se fosse parte dell’applicazione.\n\n\nSperimentare con l’XSS\nPer comprendere le implicazioni pratiche dell’XSS, si può condurre un semplice esperimento utilizzando browser web come Chrome o Firefox:\n\nAprire una seconda scheda nel browser e navigare verso la stessa URL della prima scheda o qualsiasi URL all’interno dello stesso dominio.\nAccedere alla console JavaScript all’interno degli strumenti per sviluppatori del browser.\nDigitare alert(document.cookie); per visualizzare i cookie per quel dominio.\nOsservare che i cookie visualizzati in entrambe le schede sono gli stessi, illustrando come un attacco XSS possa accedere e potenzialmente sfruttare le informazioni dei cookie attraverso le sessioni.\n\nLe Località Più Comuni per le Vulnerabilità XSS\nLe vulnerabilità Cross-Site Scripting (XSS) possono manifestarsi in diversi punti di un’applicazione web. Questi punti sono spesso associati all’input dell’utente e alla successiva visualizzazione di tale input nella pagina web. Di seguito sono riportate le località più comuni dove possono verificarsi vulnerabilità XSS:\nCampi di Ricerca\n\nCampi di ricerca che rimandano una stringa di ricerca all’utente: Quando un utente inserisce una query in un campo di ricerca e l’applicazione web visualizza quella query nella pagina dei risultati, senza una corretta sanitizzazione, un aggressore può inserire uno script maligno come parte della query di ricerca.\n\nCampi di Input\n\nCampi di input che fanno eco ai dati dell’utente: Qualsiasi campo di input che accetta dati dall’utente e li visualizza nuovamente nella pagina web può essere sfruttato per iniettare script dannosi.\n\nMessaggi di Errore\n\nMessaggi di errore che restituiscono testo fornito dall’utente: Se un’applicazione genera messaggi di errore che includono input forniti dall’utente, questi messaggi possono essere manipolati per eseguire script XSS.\n\nCampi Nascosti\n\nCampi nascosti che contengono dati forniti dall’utente: Anche se non visibili direttamente nell’interfaccia utente, i campi nascosti possono contenere dati vulnerabili all’iniezione di XSS se tali dati sono manipolati e poi eseguiti dal browser.\n\nPagine che Visualizzano Dati Forniti dall’Utente\n\nBacheche di messaggi: Le bacheche che consentono agli utenti di postare messaggi possono diventare veicoli per script XSS se i messaggi degli utenti non sono adeguatamente sanificati.\nCommenti in forma libera: Similmente, i sistemi di commenti che consentono input in forma libera senza restrizioni o sanificazioni adeguate possono facilmente essere sfruttati per attacchi XSS.\n\nIntestazioni HTTP\n\nIntestazioni HTTP: Anche se meno comune, le vulnerabilità XSS possono essere introdotte tramite dati utente manipolati che vengono inviati nelle intestazioni HTTP, come il campo “Referrer” o “User-Agent”, e poi riflessi nel contenuto della pagina web.\n\nPerché Dovremmo Preoccuparci degli Attacchi XSS?\nGli attacchi Cross-Site Scripting (XSS) rappresentano una minaccia significativa per la sicurezza delle applicazioni web e degli utenti che vi accedono. La gravità degli attacchi XSS deriva dalla loro capacità di compromettere l’integrità e la privacy sia degli utenti che delle organizzazioni. Di seguito, alcuni dei motivi principali per cui è essenziale prendere sul serio le vulnerabilità XSS:\nFurto di Cookie di Sessione\nGli attacchi XSS possono consentire agli aggressori di rubare i cookie di sessione degli utenti. Questo permette agli aggressori di impersonare le vittime, accedendo ai loro account senza richiedere username e password.\nCreazione di Richieste False\nGli aggressori possono utilizzare script XSS per creare richieste false da parte dell’utente, come se fossero richieste legittime. Ciò può portare a cambiamenti non autorizzati dei dati dell’utente o ad azioni indesiderate sul sito web.\nRaccolta di Credenziali tramite Campi Falsi\nMediante lo scripting XSS, gli aggressori possono inserire campi di input falsi nelle pagine web, ingannando gli utenti affinché inseriscano le proprie credenziali, che vengono poi catturate dagli aggressori.\nReindirizzamento a Siti Malevoli\nUn attacco XSS può reindirizzare gli utenti da una pagina legittima a un sito web malevolo o non amichevole, potenzialmente esponendo gli utenti a malware o tentativi di phishing.\nMascheramento di Richieste Come Utente Valido\nGli script XSS possono essere usati per creare richieste che appaiono come se fossero state effettuate da un utente valido, compromettendo l’integrità delle interazioni con l’applicazione.\nFurto di Informazioni Riservate\nGli attacchi XSS possono portare al furto di informazioni riservate o sensibili, esponendo sia gli utenti individuali che le organizzazioni a rischi di privacy e sicurezza.\nEsecuzione di Codice Dannoso\nLo scripting XSS consente l’esecuzione di codice malevolo sui sistemi degli utenti finali. Questo può includere lo scripting attivo che sfrutta le vulnerabilità dei browser o altri software.\nInserimento di Contenuti Ostili o Inappropriati\nGli attacchi XSS possono essere utilizzati per inserire contenuti ostili, inappropriati o persino diffamatori in una pagina web, danneggiando la reputazione di un’organizzazione e compromettendo l’esperienza dell’utente.\nLegittimazione degli Attacchi di Phishing\nGli attacchi XSS aggiungono un livello di legittimità agli attacchi di phishing, utilizzando domini validi nell’URL per mascherare intenti malevoli, rendendo più difficile per gli utenti riconoscere tentativi fraudolenti.\nTipi di Attacchi XSS\nGli attacchi Cross-Site Scripting (XSS) si classificano in tre categorie principali in base al modo in cui il codice maligno viene inserito e eseguito nella pagina web. Queste categorie sono: XSS Riflesso, XSS basato su DOM e XSS Memorizzato (o Persistente). La comprensione delle differenze tra questi tipi è fondamentale per implementare misure di sicurezza efficaci.\nXSS Riflesso\n\n\nDefinizione: L’XSS riflesso si verifica quando il contenuto malevolo, proveniente da una richiesta dell’utente, viene immediatamente riflesso dal server e visualizzato nell’interfaccia utente del browser web. Questo tipo di attacco richiede tipicamente che la vittima clicchi su un link malevolo.\n\n\nCaratteristiche:\n\nIl contenuto dannoso è incluso nella risposta del server a seguito di una richiesta dell’utente.\nRichiede l’ingegneria sociale per indurre la vittima a cliccare su un link o a inviare una richiesta contenente lo script malevolo.\nViene eseguito con i privilegi del browser ereditati dall’utente.\n\n\n\nXSS basato su DOM (Tecnicamente Riflesso)\n\n\nDefinizione: Il DOM-based XSS, o XSS basato sul Document Object Model, si verifica lato client quando gli script della pagina web manipolano i dati in ingresso dall’utente e scrivono o modificano il DOM della pagina con contenuti dannosi, senza un adeguato controllo o sanificazione da parte del server.\n\n\nCaratteristiche:\n\nGli script lato client utilizzano contenuti malevoli provenienti da una richiesta dell’utente per scrivere o modificare il HTML della pagina.\nFunziona in modo simile all’XSS riflesso, ma l’interazione avviene interamente sul lato client senza la necessità di una risposta malevola dal server.\nViene eseguito con i privilegi del browser ereditati dall’utente.\n\n\n\nXSS Memorizzato o Persistente\n\n\nDefinizione: L’XSS memorizzato si verifica quando il contenuto malevolo viene salvato su un server (ad esempio, in un database, sistema di file o altri oggetti) e successivamente visualizzato agli utenti in un browser web. A differenza dell’XSS riflesso, non richiede ingegneria sociale per essere sfruttato.\n\n\nCaratteristiche:\n\nIl contenuto dannoso è conservato sul server e mostrato automaticamente nelle pagine web agli utenti finali, senza richiedere azioni specifiche dalla vittima per attivare lo script malevolo.\nNon richiede l’ingegneria sociale per influenzare la vittima, rendendolo particolarmente insidioso.\nPuò avere un impatto significativo poiché il contenuto malevolo può essere visualizzato a molti utenti o in molteplici sessioni fino alla sua rimozione dal server.\n\n\n\nScenario di Attacco XSS Riflesso\nLo scenario di un attacco XSS riflesso illustra un percorso comune utilizzato dagli aggressori per compromettere i dati degli utenti e ottenere accesso non autorizzato alle informazioni sensibili. Questo tipo di attacco sfrutta la fiducia dell’utente in un sito web legittimo per eseguire codice malevolo attraverso un URL manipolato. Di seguito è descritto in dettaglio uno scenario tipico di attacco XSS riflesso:\n1. Creazione dell’URL Malevolo\n\nAzione dell’Aggressore: L’aggressore crea un URL che incorpora uno script malevolo. Questo URL è progettato per essere inviato a un sito web legittimo, ma con l’intento di riflettere lo script inserito nell’URL stesso sulla pagina web visitata dall’utente.\n\n2. Invio dell’URL alla Vittima\n\nDiffusione: L’aggressore invia l’URL malevolo alla vittima. Questo può avvenire tramite email, messaggi, forum o attraverso qualsiasi mezzo che permetta alla vittima di cliccare sul link. L’ingegneria sociale gioca un ruolo chiave in questa fase, poiché l’aggressore deve convincere la vittima a cliccare sul link.\n\n3. Vittima Clicca sul Link\n\nInterazione della Vittima: La vittima, convinta della legittimità del link, clicca sull’URL. Il link conduce la vittima a visitare una pagina web legittima, ma l’URL contiene lo script malevolo progettato per essere eseguito.\n\n4. Esecuzione dello Script Malevolo\n\nAttacco: Una volta che la pagina web viene caricata nel browser della vittima, lo script malevolo incorporato nell’URL viene eseguito. Operando con i privilegi del browser della vittima, lo script ha la capacità di eseguire varie azioni dannose, come:\n\nRubare informazioni sensibili, ad esempio l’ID di sessione dell’utente.\nCatturare input dell’utente o modificare il contenuto visualizzato nella pagina.\nInviare i dati rubati all’aggressore tramite richieste web a server controllati dall’aggressore.\n\n\n\n5. La Vittima Rimane Ignara dell’Attacco\n\nConseguenze: La particolarità e la pericolosità dell’XSS riflesso risiede nel fatto che l’utente potrebbe non rendersi conto che un attacco è avvenuto. Poiché lo script viene eseguito all’interno del contesto di una pagina web legittima, le sue azioni malevole possono passare inosservate.\n\nPer comprendere come testare una possibile vulnerabilità XSS riflesso, esamineremo un esperimento controllato che illustra come identificare un campo suscettibile a tale attacco. È importante sottolineare che questo tipo di test dovrebbe essere eseguito solo in ambienti sicuri e autorizzati, mai su siti web reali senza il permesso esplicito dei proprietari del sito. L’esempio seguente è puramente ipotetico e intende fornire una comprensione di base di come si possa procedere.\nScenario: Carrello della Spesa\nImmaginiamo di avere una pagina web che rappresenta un carrello della spesa con vari articoli elencati. Alla fine della pagina, viene chiesto di inserire il numero della carta di credito e un codice di accesso a tre cifre per procedere all’acquisto.\nObiettivo\nL’obiettivo è identificare se uno dei campi per l’input dell’utente (ad esempio, il numero della carta di credito o il codice di accesso a tre cifre) è vulnerabile ad attacchi XSS riflessi.\nProcedimento\n\n\nPreparazione dell’URL con Script Malevolo: Creare un URL che simuli l’invio di input malevolo a uno dei campi del carrello. Questo potrebbe essere fatto aggiungendo un parametro all’URL che contenga uno script, ad esempio:\nexample.com/cart(&#039;XSS&#039;)&lt;/script&gt;\n\nOppure, se il sito utilizza metodi POST per inviare i dati, potresti aver bisogno di utilizzare strumenti di sviluppo del browser per modificare i dati inviati e includere lo script.\n\n\nTest con alert() o console.log(): L’uso della funzione alert() o console.log() nello script inserito è un modo diretto per identificare se lo script viene eseguito. Se dopo l’invio dell’input malevolo, vedi apparire un pop-up di alert o un messaggio nella console del browser, il campo è vulnerabile.\n\nEsempio di Alert: &lt;script&gt;alert(&#039;Test XSS&#039;)&lt;/script&gt;\nEsempio di Console.log: &lt;script&gt;console.log(&#039;Test XSS&#039;)&lt;/script&gt;\n\n\n\nAnalisi dei Risultati: Se l’alert appare o il messaggio viene stampato nella console, significa che il campo di input non sta adeguatamente sanificando l’input dell’utente, rendendolo vulnerabile ad attacchi XSS.\n\n\nIl concetto di “Self XSS” si riferisce a una forma di attacco Cross-Site Scripting (XSS) in cui lo script malevolo viene eseguito a causa dell’azione diretta dell’utente che utilizza il proprio browser, piuttosto che essere ingannato o indotto a eseguire lo script tramite un link o un contenuto fornito da un aggressore. Questo tipo di attacco sfrutta l’interazione diretta dell’utente con il browser, facendo leva su tecniche di ingegneria sociale o sulla mancanza di consapevolezza dell’utente riguardo alla sicurezza.\nPerché è Considerato “Self XSS”?\nNel contesto fornito, l’esecuzione dello script tramite l’URL diretto, come:\n/WebGoat/CrossSiteScripting/attack5a?QTY1=1&amp;QTY2=1&amp;QTY3=1&amp;QTY4=1&amp;field1=&lt;script&gt;alert(&#039;my%20javascript%20here&#039;)&lt;/script&gt;4128+3214+0002+1999&amp;field2=111\n\nè considerata “Self XSS” perché l’azione non è scatenata da un link preparato da un aggressore o da una fonte esterna, ma piuttosto dall’inserimento diretto e volontario dell’URL con lo script da parte dell’utente nel proprio browser. In questo caso, l’utente sta essenzialmente “auto-infliggendosi” l’attacco XSS.\nCaratteristiche del Self XSS\n\nAzioni dell’Utente: L’utente esegue azioni dirette che attivano lo script XSS, come inserire un URL manipolato o eseguire script nella console del browser.\nMancanza di Inganno: A differenza degli attacchi XSS tradizionali, dove l’aggressore inganna l’utente per eseguire lo script malevolo, nel Self XSS, l’utente compie consapevolmente l’azione.\nLimitato a Auto-Compromissione: L’efficacia di questo tipo di attacco si limita all’auto-compromissione; non può essere utilizzato direttamente per compromettere altri utenti senza un elemento di ingegneria sociale che induca gli utenti a eseguire lo script da sé.\n\nRischi Associati al Self XSS\nSebbene il Self XSS possa sembrare meno pericoloso rispetto ad altre forme di XSS, può essere sfruttato in attacchi di ingegneria sociale dove gli aggressori ingannano le vittime affinché eseguano manualmente script malevoli, ad esempio, convincendole a inserire script dannosi nella console del browser con la promessa di sbloccare funzionalità nascoste o ottenere benefici.\nGli attacchi XSS basati su DOM e gli attacchi XSS Riflessi rappresentano due modalità attraverso cui gli aggressori possono eseguire script malevoli nel browser di una vittima. Sebbene condividano alcuni aspetti, differiscono significativamente nel flusso di esecuzione e nella modalità di sfruttamento della vulnerabilità.\nXSS Riflesso\n\n\nFlusso di Esecuzione: Nell’XSS riflesso, lo script malevolo è incluso nell’URL che l’aggressore invia alla vittima. Quando la vittima clicca sul link, la richiesta viene inviata al server, che poi riflette l’input malevolo nella risposta HTML. Di conseguenza, lo script viene eseguito nel contesto del sito web visitato.\n\n\nCaratteristiche Principali:\n\nRichiede ingegneria sociale per indurre la vittima a cliccare sul link.\nIl payload (il codice malevolo) viene elaborato dal server e poi eseguito dal browser della vittima.\nUtilizzato spesso per rubare informazioni, come i cookie di sessione, o per eseguire azioni malevole rappresentando la vittima.\n\n\n\nXSS basato su DOM\n\n\nFlusso di Esecuzione: Nell’XSS basato su DOM, il payload malevolo non viene inviato al server. Invece, è interamente elaborato e eseguito lato client (nel browser della vittima) attraverso la manipolazione del DOM della pagina web. Questo tipo di attacco sfrutta le vulnerabilità presenti nel codice JavaScript o nelle funzioni che manipolano il DOM senza adeguata sanificazione.\n\n\nCaratteristiche Principali:\n\nNon richiede che il payload passi attraverso il server; l’attacco avviene interamente sul lato client.\nPuò essere scatenato da una varietà di fonti, inclusi link, che manipolano il DOM della pagina.\nSpesso più difficile da rilevare e prevenire perché il codice malevolo non passa attraverso il server.\n\n\n\nScenario di Attacco\n\nInvio dell’URL Malevolo: L’aggressore confeziona un URL che include il payload XSS e lo invia alla vittima.\nClic sulla Vittima: La vittima clicca sul link, che carica una pagina web vulnerabile.\nEsecuzione dello Script:\n\nNel caso dell’XSS riflesso, il server restituisce una pagina che include ed esegue lo script malevolo.\nPer l’XSS basato su DOM, il payload modifica il DOM della pagina direttamente nel browser, eseguendo lo script senza che il codice passi dal server.\n\n\n\nConsiderazioni sulla Sicurezza\n\nRilevamento e Prevenzione: Mentre le tecniche tradizionali di sanificazione lato server possono essere efficaci contro l’XSS riflesso, l’XSS basato su DOM richiede un’attenzione particolare alla sanificazione e alla validazione dei dati lato client, oltre all’uso di Content Security Policy (CSP) per limitare le fonti di script eseguibili.\nConsapevolezza degli Utenti: Gli utenti devono essere educati sull’importanza di non cliccare su link sospetti e di mantenere aggiornati i loro browser per beneficiare delle ultime misure di sicurezza.\nIdentificare il potenziale per attacchi XSS basati su DOM richiede una comprensione di come le applicazioni web manipolano il Document Object Model (DOM) e gestiscono i dati forniti dall’utente. In questo contesto, l’esame del codice lato client, specialmente la configurazione delle route e i gestori degli eventi, è cruciale. Vediamo come approcciare questa indagine con un esempio generico, dato che non posso interagire direttamente con il codice sorgente o esaminare applicazioni specifiche.\n\nPassaggi per Identificare XSS basato su DOM\n\n\nEsaminare il Codice Client: Inizia esaminando il codice JavaScript lato client dell’applicazione. Se l’applicazione utilizza librerie o framework come Backbone, Angular, React, o Vue, presta particolare attenzione alla definizione delle route e ai gestori degli eventi associati.\n\n\nIdentificare la Configurazione delle Route: Cerca le configurazioni delle route all’interno del codice. Le route determinano quali gestori vengono chiamati quando l’URL cambia. Ad esempio, con Backbone, potresti cercare istanze di Backbone.Router.\n\n\nRicerca di Input Riflessi: Identifica le route che accettano input dall’URL e poi “riflettono” questi input direttamente sulla pagina, senza adeguata sanificazione. Questo può includere qualsiasi cosa, dall’inserimento diretto di testo nell’HTML a modifiche del DOM basate su valori di parametro.\n\n\nEsaminare i Gestori di Route per Codice di Test: Spesso, durante lo sviluppo, il codice di test viene inserito per verificare la funzionalità. Questo codice di test può essere dimenticato e lasciato nel codice in produzione. Se questo codice gestisce male gli input, può presentare una vulnerabilità.\n\n\nEsempio Pratico\nDato il contesto ipotetico di un’applicazione che utilizza start.mvc#lesson/ come base route, potresti trovare una configurazione simile per il codice di test:\nvar AppRouter = Backbone.Router.extend({\n    routes: {\n        &quot;test/:param&quot;: &quot;testRouteHandler&quot; // Esempio di configurazione di route vulnerabile\n    },\n \n    testRouteHandler: function(param) {\n        // Un semplice esempio di gestore che riflette direttamente l&#039;input nell&#039;HTML\n        document.getElementById(&#039;someElement&#039;).innerHTML = param;\n    }\n});\nIn questo esempio, test/:param è una route che potrebbe essere vulnerabile a XSS basato su DOM se l’input non viene sanificato prima di essere inserito nel DOM.\nCome Sfruttare la Vulnerabilità\nPer sfruttare una vulnerabilità come questa, un aggressore potrebbe creare un URL che inserisce uno script nel parametro param, come segue:\nexample.com/start.mvc#test/&lt;script&gt;alert(&#039;XSS&#039;)&lt;/script&gt;\n\nOvviamente lo script va inserito nell’URL con l’encoding corretto.\nQuando un utente visita questo URL, il codicscript&gt;alert(“ciao”)e JavaScript iniettato viene eseguito, dimostrando la vulnerabilità a XSS basato su DOM.\nStored Cross-Site Scripting (XSS) Memorizzato\nLo XSS memorizzato, noto anche come XSS persistente, rappresenta una forma particolarmente insidiosa di attacchi XSS. A differenza dello XSS riflesso o basato su DOM, in cui lo script malevolo viene passato tramite un link e si basa sull’interazione immediata dell’utente per essere eseguito, lo XSS memorizzato salva il payload malevolo direttamente sul server. Questo approccio consente allo script di persistere nel tempo e di essere eseguito ogni volta che un utente accede alla parte vulnerabile dell’applicazione web.\nScenario di Attacco XSS Memorizzato\nLo scenario tipico di un attacco XSS memorizzato si svolge nei seguenti passaggi:\n\n\nPubblicazione dello Script Malevolo: L’aggressore inserisce uno script malevolo in un input dell’applicazione web che accetta e memorizza dati, come un forum di messaggi, un campo di commento o un profilo utente.\n\n\nMemorizzazione nel Database del Server: Lo script inserito viene salvato nel database del server senza adeguata sanificazione o validazione. Questo permette allo script di persistere all’interno del sistema.\n\n\nLettura del Messaggio da Parte della Vittima: Quando un’altra utenza (la vittima) accede alla parte dell’applicazione che visualizza i dati memorizzati (ad esempio, leggendo un messaggio sul forum), lo script malevolo viene eseguito nel suo browser.\n\n\nEsecuzione dello Script e Furto di Informazioni: Lo script eseguito può compiere una varietà di azioni dannose, come il furto di informazioni sensibili (ad esempio, session ID o dati personali), l’esecuzione di azioni nel contesto dell’utente senza il suo consenso o il reindirizzamento a siti malevoli.\n\n\nL’Inconsapevolezza della Vittima: Tipicamente, la vittima non si rende conto che un attacco è avvenuto, poiché lo script viene eseguito in modo trasparente durante la visualizzazione del contenuto legittimo dell’applicazione.\n\n\nImpatto degli Attacchi XSS Memorizzati\nGli attacchi XSS memorizzati sono particolarmente pericolosi per diversi motivi:\n\nAmpio Raggio di Azione: Una volta che lo script malevolo è memorizzato sul server, può potenzialmente influenzare tutti gli utenti che accedono alla parte vulnerabile dell’applicazione.\nDurata: Lo script può rimanere memorizzato per un lungo periodo, continuando a compromettere gli utenti fino alla sua identificazione e rimozione.\nDifficoltà di Rilevamento: Spesso è difficile per gli amministratori del sistema rilevare la presenza di script malevoli memorizzati, soprattutto se non sono state implementate adeguate misure di sicurezza.\n\nConclusioni\nConcludendo, gli attacchi XSS basati su DOM rappresentano una minaccia significativa alla sicurezza delle applicazioni web moderne. Sfruttando le vulnerabilità nel codice JavaScript che manipola il Document Object Model (DOM) senza adeguata sanificazione dell’input, gli aggressori possono eseguire script malevoli nel browser degli utenti. Questo tipo di attacco illustra l’importanza critica della sicurezza lato client e sottolinea la necessità per gli sviluppatori di essere meticolosi nella gestione degli input dell’utente e nella manipolazione del DOM.\nL’esperimento ipotetico di tentare un attacco XSS basato su DOM attraverso l’uso di un URL modificato per riflettere un parametro e eseguire una funzione interna dimostra sia la potenziale vulnerabilità delle applicazioni web sia l’astuzia richiesta per sfruttare tali vulnerabilità. Questo tipo di attacco, che non necessita che il payload passi attraverso il server, ma avviene interamente sul lato client, rende evidente la complessità della sicurezza web e la necessità di approcci di difesa multi-strato.\nInoltre, il contesto “self XSS” e il concetto di XSS riflesso rivelano come la manipolazione diretta dell’URL o la convinzione della vittima a eseguire azioni specifiche possano portare a compromissioni di sicurezza significative. La discrezione con cui questi attacchi possono essere portati a termine, spesso senza che la vittima si renda conto di essere stata compromessa, sottolinea l’importanza per gli utenti di rimanere vigili e per gli sviluppatori di costruire applicazioni resilienti.\nInfine, mentre esplorare e comprendere le vulnerabilità XSS e le tecniche per sfruttarle può essere un’attività formativa utile per migliorare la sicurezza delle applicazioni, è fondamentale che tali esplorazioni avvengano in contesti legali e etici, come ambienti di test autorizzati o piattaforme educative come WebGoat. La consapevolezza e l’educazione sulla sicurezza informatica sono fondamentali per costruire un futuro digitale più sicuro per tutti.\nLa prevenzione degli attacchi XSS memorizzati richiede una combinazione di sanificazione rigorosa dell’input, politiche di Content Security Policy (CSP), e l’adozione di pratiche di sviluppo sicuro per evitare che input malevoli siano salvati e poi eseguiti dal server. Educare gli sviluppatori sull’importanza della sicurezza dell’applicazione e implementare controlli di sicurezza robusti sono passaggi fondamentali per proteggere gli utenti da queste vulnerabilità pervasive e dannose.\nMitigation contro XSS (Cross-Site Scripting)\nLa difesa contro gli attacchi di tipo Cross-Site Scripting (XSS) rappresenta una componente cruciale della sicurezza informatica nelle applicazioni web. Questi attacchi permettono agli aggressori di inserire script maligni nelle pagine visualizzate dagli altri utenti, potenzialmente compromettendo la sicurezza dell’utente e ottenendo accesso non autorizzato a informazioni sensibili. Di seguito sono illustrate le pratiche fondamentali per difendersi da tali attacchi.\nPerché è importante difendersi da XSS\nLa difesa contro gli attacchi XSS è essenziale per proteggere sia gli utenti che le applicazioni web dall’esecuzione di codice maligno nel contesto di sessioni utente autenticate. Un attacco XSS riuscito può consentire a un aggressore di rubare token di sessione, credenziali di accesso, e di manipolare i contenuti visualizzati all’utente, compromettendo l’integrità e la confidenzialità dei dati.\nCosa codificare\nIl principio base nella difesa contro XSS consiste nella codifica in output di ogni input non fidato visualizzato a schermo. Questo approccio, sebbene possa sembrare semplice, rimane la miglior difesa contro gli attacchi XSS. È fondamentale trattare ogni input come non fidato, anche i dati inseriti nel proprio database, poiché potrebbero essere stati compromessi o alterati da sistemi esterni.\nQuando e Dove Codificare\nÈ consigliabile codificare i dati non fidati nel momento in cui vengono inviati al browser, evitando di codificarli direttamente nei dati persistenti. Nel contesto delle applicazioni web single-page (SPA), la codifica deve avvenire lato client. È importante consultare la documentazione specifica del framework o della libreria utilizzata per implementare correttamente questa difesa.\nCome Codificare\n\nNel corpo HTML: Utilizzare la codifica delle entità HTML per qualsiasi input visualizzato nel corpo della pagina.\nNegli attributi HTML: Similmente, codificare come entità HTML gli input che vengono inseriti come valore degli attributi HTML.\nNel codice JavaScript: Nel caso in cui l’input dell’utente sia incluso in codice JavaScript, è necessario codificarlo in modo appropriato. Tuttavia, è fondamentale riflettere sulla necessità di includere input utente in script eseguibili all’interno della pagina, data l’alta potenziale esposizione a rischi di sicurezza.\n\nÈ importante evitare approcci basati su liste nere o filtri negativi, come tentare di bloccare esplicitamente stringhe come &lt;script&gt;, poiché gli aggressori possono facilmente eludere tali misure utilizzando tecniche di codifica o sfruttando vulnerabilità non considerate dal filtro.\nRisorse consigliate\nSebbene in questa sezione non siano elencate risorse specifiche, è altamente consigliabile consultare la documentazione ufficiale dei framework e delle librerie utilizzate, oltre a guide e best practices fornite da enti di standardizzazione e sicurezza informatica come OWASP (Open Web Application Security Project), che offre ampie risorse, guide e strumenti per la difesa da attacchi XSS e altre vulnerabilità web.\nRicordare sempre che la sicurezza è un processo in continua evoluzione: rimanere aggiornati sulle ultime minacce e sulle tecniche di difesa è fondamentale per mantenere le applicazioni e i dati degli utenti sicuri.\nCodifica e Escaping dei Dati\nLa codifica e l’escaping dei dati sono tecniche fondamentali nella prevenzione degli attacchi di Cross-Site Scripting (XSS) e nella sicurezza delle applicazioni web in generale. Questi metodi proteggono le applicazioni e i loro utenti dall’esecuzione di script maligni inseriti da attori esterni.\nCosa Significa Non Fidarsi dell’Input Utente\nNon fidarsi dell’input dell’utente implica una serie di pratiche per assicurarsi che i dati forniti siano sicuri prima di utilizzarli all’interno dell’applicazione. Questo include la validazione dei dati per tipo, lunghezza, formato e range quando attraversano un confine di fiducia, ad esempio, da un modulo web a uno script dell’applicazione. Dopo la validazione, i dati devono essere codificati prima di essere reinseriti in una pagina dinamica.\nRevisione e Trattamento dei Dati Forniti dall’Utente\nÈ necessario esaminare ogni punto del sito dove i dati forniti dagli utenti vengono gestiti ed elaborati, assicurandosi che, prima di essere restituiti all’utente, i valori accettati dal lato client siano controllati, filtrati e codificati. La validazione lato client non è sufficientemente affidabile; tuttavia, l’input dell’utente può essere ridotto a un set alfanumerico minimo con l’elaborazione lato server prima di essere utilizzato dall’applicazione web.\nEscaping\nL’escaping implica la conversione (o la marcatura) dei caratteri chiave nei dati per prevenirne l’interpretazione in un contesto pericoloso. Nel contesto dell’output HTML, è necessario convertire caratteri come &lt; e &gt; in entità equivalenti, &amp;lt; e &amp;gt;, per impedire l’esecuzione di codice maligno. Questi caratteri, una volta convertiti, non verranno interpretati come tag HTML dal browser.\nCaratteri Speciali\nÈ necessario codificare i caratteri speciali come &lt; e &gt; prima che vengano visualizzati di nuovo, se ricevuti dall’input dell’utente. Ad esempio, la codifica di &lt; e &gt; assicura che un browser visualizzi &lt;script&gt; ma non lo esegua. In aggiunta alla codifica, le pagine web devono sempre definire il loro set di caratteri in modo che il browser non interpreti le codifiche dei caratteri speciali provenienti da altri set di caratteri.\nCaratteri Speciali Rilevanti in XML/HTML\n\n&lt; (Minore di): &amp;lt;\n&gt; (Maggiore di): &amp;gt;\n” (Virgoletta doppia): &amp;quot;\n’ (Apostrofo): &amp;#x27;\n&amp; (E commerciale): &amp;amp;\n/ (Slash): &amp;#x2F;\n\nGli attacchi XSS si verificano solitamente quando uno script maligno (spesso JavaScript) viene inserito in un sito web, consentendo l’esecuzione di codice dannoso. La codifica e l’escaping dei dati sono misure preventive essenziali per proteggere le applicazioni web da tali minacce.\nRisorse per la Difesa contro XSS\nLa difesa contro gli attacchi Cross-Site Scripting (XSS) richiede un approccio informato e proattivo. Fortunatamente, esistono numerose risorse che possono aiutare gli sviluppatori a proteggere le loro applicazioni. Di seguito sono elencate alcune delle risorse più utili fornite dall’OWASP (Open Web Application Security Project), una fondazione che gioca un ruolo chiave nella diffusione delle migliori pratiche di sicurezza delle applicazioni web.\nOWASP Java Encoder\n\nProgetto: OWASP Java Encoder\nDescrizione: Una libreria dedicata alla difesa delle applicazioni web Java contro XSS, convertendo i dati in formati sicuri per l’HTML.\nLink: OWASP Java Encoder Project\n\nGeneral XSS Prevention Cheat Sheet\n\nDescrizione: Una guida completa alle strategie di prevenzione contro gli attacchi XSS, inclusi i metodi di codifica e le pratiche di sanitizzazione.\nLink: General XSS Prevention Cheat Sheet\n\nDOM XSS Prevention Cheat Sheet\n\nDescrizione: Una risorsa specifica per la prevenzione di attacchi XSS basati sul DOM, con consigli e tecniche per mitigare questo tipo di vulnerabilità.\nLink: DOM XSS Prevention Cheat Sheet\n\nXSS Filter Evasion Cheat Sheet\n\nDescrizione: Una guida per comprendere come gli attaccanti possono eludere i filtri XSS e come rafforzare le difese per prevenirlo.\nLink: XSS Filter Evasion Cheat Sheet\n\nSpecifici dei Framework JavaScript\nLa codifica lato client può presentare delle sfide uniche. Di seguito sono elencate alcune risorse per framework specifici:\njQuery\n\nAttenzione all’uso di $selector.html(userInputHere); è rischioso. Per un uso sicuro, preferire $selector.html(someEncodeHtmlMethod(userInputHere)) o $selector.text(someEncodeHtmlMethod(userInputHere)) per un output basato solo su testo.\nRisorsa: jQuery .text Method XSS Safety\n\nBackbone.js\n\nLa differenza può stare in un singolo carattere. Utilizzare template sicuri è fondamentale.\nRisorse: Underscore.js Template, Don’t Break Your Backbone: XSS Mitigation\n\nAngular\n\nAngular cerca di eseguire l’escaping per impostazione predefinita, ma è stato riscontrato che il linguaggio di espressione può essere soggetto a evasioni dal ‘sandbox’. È consigliabile verificare i dettagli della versione in uso e consultare la documentazione ufficiale.\nRisorsa: Angular Security Guide\n\nQueste risorse rappresentano un punto di partenza essenziale per gli sviluppatori che cercano di rafforzare le difese delle loro applicazioni web contro gli attacchi XSS. Ricordarsi sempre di rimanere aggiornati sulle ultime tecniche di attacco e sulle strategie di difesa, poiché sia gli attacchi che le tecnologie web evolvono continuamente.\nPer prevenire attacchi di tipo Reflective XSS attraverso l’escape dei parametri URL nel file JSP, è possibile utilizzare la JSTL (JavaServer Pages Standard Tag Library) per codificare in modo sicuro l’input dell’utente prima di visualizzarlo. Ciò implica l’utilizzo del tag &lt;c:out&gt;, che esegue automaticamente l’escape delle entità HTML e JavaScript, prevenendo così l’esecuzione di script maligni. Prima di tutto, assicurati che la JSTL sia inclusa nel tuo progetto; puoi farlo aggiungendo la libreria JSTL alla directory WEB-INF/lib della tua applicazione web.\nEcco come puoi modificare il file JSP per utilizzare il tag &lt;c:out&gt; per visualizzare in modo sicuro i dati degli utenti:\n&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;\n&lt;%@ taglib uri=&quot;java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;\n&lt;html&gt;\n \n&lt;head&gt;\n    &lt;title&gt;Utilizzo dei metodi GET e POST per leggere i dati del form&lt;/title&gt;\n&lt;/head&gt;\n \n&lt;body&gt;\n    &lt;h1&gt;Utilizzo del metodo POST per leggere i dati del form&lt;/h1&gt;\n    &lt;table&gt;\n        &lt;tbody&gt;\n            &lt;tr&gt;\n                &lt;td&gt;&lt;b&gt;Nome:&lt;/b&gt;&lt;/td&gt;\n                &lt;td&gt;&lt;c:out value=&quot;${param.first_name}&quot; /&gt;&lt;/td&gt;\n            &lt;/tr&gt;\n            &lt;tr&gt;\n                &lt;td&gt;&lt;b&gt;Cognome:&lt;/b&gt;&lt;/td&gt;\n                &lt;td&gt;&lt;c:out value=&quot;${param.last_name}&quot; /&gt;&lt;/td&gt;\n            &lt;/tr&gt;\n        &lt;/tbody&gt;\n    &lt;/table&gt;\n&lt;/body&gt;\n \n&lt;/html&gt;\nModifiche Spiegate:\n\nDirettiva Taglib JSTL: La linea &lt;%@ taglib uri=&quot;java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt; viene aggiunta all’inizio del file per indicare l’uso della libreria JSTL. Questo permette di utilizzare i tag JSTL nel file JSP.\nEscape dell’input dell’utente: L’utilizzo del tag &lt;c:out value=&quot;${param.first_name}&quot; /&gt; e &lt;c:out value=&quot;${param.last_name}&quot; /&gt; consente di eseguire l’escape automatico dei caratteri speciali nell’input dell’utente, convertendoli in entità HTML sicure. Questo impedisce al browser di interpretare l’input come parte del codice della pagina, bloccando l’esecuzione di script potenzialmente pericolosi.\nPer prevenire attacchi di tipo Stored XSS utilizzando OWASP AntiSamy, è necessario sanificare l’input dell’utente prima di salvarlo nel database. AntiSamy permette di creare una stringa “pulita” basandosi su un file di politiche (policy) configurabile. Ecco come si può modificare la classe AntiSamyController per includere questa funzionalità di sanificazione:\n\nimport org.owasp.validator.html.*;\nimport MyCommentDAO;\n \npublic class AntiSamyController {\n    // Assumiamo che la connessione e altre configurazioni necessarie siano già state fatte\n    ...\n \n    public void saveNewComment(int threadID, int userID, String newComment){\n        try {\n            // Crea un&#039;istanza di AntiSamy basandosi sul file di policy\n            Policy policy = Policy.getInstance(&quot;path/to/antisamy-slashdot.xml&quot;); // Assicurati di specificare il percorso corretto del file di policy\n            AntiSamy antiSamy = new AntiSamy();\n            \n            // Sanifica l&#039;input dell&#039;utente\n            CleanResults results = antiSamy.scan(newComment, policy);\n            \n            // Ottiene la stringa pulita e la salva nel database\n            String cleanComment = results.getCleanHTML();\n            MyCommentDAO.addComment(threadID, userID, cleanComment);\n        } catch (PolicyException | ScanException e) {\n            e.printStackTrace();\n            // Gestire l&#039;eccezione o registrare l&#039;errore come più appropriato\n        }\n    }\n \n    ...\n}\nIn questo esempio, il metodo saveNewComment() utilizza AntiSamy per sanificare newComment prima di salvarlo nel database. Questo processo di sanificazione utilizza un file di policy (antisamy-slashdot.xml) che definisce quali tag e attributi HTML sono permessi, garantendo così che l’input salvato nel database non contenga script potenzialmente dannosi.\nÈ importante notare che il percorso del file di policy deve essere specificato correttamente. Questo file di policy può essere personalizzato per soddisfare le specifiche esigenze di sicurezza della tua applicazione.\nImplementando questa soluzione, si previene efficacemente che l’input dannoso venga salvato e successivamente eseguito dal database, mitigando così il rischio di attacchi XSS di tipo Stored."},"Argomenti/Cybersecurity-e-Ethical-hacking/Domande":{"slug":"Argomenti/Cybersecurity-e-Ethical-hacking/Domande","filePath":"Argomenti/Cybersecurity e Ethical hacking/Domande.md","title":"Domande","links":[],"tags":[],"content":"\nDiscuti l’importanza della triade CIA e come sia possibile mantenere la disponibilità di accesso a delle informazioni online pur rispettando confidenzialità e integrità.\nDescivi a cosa serve l’encoding e come viene utilizzato. Fai degli esempi.\nCosa è e a cosa serve HTTPS? Come funziona dal punto di vista tecnico?\nA cosa serve lo XOR encoding e in quale tecnica di crittografia rientra e per quale motivo? Quando può diventare insicuro?\nSpiega come funzionano le tecniche di hashing e come vengono impiegate, approfondendo in particolare come vengono utilizzati nell’autenticazione e quali vulerabilità hanno.\nSpiega cosa è e come funziona una firma digitale. Cosa sono i keystore o truststore?\nDiscuti la minaccia rappresentata dai computer quantistici riguardo la sicurezza.\nPer quale motivo non è sicuro utilizzare soltanto la concatenazione delle stringhe in una query parametrizzata? È sufficiente/necessaria la validazione degli input? Spiega a quale tipo di attacco è vulnerabile questa tecnica e fai un esempio.\nSpiega cosa è il cross site scripting, quali conseguenze può avere e come si contrasta.\nIn cosa consiste il path traversal?\nI controlli sull’input andrebbero fatti a livello di front end, middleware o backend? Per quale motivo? Fai un esempio di frontend bypass.\n"},"Argomenti/Cybersecurity-e-Ethical-hacking/Filtro-Zap":{"slug":"Argomenti/Cybersecurity-e-Ethical-hacking/Filtro-Zap","filePath":"Argomenti/Cybersecurity e Ethical hacking/Filtro Zap.md","title":"Filtro Zap","links":[],"tags":[],"content":""},"Argomenti/Cybersecurity-e-Ethical-hacking/Front-end-bypass":{"slug":"Argomenti/Cybersecurity-e-Ethical-hacking/Front-end-bypass","filePath":"Argomenti/Cybersecurity e Ethical hacking/Front-end bypass.md","title":"Front-end bypass","links":[],"tags":[],"content":"Concetto\nNel contesto delle applicazioni web, gli utenti possono avere un notevole grado di controllo sul front-end, che include la possibilità di modificare il codice HTML e, in alcuni casi, anche gli script. Questo livello di accessibilità permette agli utenti di alterare le richieste inviate al server. È fondamentale che le applicazioni che richiedono un formato di input specifico implementino un meccanismo di validazione anche sul lato server, oltre a quella sul lato client, per prevenire manipolazioni indesiderate.\nObiettivi didattici\n\n\nConoscenza di base di HTML: Gli utenti dovrebbero comprendere i fondamenti dell’HTML, come è strutturato un documento HTML e quali sono i principali tag e attributi utilizzati. Questa conoscenza è essenziale per poter modificare efficacemente il codice del front-end di un’applicazione web.\n\n\nCapacità di manipolare una richiesta prima dell’invio: Gli utenti dovrebbero essere in grado di intercettare e modificare le richieste inviate dal loro browser al server. Questo può essere realizzato utilizzando strumenti come proxy web, che permettono di osservare e alterare il traffico HTTP/HTTPS tra il client e il server.\n\n\nPossibilità di eludere le restrizioni dei campi e la validazione lato client: Gli utenti dovrebbero essere capaci di modificare i limiti imposti sui campi di input e di bypassare le validazioni effettuate sul lato client. Questo include la rimozione o la modifica di validazioni JavaScript che impediscono l’invio di dati non conformi alle aspettative del server. Questa pratica sottolinea l’importanza della validazione sul lato server per garantire la sicurezza e l’integrità dei dati.\n\n\nEsempio pratico\nImmaginiamo un form di registrazione su un sito web che include un campo per l’età, il quale accetta solo valori numerici da 18 a 65. La validazione lato client impedisce l’inserimento di valori al di fuori di questo intervallo attraverso uno script JavaScript. Un utente con conoscenze di HTML e strumenti di intercettazione delle richieste potrebbe modificare il valore inviato al server, inserendo un’età non consentita, come 17 o 66. Se il server non valida nuovamente questi dati, l’utente riuscirebbe a registrarsi con un’età non conforme alle regole del sito.\nIn conclusione, mentre la manipolazione del front-end può offrire agli utenti la flessibilità di personalizzare l’esperienza utente e testare la sicurezza delle applicazioni, è essenziale che gli sviluppatori implementino robuste misure di sicurezza sul lato server per prevenire abusi e garantire la validità dei dati inviati.\nRestrizioni dei Campi\nNel contesto delle applicazioni web moderne, il controllo del codice HTML del front-end da parte del cliente è completo o quasi. Gli utenti possono modificare valori o restrizioni per adattarli alle loro preferenze personali, manipolando così il comportamento previsto del sito web.\nCompito\nL’obiettivo è inviare una richiesta che bypassi le restrizioni di quattro specifici tipi di campo in un form HTML. I campi in questione sono:\n\nCampo select con due possibili valori\nPulsante radio con due possibili valori\n\nOpzione 1\nOpzione 2\n\n\nCheckbox: valore attivato o disattivato\nCampo di input limitato a massimo 5 caratteri\nCampo di input di sola lettura\n\nEsempio di manipolazione dei campi\nPer illustrare come un utente possa bypassare le restrizioni imposte su questi campi, consideriamo un esempio pratico utilizzando strumenti come le DevTools di un browser o un proxy HTTP per modificare le richieste inviate al server:\n\n\nCampo select e pulsante radio: Anche se l’interfaccia utente presenta solo due opzioni, l’utente può inserire un valore diverso modificando il valore dell’elemento nel DOM o intercettando la richiesta e cambiando il valore del parametro prima che venga inviato al server.\n\n\nCheckbox: Di norma, questo controllo invia un valore solo se è selezionato (ad esempio, “on”). L’utente può forzare l’invio di un valore differente o modificare il comportamento di invio per testare la reazione del server a valori inattesi.\n\n\nInput limitato a massimo 5 caratteri: È possibile modificare l’attributo maxlength nel campo di input utilizzando gli strumenti di sviluppo del browser, o rimuovere completamente questa restrizione, permettendo l’inserimento di una stringa più lunga.\n\n\nCampo di input di sola lettura: L’attributo readonly può essere rimosso dal campo di input attraverso la modifica del DOM. Questo permetterebbe di inserire o modificare il valore nel campo che dovrebbe essere non modificabile.\n\n\nQueste tecniche evidenziano la necessità per gli sviluppatori di applicazioni web di non affidarsi unicamente alla validazione lato client per garantire la sicurezza e l’integrità dei dati. È essenziale implementare controlli di validazione robusti anche sul lato server per verificare che i dati ricevuti siano conformi alle aspettative e alle regole di business dell’applicazione, evitando così potenziali abusi o manipolazioni dei dati inviati dagli utenti.\nValidazione\nIn molti contesti applicativi, esistono meccanismi per prevenire l’invio al server di valori di campo modificati, come la validazione prima dell’invio. I browser più popolari, come Chrome, non permettono di modificare gli script durante l’esecuzione, pertanto è necessario trovare altre vie per aggirare queste validazioni.\nCompito\nL’obiettivo è inviare una richiesta che non corrisponda alle espressioni regolari specificate per ciascun campo. Qui di seguito sono descritti i campi e le relative espressioni regolari che determinano i valori validi:\n\nCampo 1: esattamente tre caratteri minuscoli (^[a-z]{3}$)\n\nValore valido: abc\n\n\nCampo 2: esattamente tre cifre (^[0-9]{3}$)\n\nValore valido: 123\n\n\nCampo 3: solo lettere, numeri e spazi (^[a-zA-Z0-9 ]*$)\n\nValore valido: abc 123 ABC\n\n\nCampo 4: enumerazione di numeri (^(one|two|three|four|five|six|seven|eight|nine)$)\n\nValore valido: seven\n\n\nCampo 5: codice postale semplice (^\\d{5}$)\n\nValore valido: 01101\n\n\nCampo 6: codice postale con trattino opzionale e quattro cifre (^\\d{5}(-\\d{4})?$)\n\nValore valido: 90210-1111\n\n\nCampo 7: numero di telefono USA con o senza trattini (^[2-9]\\d{2}-?\\d{3}-?\\d{4}$)\n\nValore valido: 301-604-4882\n\n\n\nEsempi di manipolazione\nPer inviare richieste che non soddisfano le espressioni regolari sopra menzionate, potresti considerare i seguenti valori di esempio:\n\nCampo 1: Inviare ab o abcd (troppo corto o troppo lungo)\nCampo 2: Inviare 12a (non solo cifre)\nCampo 3: Inviare abc@123 (presenza di caratteri non permessi)\nCampo 4: Inviare ten (valore non incluso nell’enumerazione)\nCampo 5: Inviare 011010 (più di 5 cifre)\nCampo 6: Inviare 90210-111 (ultima parte non rispetta le 4 cifre richieste)\nCampo 7: Inviare 101-604-4882 (inizia con una cifra non permessa)\n\nQuesti esempi dimostrano l’importanza della validazione lato server per garantire che i dati inviati rispettino le regole e i formati attesi. Affidarsi esclusivamente alla validazione lato client può esporre l’applicazione a rischi di sicurezza, manipolazione dei dati e comportamenti non previsti. Implementare controlli di validazione robusti e coerenti su entrambi i lati, client e server, è fondamentale per mantenere l’integrità e la sicurezza delle applicazioni web."},"Argomenti/Cybersecurity-e-Ethical-hacking/HTTP":{"slug":"Argomenti/Cybersecurity-e-Ethical-hacking/HTTP","filePath":"Argomenti/Cybersecurity e Ethical hacking/HTTP.md","title":"HTTP","links":[],"tags":[],"content":"Comprensione delle Transazioni HTTP\nPanoramica di HTTP\nHTTP (Hypertext Transfer Protocol) è il protocollo primario utilizzato per la trasmissione di pagine web e file associati su Internet. Le transazioni HTTP coinvolgono un client (solitamente un browser web) che invia richieste a un server per ottenere o inviare informazioni. Queste transazioni seguono un formato generale che comprende tre parti principali: la linea di richiesta o risposta, una sezione di intestazione e il corpo dell’entità.\nIl Processo di Transazione HTTP\n\nIniziazione della Transazione da Parte del Cliente:\nIl client avvia una transazione contattando il server e inviando una richiesta di documento. Per esempio, una richiesta GET può includere parametri nell’URL, che saranno registrati nei log di accesso al web del server.\n\n   GET /index.html HTTP/1.0\n\nInvio delle Intestazioni Opzionali:\nDopo la richiesta iniziale, il client può inviare informazioni di intestazione opzionali per informare il server sulla sua configurazione e sui formati di documento che accetta. Queste intestazioni aiutano il server a personalizzare la risposta in base alle capacità e preferenze del client.\n\n   User-Agent: Mozilla/4.06\n   Accept: image/gif, image/jpeg\n\nRichieste POST e Dati Forniti dall’Utente:\nIn una richiesta POST, i dati forniti dall’utente seguono le intestazioni opzionali e non sono inclusi nell’URL della POST. Questo metodo è comunemente utilizzato per l’invio di formulari o per il trasferimento di dati sensibili che non dovrebbero essere esposti nell’URL.\n\nEsercitazioni Pratiche con WebGoat e OWASP ZAP\nPer comprendere meglio come funzionano le transazioni HTTP e per mettere in pratica le conoscenze acquisite, si può utilizzare WebGoat, una piattaforma di apprendimento interattiva focalizzata sulla sicurezza delle applicazioni web. WebGoat offre la possibilità di interagire con componenti web reali attraverso esercizi che mostrano come le richieste HTTP sono costruite e gestite.\nOWASP Zed Attack Proxy (ZAP) è un altro strumento essenziale per coloro che desiderano esplorare ulteriormente la sicurezza delle applicazioni web. ZAP permette di intercettare e modificare le richieste e le risposte tra il browser e il server, offrendo un’opportunità unica per vedere in tempo reale come le informazioni vengono scambiate attraverso il web.\nQuesti strumenti sono particolarmente utili per:\n\nVisualizzare i parametri della richiesta HTTP.\nEsaminare i cookie della richiesta HTTP.\nAnalizzare il codice sorgente Java delle applicazioni web.\n\nUtilizzare queste piattaforme può aiutare a sviluppare una comprensione pratica delle vulnerabilità comuni nel web e delle tecniche per mitigarle.\nEsercizio Pratico: Gestione di una Richiesta HTTP\nQuesto esercizio illustra le basi della gestione di una richiesta HTTP attraverso un semplice esempio di interazione con un server web. Seguendo le istruzioni sottostanti, potrai vedere come un server elabora i dati inviati da un utente e come risponde modificando questi dati.\nIstruzioni per l’Esercizio\n\n\nInserisci il tuo nome nel campo di input sottostante.\n\nTrova il campo di input dove è richiesto di inserire il tuo nome.\n\n\n\nPremi il pulsante “Go!” per inviare la richiesta.\n\nUna volta inserito il tuo nome, clicca sul pulsante “Go!” per inviare la tua richiesta al server.\n\n\n\nOsserva la risposta del server.\n\nIl server riceverà il tuo nome, lo inverterà e ti mostrerà il risultato. Per esempio, se inserisci “Davide”, il server risponderà con “edivaD”.\n\n\n\nObiettivo dell’Esercizio\nL’obiettivo di questo esercizio è dimostrare come un server web gestisce le richieste HTTP inviate dai clienti. In particolare, vedrai come i dati vengono ricevuti dal server, come possono essere elaborati e infine come vengono inviati indietro al client sotto forma di risposta. Questo processo illustra un aspetto fondamentale delle interazioni tra client e server nel contesto del web.\nQuesto tipo di esercizio aiuta a comprendere meglio la dinamica delle richieste e delle risposte HTTP, nonché le basi della programmazione lato server.\nIl Quiz\nDomanda del Quiz\nQual è il tipo di comando HTTP utilizzato da WebGoat per questa lezione? Un POST o un GET?\nContesto e Risposta\nPer rispondere correttamente a questa domanda, è importante considerare il tipo di azione che viene eseguita quando l’utente inserisce il suo nome e preme il pulsante “Go!“. L’azione descritta implica l’invio di dati (il nome dell’utente) al server per essere elaborati (in questo caso, invertiti) e quindi restituiti al client.\nIn base a questa descrizione, il tipo di comando HTTP più appropriato per trasmettere dati che devono essere elaborati in questo modo è tipicamente un POST. I comandi POST sono usati per inviare dati al server, ad esempio, quando si compila un modulo su una pagina web. I dati inviati tramite POST non sono visibili nell’URL, rendendolo più sicuro per la trasmissione di informazioni sensibili o private.\nPertanto, la risposta corretta è: POST.\nCos’è un HTTP Proxy\nDefinizione e Utilizzo\nUn proxy HTTP è un’applicazione intermedia che agisce come intermediario tra un client HTTP e le risorse del backend. I client HTTP possono essere browser o applicazioni come curl, SOAP UI, Postman, ecc. Generalmente, i proxy vengono utilizzati per il routing e per ottenere accesso a internet quando non esiste una connessione diretta a internet dal client stesso. I proxy HTTP sono quindi ideali anche per testare le applicazioni. Utilizzando i record di log del proxy, è possibile vedere ciò che è stato effettivamente inviato dal client al server, permettendo di controllare le intestazioni di richiesta e risposta e i payload in formati come XML, JSON, o altri.\nFunzionamento di un HTTP Proxy\nUn HTTP Proxy riceve richieste da un client e le inoltra. Tipicamente, registra anche queste transazioni. Funziona come un “uomo nel mezzo” (man-in-the-middle), ed è efficace sia con che senza HTTPS, a condizione che il client o il browser si fidi del certificato del proxy HTTP.\nCapacità del Proxy ZAP\nCon ZAP (Zed Attack Proxy), è possibile registrare il traffico, ispezionarlo, modificare le richieste e le risposte inviate e ricevute dal browser e ottenere rapporti su una serie di vulnerabilità conosciute che ZAP rileva attraverso l’ispezione del traffico. La segnalazione passiva e attiva delle questioni di sicurezza è solitamente utilizzata nelle pipeline di Continuous Delivery che impiegano una versione di ZAP senza interfaccia grafica. Qui, useremo ZAP in modo interattivo, principalmente per visualizzare e modificare le richieste per individuare vulnerabilità e risolvere compiti. ZAP dispone di un’interfaccia grafica, ma ora include anche un HUD (Heads-On-Display), che stabilisce una connessione via web socket tra il browser e il proxy ZAP.\nQuesto strumento è particolarmente utile per gli sviluppatori e i professionisti della sicurezza informatica, che possono sfruttare le sue funzionalità per migliorare la sicurezza delle applicazioni web attraverso un’analisi dettagliata del traffico di rete.\nStrumenti per Sviluppatori di Google Chrome\nIntroduzione agli Strumenti per Sviluppatori\nGli strumenti per sviluppatori di Google Chrome sono una suite di utility integrate nel browser che permettono agli sviluppatori di analizzare, testare e modificare pagine web in tempo reale. Anche se questa introduzione si concentra sugli strumenti disponibili in Google Chrome, quasi tutti i moderni browser offrono un insieme simile di strumenti. Puoi comunque utilizzare il browser di tua scelta, come Firefox o Safari, anche se alcuni passaggi di questo tutorial potrebbero differire.\nScopo del Tutorial\nQuesto tutorial è volto a fornire le conoscenze essenziali per completare specifiche assegnazioni utilizzando gli strumenti per sviluppatori. Non è inteso come una guida completa a tutte le funzionalità di questi strumenti. Se sei già familiare con queste utility, puoi saltare queste lezioni.\nCome Accedere agli Strumenti per Sviluppatori\nPer aprire gli strumenti per sviluppatori in Google Chrome, hai diverse opzioni:\n\n\nClic Destro e Ispeziona:\n\nFai clic destro in qualsiasi punto della finestra del browser e seleziona l’opzione “Ispeziona”.\n\n\n\nMenu del Browser:\n\nVai al menu del browser (tre puntini nell’angolo in alto a destra), poi vai a “Altri strumenti” e seleziona l’opzione “Strumenti per sviluppatori”.\n\n\n\nScorciatoia da Tastiera:\n\nUtilizza la combinazione di tasti Ctrl + Shift + I.\n\n\n\nUtilizzo degli Strumenti per Sviluppatori\nUna volta aperti gli strumenti per sviluppatori, avrai accesso a diverse funzionalità, tra cui:\n\nConsole: permette di eseguire comandi JavaScript direttamente nel browser e di visualizzare messaggi di log, errori e avvisi.\nSources (Sorgenti): mostra i file sorgente della pagina web, consentendo di esaminare e modificare il codice HTML, CSS e JavaScript.\nNetwork (Rete): registra le richieste e le risposte tra il browser e i server web, utile per analizzare il flusso di dati e le prestazioni.\n\nQuesti strumenti sono indispensabili per comprendere meglio il funzionamento interno delle pagine web, identificare e risolvere problemi di codice, ottimizzare le prestazioni e garantire una buona esperienza utente.\nLa Scheda “Elements” degli Strumenti per Sviluppatori di Google Chrome\nPanoramica della Scheda “Elements”\nLa scheda “Elements” (Elementi) degli strumenti per sviluppatori di Google Chrome è uno strumento potente che permette di esaminare e modificare il codice HTML e CSS di una pagina web in tempo reale. Questa funzionalità è particolarmente utile per sviluppatori web, designer e chiunque voglia sperimentare con la struttura e lo stile di una pagina.\nFunzionalità del Codice HTML\n\n\nEsplorazione del Codice HTML:\n\nPassando il mouse su una riga di codice HTML nella scheda “Elements”, vedrai che la parte corrispondente del sito web si illumina di blu. Questo indica che la linea di HTML specifica definisce quella sezione del sito.\n\n\n\nModifica degli Elementi HTML:\n\nCliccando all’interno di un elemento HTML, come un tag di paragrafo (&lt;p&gt;), è possibile modificare direttamente il contenuto visibile della pagina web. Dopo aver apportato le modifiche e premuto invio, Chrome aggiornerà il sito per mostrare le modifiche effettuate.\n\n\n\nPersonalizzazione di Tag, Classi e ID:\n\nOltre a modificare il contenuto, puoi anche cambiare il tipo di tag HTML usato, modificare o aggiungere classi e ID agli elementi, e molto altro ancora. Questo permette una personalizzazione dettagliata e specifica di ogni elemento della pagina.\n\n\n\nFunzionalità del Codice CSS\n\n\nAccesso alle Informazioni CSS:\n\nSotto la fonte HTML nella scheda “Elements”, troverai le informazioni relative al CSS utilizzato per stilizzare il sito. Questo include i fogli di stile collegati e i blocchi di stile incorporati.\n\n\n\nModifica del CSS:\n\nCome per l’HTML, anche il CSS può essere modificato direttamente dalla scheda “Elements”. Puoi cambiare i valori specifici o disattivare singoli stili per vedere come influenzano la presentazione del sito.\n\n\n\nVantaggi dell’Uso della Scheda “Elements”\nL’utilizzo della scheda “Elements” offre numerosi vantaggi:\n\nApprendimento interattivo: Permette agli utenti di vedere immediatamente l’effetto delle modifiche al codice sulla presentazione della pagina, facilitando l’apprendimento del web design e dello sviluppo front-end.\nDebugging rapido: Gli sviluppatori possono rapidamente identificare e correggere problemi con la struttura o lo stile di una pagina.\nEsperimentazione visiva: Designer e sviluppatori possono sperimentare con variazioni di layout e stili senza la necessità di modificare i file sorgente originali, rendendo il processo creativo più fluido e meno rischioso.\n\nUtilizzare la scheda “Elements” per manipolare HTML e CSS è uno strumento essenziale per chiunque lavori nella creazione o manutenzione di siti web, offrendo una potente piattaforma per ottimizzare e perfezionare l’esperienza utente finale.\nLa Scheda “Console” degli Strumenti per Sviluppatori di Google Chrome\nPanoramica della Scheda “Console”\nLa scheda “Console” negli strumenti per sviluppatori di Google Chrome è un potente ambiente di interazione che permette agli sviluppatori di visualizzare output, diagnosticare problemi e eseguire codice JavaScript in tempo reale direttamente nel browser. Questa scheda è essenziale per il testing e il debugging del codice JavaScript.\nVisualizzazione di Output e Errori\n\n\nMessaggi di Output:\n\nNella console, puoi vedere tutto ciò che un file JavaScript caricato potrebbe avere stampato. Questo include messaggi di log, avvisi e errori.\n\n\n\nErrori in Rosso:\n\nSe vedi dei messaggi in rosso, significa che ci sono degli errori. Non preoccuparti se vedi questi messaggi; mentre indicano problemi, molti di essi potrebbero essersi già risolti automaticamente.\n\n\n\nEsecuzione di Codice JavaScript\n\n\nPulizia della Console:\n\nPuoi iniziare pulendo la console utilizzando la scorciatoia da tastiera CTRL+L. Questo comando cancella tutti i messaggi precedentemente visualizzati, offrendo una vista pulita per nuove operazioni.\n\n\n\nEsecuzione di Comandi JavaScript:\n\nPer eseguire il tuo codice JavaScript, clicca all’interno della console e scrivi un comando, ad esempio:\nconsole.log(&quot;Hello WebGoat!&quot;);\n\nPremi invio. Dovresti vedere “Hello WebGoat” apparire nella tua console.\n\n\n\nOperazioni Aritmetiche:\n\nLa console permette anche di eseguire alcune operazioni aritmetiche di base. Se digiti, per esempio, 1+3 e premi invio, la console mostrerà 4.\n\n\n\nNote sull’Uso della Console\n\nMessaggi ‘undefined’:\n\nPotresti vedere la parola undefined apparire nella console dopo l’esecuzione di alcuni comandi. Questo è normale e indica semplicemente che la funzione JavaScript chiamata non ha restituito alcun valore, quindi il risultato è undefined. Puoi ignorare tranquillamente questo messaggio.\n\n\n\nLa scheda “Console” è uno strumento indispensabile per lo sviluppo web, offrendo un accesso diretto e immediato al motore JavaScript del browser. È particolarmente utile per test rapidi, esplorazione di snippet di codice o semplicemente per l’apprendimento di JavaScript.\nEsercizio Pratico: Utilizzo della Console per Eseguire JavaScript\nQuesto esercizio ti guiderà nell’uso della scheda “Console” degli strumenti per sviluppatori di Google Chrome per eseguire una funzione JavaScript e osservare la risposta generata.\nPassaggi per l’Esercizio\n\n\nApri gli Strumenti per Sviluppatori:\n\nAssicurati che gli strumenti per sviluppatori siano aperti nel tuo browser. Puoi aprire la console come descritto in precedenza, cliccando con il tasto destro e selezionando “Ispeziona”, dal menu del browser oppure usando la scorciatoia da tastiera CTRL+Shift+I.\n\n\n\nAccedi alla Scheda Console:\n\nSeleziona la scheda “Console” all’interno degli strumenti per sviluppatori per accedere all’ambiente di comando.\n\n\n\nEsegui la Funzione JavaScript:\n\nNella console, digita il seguente comando per eseguire la funzione:\nwebgoat.customjs.phoneHome()\n\nPremi Enter per inviare il comando.\n\n\n\nOsserva la Risposta:\n\nDopo l’esecuzione, dovresti vedere una risposta nella console. La risposta sarà un oggetto JSON che contiene diversi valori, tra cui un numero casuale generato ogni volta che la funzione viene chiamata.\n\n\n\nCosa Fare con il Risultato\n\nCopia il Numero Casuale:\n\nCerca nel risultato della risposta l’elemento che contiene il numero casuale, solitamente indicato dopo &quot;output&quot;:&quot;phone home response is…&quot;.\nCopia questo numero casuale.\n\n\n\n\nIncolla il Numero nel Campo di Testo Sottostante:\n\nIncolla il numero casuale che hai copiato nel campo di testo indicato qui sotto o nella piattaforma di apprendimento che stai utilizzando per completare l’esercizio.\n\n\n\nNota Importante\n\nAggiornamenti Frequenti:\n\nAssicurati di avere il numero più recente, poiché è generato casualmente ogni volta che la funzione viene chiamata. Se necessario, ripeti l’esecuzione della funzione per ottenere un nuovo numero.\n\n\n\nQuesto esercizio dimostra non solo come utilizzare la console per eseguire il codice JavaScript, ma anche come interagire con le funzioni personalizzate all’interno di un’applicazione web, un’abilità fondamentale nello sviluppo e nel testing del software.\nEsplorazione delle Schede “Sources” e “Network” degli Strumenti per Sviluppatori di Google Chrome\nScheda “Sources”\nFunzionalità Principali\nLa scheda “Sources” (Sorgenti) permette di esaminare il sistema di file e visualizzare tutti i file HTML, CSS e JavaScript utilizzati per creare il sito web. Questa scheda è essenziale per chi desidera comprendere la struttura e il codice sottostante di una pagina web.\nCome Usare la Scheda “Sources”\n\nVisualizzazione dei File:\n\nClicca su un file per visualizzarne il contenuto. Potrai vedere il codice sorgente completo, che include HTML, CSS, e JavaScript.\n\n\nNavigazione nel Sistema dei File:\n\nEsplora la struttura delle cartelle per trovare altri file e risorse collegati alla pagina web.\n\n\n\nScheda “Network”\nFunzionalità Principali\nLa scheda “Network” (Rete) offre una visione dettagliata delle richieste HTTP e delle risposte eseguite dal sito web. Questa funzionalità è cruciale per analizzare come i dati vengono scambiati tra il client e il server.\nCome Usare la Scheda “Network”\n\n\nVisualizzazione delle Richieste e Risposte HTTP:\n\nClicca sulla scheda “Network” per vedere un elenco di tutte le richieste e risposte HTTP.\n\n\n\nInformazioni Dettagliate su una Richiesta:\n\nClicca su una richiesta specifica per ottenere informazioni più dettagliate, come l’intestazione della richiesta, il corpo della risposta, i cookie utilizzati, e molto altro.\n\n\n\nAnalisi della Timeline:\n\nLa “Timeline” sopra i punti blu mostra quando sono state effettuate queste richieste e risposte.\nPuoi anche visualizzare le richieste effettuate in un determinato lasso di tempo cliccando e trascinando sulla timeline. La finestra sottostante mostrerà solo le richieste e le risposte effettuate in quel periodo.\n\n\n\nUtilità delle Schede “Sources” e “Network”\nQueste schede sono strumenti indispensabili per gli sviluppatori web, in quanto permettono di:\n\nDebugging del Codice: Identificare e risolvere problemi nel codice HTML, CSS e JavaScript.\nOttimizzazione delle Prestazioni: Analizzare le richieste e le risposte per migliorare i tempi di caricamento e l’efficienza della pagina.\nSicurezza: Verificare come i dati vengono trasmessi e assicurarsi che le informazioni sensibili siano gestite correttamente.\n\nL’uso combinato delle schede “Sources” e “Network” fornisce una comprensione completa delle dinamiche tecniche e del flusso di dati di una pagina web, essenziale per lo sviluppo e il mantenimento di siti web robusti e performanti.\nEsercizio Pratico: Lavorare con la Scheda “Network”\nQuesto esercizio ti guiderà attraverso il processo di identificazione e analisi di una specifica richiesta HTTP utilizzando la scheda “Network” degli strumenti per sviluppatori di Google Chrome. L’obiettivo è trovare un numero casuale generato da una richiesta e utilizzarlo come richiesto nell’assegnazione.\nPassaggi per Completare l’Esercizio\n\n\nApri gli Strumenti per Sviluppatori e la Scheda “Network”:\n\nAssicurati che gli strumenti per sviluppatori siano aperti nel tuo browser e che la scheda “Network” sia selezionata. Puoi aprire gli strumenti per sviluppatori facendo clic destro e selezionando “Ispeziona”, oppure usando la scorciatoia da tastiera Ctrl+Shift+I.\n\n\n\nGenera la Richiesta HTTP:\n\nTrova e clicca il primo pulsante disponibile nella pagina web. Questo azionerà una richiesta HTTP che sarà visibile nella scheda “Network”.\n\n\n\nTrova la Richiesta Specifica:\n\nOsserva le richieste che appaiono nella scheda “Network”. Dovrai trovare la richiesta specifica che contiene il campo networkNum. Questo potrebbe richiedere di cliccare su diverse richieste per esaminare i dettagli.\n\n\n\nCopia il Numero Casuale:\n\nUna volta individuata la richiesta corretta, cerca il campo networkNum nei dettagli della richiesta. Copia il numero visualizzato subito dopo questo campo.\n\n\n\nInserisci il Numero nell’Input Field:\n\nTorna alla pagina web o alla piattaforma di apprendimento dove stai completando l’assegnazione. Incolla il numero che hai copiato nel campo di input previsto.\n\n\n\nConferma il Numero:\n\nClicca sul pulsante di verifica (“check button”) per sottomettere il numero e completare l’assegnazione.\n\n\n\nPunti da Ricordare\n\nAggiornamenti Frequenti: La richiesta HTTP potrebbe essere generata ogni volta che clicchi il pulsante, quindi il numero può cambiare. Assicurati di usare il numero più recente.\nPrecisione: Assicurati di copiare correttamente il numero per evitare errori nel completamento dell’assegnazione.\n\nQuesto esercizio è un ottimo modo per praticare il monitoraggio del traffico di rete e migliorare le tue abilità nell’analisi delle richieste e delle risposte HTTP, competenze cruciali per lo sviluppo web e la sicurezza informatica."},"Argomenti/Cybersecurity-e-Ethical-hacking/Installazione-e-avvio-WebGoat":{"slug":"Argomenti/Cybersecurity-e-Ethical-hacking/Installazione-e-avvio-WebGoat","filePath":"Argomenti/Cybersecurity e Ethical hacking/Installazione e avvio WebGoat.md","title":"Installazione e avvio WebGoat","links":[],"tags":[],"content":"Installazione di Docker\nCon i seguenti comandi installiamo e configuriamo Docker per l’utilizzo su Linux su una distribuzione Debian-based. Nelle altre distribuzioni, utilizzare il packet manager relativo. Docker si può anche installare su Windows. In alcune distribuzioni Debian non serve utilizzare systemctl enable.\n   sudo apt install docker\n   systemctl enable docker\n   sudo usermod -aG docker $USER\nSe usermod non funziona, aggiungere manualmente il gruppo e poi lanciare usermod\nsudo groupadd docker\nsudo usermod -aG docker $USER\nRiavviare il sistema\nDownload e utilizzo di WebGoat-desktop\n\n\n                  \n                  Attenzione!!! \n                  \n                \n\n\nNon utilizzare mai WebGoat sulla tua macchina fisica in versione standalone, in quanto la rende vulnerabile ed espone ad attacchi. Se vuoi utilizzare WebGoat senza container, assicurati di utilizzare una macchina virtuale che abbia unicamente questo scopo\n\n\n\nPer i nostri scopi utilizziamo WebGoat-desktop, un container Docker con un desktop environment Linux preconfigurato per l’utilizzo con WebGoat e i suoi strumenti (comodo per evitare di installare programmi aggiuntivi sul proprio sistema e buttare via tutto una volta che non si vuole più utilizzare WebGoat con un semplice comando). Lanciamo l’immagine con il seguente comando (questo comando va usato soltanto la prima volta):\ndocker run --name webgoat -p 127.0.0.1:3000:3000 webgoat/webgoat-desktop\nSe fosse la prima volta che lanciamo l’immagine, Docker lo scaricherà automaticamente. Utilizzando il parametro --name diamo un nome al container che stiamo utilizzando, in questo caso webgoat. In questo modo, rendiamo persistenti le modifiche fatte all’immagine webgoat fintanto che non la eliminiamo.\nA questo punto, per avviare l’immagine le volte successive basterà utilizzare\ndocker start webgoat\nper avviare l’immagine e\ndocker stop webgoat\nper fermarla.\nUna volta avviata l’immagine, basterà aprire il proprio browser e connettersi all’indirizzo localhost:3000 e potremmo utilizzare il nostro container tramite una connessione VNC.\nDentro l’immagine, possiamo eseguire WebGoat e ZAP con i seguenti comandi:\nsh start_webgoat.sh\nsh start_zap.sh\nUna volta avviati, aprire il browser all’indirizzo indicato dalla console, di solito http://127.0.0.1:8080/WebGoat/\nA tal proposito, se si vuole utilizzare ZAP, assicurarsi di avviare prima WebGoat, in quanto altrimenti ZAP userà la stessa porta di WebGoat impedendogli di avviarsi."},"Argomenti/Cybersecurity-e-Ethical-hacking/Path-Traversal":{"slug":"Argomenti/Cybersecurity-e-Ethical-hacking/Path-Traversal","filePath":"Argomenti/Cybersecurity e Ethical hacking/Path Traversal.md","title":"Path Traversal","links":[],"tags":[],"content":"Comprensione del Path Traversal\nDefinizione e Meccanismo\nIl path traversal, noto anche come directory traversal, è una vulnerabilità di sicurezza che si verifica quando non viene applicata una valida sicurezza alla verifica degli input dei file forniti dall’utente. Questo permette agli aggressori di accedere a file o directory che sono conservati fuori dalla cartella prevista. Manipolando gli input, gli aggressori possono navigare attraverso la struttura delle directory del server e accedere a file o directory al di fuori di quelli concessi dall’applicazione.\nEsempio di Attacco\nConsideriamo un’applicazione che ospita file in questo formato: example.com/file=report.pdf. Un attaccante, interessato ad accedere ad altri file, potrebbe provare a inserire example.com/file=../../../../../etc/passwd nel browser. In questo esempio, l’attaccante tenta di risalire fino alla radice del filesystem e quindi accedere al file /etc/passwd. L’uso della sequenza ../, nota anche come dot-dot-slash, è il metodo fondamentale per navigare tra le directory in modo retrogrado.\nTecniche di Elusione della Sicurezza\nSebbene negli esempi più diretti questo metodo possa non funzionare a causa dei controlli implementati nei moderni framework, gli aggressori possono diventare più creativi per eludere tali misure. Un metodo comune è l’encoding dell’URL. Codificando ../ come %2e%2e%2f, il server web riceverà questa richiesta e la decodificherà nuovamente in ../.\nInoltre, se l’applicazione filtra questi encoding, la doppia codifica può risultare efficace. La doppia codifica potrebbe essere necessaria quando un sistema A chiama un sistema B. Il sistema A potrebbe decodificare una volta sola e passare l’URL ancora codificato al sistema B.\nContromisure\nPer mitigare le vulnerabilità di path traversal, gli sviluppatori devono implementare una rigorosa validazione dell’input, limitando le possibilità degli utenti di inserire percorsi relativi o assoluti. È anche prudente utilizzare liste di controllo di accesso a file (file access control lists) per restringere l’accesso ai file solo a quelli strettamente necessari per l’operatività dell’applicazione."},"Argomenti/Cybersecurity-e-Ethical-hacking/SQL-Injection":{"slug":"Argomenti/Cybersecurity-e-Ethical-hacking/SQL-Injection","filePath":"Argomenti/Cybersecurity e Ethical hacking/SQL Injection.md","title":"SQL Injection","links":[],"tags":[],"content":"Introduzione al SQL (Structured Query Language)\nSQL è un linguaggio di programmazione progettato per gestire e manipolare i database relazionali. Viene utilizzato per eseguire varie operazioni sui dati, come l’inserimento, l’aggiornamento, la cancellazione e la ricerca di record nei database. SQL gioca un ruolo cruciale nell’interazione con i database, permettendo agli sviluppatori e agli analisti di dati di estrarre facilmente informazioni significative.\nConcetti Fondamentali di SQL\n\nDML (Data Manipulation Language): Include comandi come SELECT, INSERT, UPDATE, e DELETE, usati per manipolare i dati presenti nelle tabelle.\nDDL (Data Definition Language): Comprende istruzioni come CREATE, ALTER, DROP, che sono utilizzate per definire e modificare la struttura del database, come la creazione di tabelle.\nDCL (Data Control Language): Include comandi come GRANT e REVOKE, impiegati per definire i diritti e gli accessi degli utenti.\n\nComprensione dell’SQL injection\nL’SQL injection è una tecnica di attacco informatico che sfrutta le vulnerabilità nel codice di un’applicazione per manipolare le query SQL. Questo permette agli aggressori di eseguire operazioni non autorizzate sul database, come accedere a dati sensibili, modificarli o eliminarli.\nTipi di SQL injection\n\nSQL injection basata su Stringhe: Si verifica quando l’attaccante inserisce una sequenza di caratteri che termina la stringa SQL originale e aggiunge una nuova query o condizione.\nSQL injection Numerica: Avviene quando l’input atteso è un numero, e l’attaccante inserisce una query SQL o condizioni logiche che alterano la query originale.\n\nSQL injection e la Triade CIA\nLa triade CIA (Confidenzialità, Integrità, Disponibilità) rappresenta i principi fondamentali della sicurezza informatica. L’SQL injection impatta negativamente su tutti e tre gli aspetti:\n\nConfidenzialità: L’SQL injection può essere utilizzata per accedere a dati riservati senza autorizzazione, violando la confidenzialità.\nIntegrità: Gli attacchi possono alterare o cancellare dati, compromettendo l’integrità delle informazioni memorizzate nel database.\nDisponibilità: Un attacco SQL Injection può anche portare al sovraccarico del sistema o alla corruzione dei dati, influenzando la disponibilità dei servizi\n\nStruttura di base e select\nQuesta lezione introduce le basi di SQL (Structured Query Language), il linguaggio standardizzato usato per gestire database relazionali e per eseguire varie operazioni sui dati contenuti. SQL consente di organizzare i dati in righe, colonne e tabelle, e di indicizzarli per rendere più efficiente la ricerca di informazioni pertinenti.\nEsempio di Tavola SQL\nL’esempio fornito mostra una tabella chiamata employees che contiene dati sugli impiegati di un’azienda. Ogni riga rappresenta un dipendente e include informazioni come numero di identificazione unico (userid), nome, cognome, dipartimento, salario e un numero di autenticazione della transazione (auth_tan).\nCategorie Principali di Comandi SQL\n\nData Manipulation Language (DML): Questi comandi sono utilizzati per manipolare i dati all’interno delle tabelle del database. Esempi includono SELECT, INSERT, UPDATE, e DELETE.\nData Definition Language (DDL): Questi comandi sono usati per definire, modificare o eliminare strutture di dati, come le tabelle. Esempi includono CREATE, ALTER, e DROP.\nData Control Language (DCL): Questi comandi gestiscono le autorizzazioni e l’accesso ai dati, includendo comandi come GRANT e REVOKE.\n\nOgnuno di questi tipi di comandi può essere sfruttato dagli attaccanti per compromettere la confidenzialità, l’integrità e/o la disponibilità di un sistema.\nCerto, per l’esercizio di recupero del dipartimento del dipendente Bob Franco dalla tabella employees, ecco una rappresentazione più dettagliata che include il testo dell’esercizio, la struttura della tabella e la query SQL esemplificativa.\nEsercizio\nSi consideri la seguente tabella SQL denominata employees, che contiene dati sugli impiegati di un’azienda. L’azienda registra le seguenti informazioni sui propri dipendenti: un numero unico di identificazione del dipendente (userid), il cognome (last_name), il nome (first_name), il dipartimento (department), il salario (salary) e un numero di autenticazione della transazione (auth_tan). Ogni pezzo di informazione è memorizzato in una colonna separata, e ogni riga rappresenta un singolo dipendente dell’azienda.\nStruttura della Tavola employees\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nuseridfirst_namelast_namedepartmentsalaryauth_tan32147PaulinaTraversAccounting$46.000P45JSI89762TobiBarnettDevelopment$77.000TA9LL196134BobFrancoMarketing$83.700LO9S2V34477AbrahamHolmanDevelopment$50.000UU2ALK37648JohnSmithMarketing$64.3503SL99A\nEsercizio\nCompito: Recuperare il dipartimento del dipendente Bob Franco. Si assume di avere pieni privilegi amministrativi per questo compito e di poter accedere a tutti i dati senza autenticazione.\nQuery SQL Esemplificativa\nPer ottenere il dipartimento di Bob Franco, si utilizza la seguente query SQL:\nSELECT department FROM employees WHERE first_name = &#039;Bob&#039; AND last_name = &#039;Franco&#039;;\nRisultato Atteso\nLa query dovrebbe restituire il dipartimento di Bob Franco, che, secondo la tabella fornita, è “Marketing”.\nConclusioni\nQuesto esercizio dimostra come utilizzare una query SQL SELECT per filtrare e recuperare informazioni specifiche da una tabella basandosi su criteri definiti, come il nome e il cognome di un dipendente. Gli esercizi come questo sono fondamentali per comprendere le operazioni di base di SQL e per imparare a manipolare e accedere ai dati all’interno di un database relazionale.\nData Manipulation Language (DML)\nIl Data Manipulation Language (DML) è una componente fondamentale del SQL che si occupa della manipolazione dei dati all’interno dei database. Attraverso l’utilizzo di comandi DML, è possibile eseguire operazioni come la richiesta, l’aggiunta, la modifica e la cancellazione di record. Gli attacchi di SQL Injection sfruttano proprio questi comandi per compromettere la sicurezza dei sistemi.\nComandi DML Principali:\n\nSELECT: Per recuperare dati da una o più tabelle.\nINSERT: Per inserire nuovi dati nelle tabelle.\nUPDATE: Per aggiornare i dati esistenti.\nDELETE: Per eliminare i record dalle tabelle.\n\nQuesti comandi sono essenziali sia per la gestione quotidiana dei dati che per lo sviluppo di applicazioni robuste e sicure.\nEsempio di Utilizzo DML:\nPer recuperare il numero di telefono di un dipendente specifico, si utilizzerebbe il comando SELECT come segue:\nSELECT phone\nFROM employees\nWHERE userid = 96134;\nQuesto comando estrae il numero di telefono del dipendente con userid 96134.\nEsercizio Pratico: Modifica del Dipartimento\nObiettivo: Cambiare il dipartimento di Tobi Barnett in ‘Sales’.\nPremessa: Si assume di avere pieni privilegi amministrativi, il che permette di accedere e modificare tutti i dati senza necessità di autenticazione.\nPassaggi Consigliati:\n\nIdentificare il Record: Prima di tutto, è necessario individuare il record corrispondente a Tobi Barnett nella tabella employees.\nEseguire l’UPDATE: Utilizzare il comando UPDATE per modificare il dipartimento di Tobi Barnett.\n\nQuery SQL di Esempio:\nUPDATE employees\nSET department = &#039;Sales&#039;\nWHERE first_name = &#039;Tobi&#039; AND last_name = &#039;Barnett&#039;;\nQuesta query modifica il dipartimento di Tobi Barnett in ‘Sales’, dimostrando come un comando DML UPDATE possa essere utilizzato per aggiornare i dati in un database.\nRiflessione sulla Sicurezza\nLa capacità di manipolare i dati tramite DML sottolinea l’importanza di proteggere le applicazioni web da attacchi di SQL Injection. Tali attacchi possono violare la confidenzialità, l’integrità e la disponibilità dei dati, compromettendo gravemente la sicurezza di un sistema. Implementare misure di sicurezza come la validazione dell’input, l’uso di query parametrizzate e la limitazione dei privilegi di accesso al database sono passi cruciali per mitigare questo rischio.\nDDL (Data Definition Language)\nLa Data Definition Language (DDL) comprende comandi utilizzati per definire la struttura dei dati all’interno di un database. Questi comandi sono fondamentali per la creazione, la modifica e l’eliminazione degli oggetti del database, contribuendo a delineare lo schema del database, che include tabelle, indici, viste, relazioni, trigger e altro ancora.\nComandi DDL Principali\n\nCREATE: Utilizzato per creare nuovi oggetti nel database, come tabelle e viste.\nALTER: Modifica la struttura di un oggetto esistente, come aggiungere o rimuovere colonne in una tabella.\nDROP: Elimina oggetti dal database, rimuovendo definitivamente tabelle, viste o altri oggetti.\n\nEsempio: Creazione di una Tabella\nCREATE TABLE employees(\n    userid varchar(6) not null primary key,\n    first_name varchar(20),\n    last_name varchar(20),\n    department varchar(20),\n    salary varchar(10),\n    auth_tan varchar(6)\n);\nQuesto comando CREATE TABLE crea la tabella degli impiegati (employees) con varie colonne per memorizzare informazioni quali l’ID utente, il nome, il cognome, il dipartimento, lo stipendio e un numero di autenticazione della transazione.\nRischi per la Sicurezza con DDL\nUn attaccante che riesce a iniettare comandi DDL in un database può compromettere l’integrità e la disponibilità del sistema:\n\nIntegrità: Utilizzando comandi ALTER e DROP, un attaccante può alterare o rimuovere elementi strutturali essenziali del database, influenzando l’integrità dei dati.\nDisponibilità: I comandi DROP possono essere utilizzati per eliminare tabelle o altri oggetti del database, influenzando negativamente la disponibilità dei dati per gli utenti legittimi.\n\nEsercizio Pratico: Modifica dello Schema\nObiettivo: Aggiungere una colonna “phone” (varchar(20)) alla tabella “employees”.\nAvendo pieni privilegi amministrativi, per aggiungere una nuova colonna alla tabella employees, si utilizza il comando ALTER TABLE come segue:\nALTER TABLE employees\nADD COLUMN phone varchar(20);\nQuesto comando aggiunge una colonna phone alla tabella employees, permettendo di memorizzare numeri di telefono degli impiegati fino a 20 caratteri.\nComprendere e utilizzare correttamente i comandi DDL è essenziale per la gestione efficace della struttura di un database. Tuttavia, è fondamentale garantire che queste operazioni siano protette da accessi non autorizzati per preservare l’integrità e la disponibilità dei dati all’interno del sistema.\nDCL (Data Control Language)\nLa Data Control Language (DCL) comprende comandi utilizzati per implementare la logica di controllo degli accessi in un database. DCL si occupa principalmente della sicurezza e della gestione degli accessi, permettendo agli amministratori di database di specificare i diritti di accesso agli oggetti del database, come tabelle, viste e funzioni.\nComandi Principali DCL\n\nGRANT: Utilizzato per concedere privilegi di accesso a un utente o a un gruppo su specifici oggetti del database.\nREVOKE: Utilizzato per revocare privilegi di accesso precedentemente concessi a un utente o a un gruppo.\n\nRischi per la Sicurezza con DCL\nSe un attaccante riesce a iniettare comandi DCL in un database, può compromettere:\n\nConfidenzialità: Utilizzando comandi GRANT, potrebbe concedere a sé stesso o ad altri privilegi amministrativi, accedendo così a dati sensibili.\nDisponibilità: Utilizzando comandi REVOKE, potrebbe revocare i privilegi di accesso all’amministratore del database o ad altri utenti legittimi, influenzando la disponibilità dei dati.\n\nEsercizio Pratico: Concessione dei Diritti\nObiettivo: Concedere i diritti alla tabella grant_rights all’utente unauthorized_user.\nConsiderando che si dispone di pieni privilegi amministrativi per l’assegnazione, il comando DCL per concedere diritti sull’oggetto tabella grant_rights a unauthorized_user sarebbe:\nGRANT SELECT, INSERT, UPDATE, DELETE ON grant_rights TO unauthorized_user;\nQuesto comando concede all’unauthorized_user i privilegi per eseguire operazioni di SELECT, INSERT, UPDATE, e DELETE sulla tabella grant_rights.\nLa comprensione e l’uso appropriato dei comandi DCL sono cruciali per mantenere la sicurezza dei dati all’interno di un database, garantendo che solo gli utenti autorizzati abbiano accesso alle informazioni appropriate. Gli amministratori di database devono essere diligentemente consapevoli dei diritti concessi e revocati per prevenire potenziali violazioni della sicurezza e assicurare che l’integrità e la confidenzialità dei dati siano preservate.\nSQL Injection\nL’iniezione SQL (SQLi) è una tecnica di hacking tra le più comuni che sfrutta le vulnerabilità nell’interazione tra le applicazioni web e i loro sistemi di gestione del database. Consiste nell’inserimento o “iniezione” di codice SQL maligno attraverso i campi di input forniti agli utenti, come form di ricerca o di login. Se un’applicazione non sanifica correttamente l’input utente o non filtra i caratteri speciali, gli aggressori possono manipolare le query SQL sottostanti per ottenere accesso non autorizzato o danneggiare i dati.\nEsempi di Iniezione SQL\nConsideriamo un’applicazione web che consente agli utenti di recuperare informazioni inserendo un nome utente in un campo di un form. L’input dell’utente viene inviato al server e inserito in una query SQL, che viene poi interpretata da un motore SQL.\nEsempio di Query SQL Base:\n&quot;SELECT * FROM users WHERE name = &#039;&quot; + userName + &quot;&#039;&quot;;\nSe l’input fosse Smith, la query diventerebbe:\n&quot;SELECT * FROM users WHERE name = &#039;Smith&#039;&quot;;\ne restituirebbe tutti i dati relativi all’utente con nome Smith.\nManipolazione tramite Iniezione SQL:\nSe un aggressore inserisce dati contenenti caratteri o stringhe che hanno un significato “speciale” per l’interprete SQL (come ;, --, o &#039;), e i dati non vengono correttamente sanificati o validati, l’aggressore può modificare il comportamento previsto della query SQL per eseguire azioni (maligne) sul database.\nEsempi di Input Maligni:\n\n\nSmith&#039; OR &#039;1&#039; = &#039;1: Risulta in SELECT * FROM users WHERE name = &#039;Smith&#039; OR TRUE; che restituirà tutte le voci dalla tabella users.\n\n\nSmith&#039; OR 1 = 1; --: Risulta in SELECT * FROM users WHERE name = &#039;Smith&#039; OR TRUE;--&#039;; che, come nel primo esempio, restituirà tutte le voci dalla tabella users.\n\n\nSmith&#039;; DROP TABLE users; TRUNCATE audit_log; --: Concatena più comandi SQL per eliminare sia la tabella users che cancellare tutte le voci dalla tabella audit_log.\n\n\nImpatto dell’Iniezione SQL\nL’iniezione SQL può compromettere seriamente l’integrità, la confidenzialità e la disponibilità dei dati in un sistema:\n\nConfidenzialità: Accedendo a dati sensibili senza autorizzazione.\nIntegrità: Modificando o cancellando dati.\nDisponibilità: Rendendo i dati o l’intero database inaccessibili.\n\nPrevenzione dell’Iniezione SQL\nPer prevenire l’iniezione SQL, le applicazioni dovrebbero:\n\nUtilizzare statement SQL parametrizzati o ORM che automaticamente gestiscono la sicurezza dell’input.\nSanificare e validare tutti gli input utente, in particolare quelli che influenzano le query SQL.\nAdottare il principio del minimo privilegio, limitando i diritti degli utenti sui database solo a quelli strettamente necessari.\n\nL’adozione di queste pratiche migliora notevolmente la sicurezza delle applicazioni web e protegge i dati sensibili da accessi non autorizzati o manipolazioni dannose.\nL’iniezione SQL (SQLi) rappresenta una minaccia significativa per la sicurezza dei database collegati alle applicazioni web. Questa tecnica di attacco sfrutta le vulnerabilità nell’input dell’utente che non viene adeguatamente filtrato o sanificato prima di essere eseguito come parte di una query SQL. Le conseguenze di un attacco SQLi riuscito sono vaste e possono avere impatti devastanti sulla sicurezza e l’integrità dei dati. Di seguito, sono dettagliate le possibili conseguenze di un’iniezione SQL:\nLettura e Modifica di Dati Sensibili\nGli attaccanti possono leggere dati sensibili dal database, come informazioni personali degli utenti, dati finanziari, o credenziali di accesso. Questo viola la confidenzialità dei dati e può portare a furti di identità, frodi finanziarie, o altre forme di abuso di dati.\nEsecuzione di Operazioni Amministrative sul Database\nLe iniezioni SQL possono consentire agli attaccanti di eseguire operazioni amministrative sul database, come:\n\nDisattivazione dell’auditing o del DBMS: Compromettendo la capacità di monitorare e registrare le attività sospette.\nTroncamento di tabelle e log: Eliminando i dati importanti e le tracce delle attività degli attaccanti.\nAggiunta di utenti: Creando nuovi account con privilegi elevati, gli attaccanti possono garantirsi l’accesso continuo al sistema.\n\nRecupero del Contenuto di File Presenti nel File System del DBMS\nGli attaccanti possono utilizzare l’iniezione SQL per leggere il contenuto di file specifici presenti nel file system del DBMS, ottenendo così accesso a dati o configurazioni sensibili del sistema.\nEmissione di Comandi al Sistema Operativo\nIn alcuni casi, l’iniezione SQL può permettere agli attaccanti di eseguire comandi direttamente sul sistema operativo sottostante, compromettendo l’intera macchina ospitante il database.\nConseguenze dell’Iniezione SQL sugli Obiettivi di Sicurezza\n\nFalsificazione dell’Identità: Gli attaccanti possono impersonare altri utenti, accedendo a dati o eseguendo azioni non autorizzate.\nAlterazione dei Dati Esistenti: Possono modificare o cancellare dati, compromettendo l’integrità delle informazioni.\nProblemi di Ripudio: Possono alterare bilanci, annullare transazioni o modificare dati critici, creando confusione e problemi legali.\nDivulgazione Completa dei Dati: Possono accedere a tutti i dati del sistema, esponendo informazioni riservate o sensibili.\nDistruggere i Dati o Renderli Altrimenti Non Disponibili: Possono cancellare dati critici o rendere il sistema inutilizzabile, influenzando la disponibilità.\nDiventare Amministratori del Server del Database: Ottenendo il controllo completo sul database e potenzialmente sull’intero sistema.\nL’iniezione SQL rappresenta una grave minaccia per la sicurezza delle applicazioni web, ma la gravità di un attacco può variare ampiamente a seconda di diversi fattori. Ecco una panoramica dei principali elementi che influenzano la severità di un’iniezione SQL:\n\nAbilità e Immaginazione dell’Attaccante\nLa gravità di un’iniezione SQL è fortemente influenzata dall’abilità tecnica e dall’ingegnosità dell’attaccante. Un aggressore con una profonda conoscenza dei sistemi di gestione dei database (DBMS) e delle tecniche avanzate di iniezione SQL può sfruttare vulnerabilità che altri potrebbero non riuscire a identificare o sfruttare.\nMisure di Difesa Stratificate\nLa presenza di misure di difesa multilivello può limitare significativamente l’impatto di un attacco SQLi. Queste misure includono:\n\nValidazione dell’Input: Assicurare che tutti gli input ricevuti dall’utente siano validati per tipologia e formato atteso può prevenire l’esecuzione di query SQL malevole.\nPrincipio del Minimo Privilegio: Limitare i diritti di accesso al database solo a ciò che è strettamente necessario per l’esecuzione delle funzioni dell’applicazione riduce il potenziale impatto di un’iniezione SQL riuscita.\n\nTecnologia del Database\nLa tecnologia del database in uso può influenzare la fattibilità e l’efficacia di un attacco SQLi. Alcuni database non supportano il chaining di comandi, il che può limitare le azioni che un attaccante può eseguire attraverso un’unica iniezione. Ad esempio:\n\nMicrosoft Access, MySQL Connector/J e C, e Oracle hanno limitazioni specifiche che possono ridurre la gravità di un attacco SQLi.\n\nLinguaggi di Programmazione\nL’iniezione SQL è più comune in linguaggi di programmazione più vecchi o meno sicuri come PHP, Classic ASP, Cold Fusion, che inizialmente non fornivano supporto per le query parametrizzate. Tuttavia, le versioni più recenti di questi linguaggi hanno introdotto il supporto per le query parametrizzate, mitigando così il rischio di iniezione SQL.\n\nQuery Parametrizzate: L’uso di query parametrizzate è una delle difese più efficaci contro l’iniezione SQL, poiché separa chiaramente i dati dalle istruzioni SQL, impedendo l’esecuzione di input malevoli come parte della query.\n\nSpecificità dei Database\nNon tutti i database sono uguali. SQL Server, ad esempio, offre funzionalità che possono essere sfruttate dagli attaccanti, come:\n\nShell dei Comandi: Utilizzando master.dbo.xp_cmdshell per eseguire comandi diretti del sistema operativo.\nComandi del Registro di Sistema: Funzioni come xp_regread e xp_regdeletekey possono essere usate per manipolare il registro di sistema del server.\n\nConclusione\nLa severità di un attacco SQLi può variare notevolmente, ma comprendere i fattori che influenzano questa gravità è essenziale per sviluppare strategie di difesa efficaci. Implementare la validazione dell’input, adottare il principio del minimo privilegio, utilizzare tecnologie di database sicure e sfruttare le funzionalità di sicurezza offerte dai linguaggi di programmazione moderni sono passi critici per proteggere le applicazioni web dalle vulnerabilità di iniezione SQL.\nString SQL Injection\nNella nostra dispensa sull’iniezione SQL, esploreremo ora come eseguire un attacco di tipo String SQL Injection e il potenziale impatto di tale attacco su una query dinamica. Questo esercizio dimostra la vulnerabilità di un’applicazione web che costruisce query SQL dinamicamente, combinando stringhe in modo insicuro.\nEsercizio: Iniezione SQL di Tipo Stringa\nImmaginiamo di avere una query SQL costruita dinamicamente nel codice di un’applicazione web, simile all’esempio fornito. Questa pratica di costruire query concatenando stringhe rende l’applicazione vulnerabile agli attacchi di iniezione SQL di tipo stringa.\nQuery Vulnerabile:\n&quot;SELECT * FROM user_data WHERE first_name = &#039;John&#039; AND last_name = &#039;&quot; + lastName + &quot;&#039;&quot;;\nIn questa query, lastName è una variabile che contiene l’input dell’utente. Se l’input non viene sanificato o filtrato adeguatamente, un attaccante può iniettare SQL malevolo.\nObiettivo dell’Esercizio:\nUtilizzare il form sottostante per recuperare tutti gli utenti dalla tabella user_data, senza necessità di conoscere un nome utente specifico.\nSoluzione Vulnerabile:\nPer eseguire un attacco e recuperare tutti gli utenti, un attaccante potrebbe inserire un valore per lastName che chiuda la query precedente e ne inserisca una nuova o alteri il comportamento della query originale. Un esempio di input malevolo potrebbe essere:\n&#039; OR &#039;1&#039;=&#039;1\n\nL’inserimento di questo input modificherebbe la query in:\nSELECT * FROM user_data WHERE first_name = &#039;John&#039; AND last_name = &#039;&#039; OR &#039;1&#039;=&#039;1&#039;;\nQuesto causa l’esecuzione di una condizione sempre vera (&#039;1&#039;=&#039;1&#039;), risultando nella restituzione di tutti i record dalla tabella user_data, indipendentemente dal valore dei campi first_name o last_name.\nDiscussione:\nQuesto esercizio dimostra la pericolosità di costruire query SQL dinamicamente senza adeguati controlli o sanificazioni sull’input dell’utente. L’iniezione di stringhe SQL può portare alla divulgazione di informazioni sensibili, alla modifica non autorizzata dei dati o ad altre conseguenze dannose.\nNella sezione sulla Numeric SQL Injection della nostra dispensa, ci concentriamo su un esercizio pratico che dimostra come un’applicazione web possa essere vulnerabile agli attacchi di iniezione SQL numerica a causa della costruzione dinamica delle query SQL. Questo tipo di vulnerabilità si verifica quando l’input dell’utente, che dovrebbe essere un numero, viene concatenato direttamente in una query SQL senza adeguati controlli o sanificazioni.\nNumeric SQL Injection\nConsideriamo una query SQL costruita dinamicamente che utilizza l’input numerico dell’utente:\n&quot;SELECT * FROM user_data WHERE login_count = &quot; + Login_Count + &quot; AND userid = &quot; + User_ID;\nIn questa query, Login_Count e User_ID sono valori forniti dall’utente. Senza adeguata validazione o sanificazione, un attaccante può inserire valori malevoli per manipolare la query.\nObiettivo dell’Esercizio:\nUtilizzare i due campi di input forniti per recuperare tutti i dati dalla tabella user_data, identificando quale dei due campi è vulnerabile all’iniezione SQL numerica per recuperare con successo tutti i dati.\nIdentificazione della Vulnerabilità:\nPer determinare quale campo è suscettibile all’iniezione SQL numerica, consideriamo che l’iniezione avviene quando l’input atteso è un numero. Un attaccante potrebbe inserire un input come 0 OR 1=1 per alterare la logica della query. Questo input forzerebbe la query a restituire tutti i record dalla tabella, ignorando le condizioni originali.\nLogin_Count: [lasciato vuoto o un valore valido]\nUser_ID: 0 OR 1=1\n\nCiò modificherebbe la query in:\nSELECT * FROM user_data WHERE login_count = [Login_Count] AND userid = 0 OR 1=1;\nQuesta manipolazione sfrutta la priorità degli operatori e la logica delle condizioni nelle query SQL. La condizione 1=1 è universalmente vera, quindi l’uso di OR 1=1 dopo userid = 0 rende l’intera condizione WHERE vera per ogni riga nella tabella, indipendentemente dai valori di login_count e User_ID. L’attacco non funzionerebbe invertendo i valori, in quanto l’OR sarebbe in mezzo all’espressione booleana, e quindi verrebbe comunque effettuato alla fine un AND che mi rende falsa l’espressione.\nNella nostra dispensa che esplora come un’iniezione SQL possa compromettere la riservatezza dei dati, ci concentriamo su un esempio pratico che illustra l’uso dell’iniezione SQL di tipo stringa per accedere a dati sensibili. Questo esercizio aiuta a comprendere come le vulnerabilità di sicurezza possano essere sfruttate per violare la confidenzialità dei dati all’interno di un sistema.\nSQL Injection per compromettere la triade CIA\nConfidentiality (C): Compromissione della Riservatezza tramite Iniezione SQL di Tipo Stringa\nL’iniezione SQL di tipo stringa si verifica quando un’applicazione costruisce query SQL concatenando direttamente input forniti dall’utente, senza adeguata sanificazione o preparazione. Questo approccio rende l’applicazione vulnerabile, permettendo agli attaccanti di modificare il comportamento delle query SQL inserendo appositamente sequenze di caratteri malevoli.\nScenario Pratico: Accesso ai Dati dei Colleghi\nSituazione: Sei un dipendente di nome John Smith in una grande azienda che dispone di un sistema interno per visualizzare i dati interni dei dipendenti, come il dipartimento di appartenenza e lo stipendio, utilizzando un TAN di autenticazione unico.\nObiettivo: Vuoi esplorare il sistema per visualizzare i dati di tutti i tuoi colleghi, non solo i tuoi, per confrontare gli stipendi.\nVulnerabilità Sfruttata: La query SQL che gestisce la tua richiesta è vulnerabile all’iniezione SQL:\n&quot;SELECT * FROM employees WHERE last_name = &#039;&quot; + name + &quot;&#039; AND auth_tan = &#039;&quot; + auth_tan + &quot;&#039;&quot;;\nApproccio di Iniezione:\nPer sfruttare questa vulnerabilità, inserisci un input che termini la query SQL corrente e ne modifichi il comportamento per restituire i dati di tutti i dipendenti. Un esempio di input malevolo potrebbe essere:\nname: &#039; OR &#039;1&#039;=&#039;1\nQuesto approccio utilizza l’iniezione di &#039; OR &#039;1&#039;=&#039;1 per creare una condizione sempre vera, ignorando i controlli su last_name e auth_tan.\nRisultato Atteso\nLa query modificata ignora i criteri di autenticazione e seleziona tutti i record dalla tabella employees, esponendo i dati sensibili di tutti i dipendenti, inclusi i dettagli sugli stipendi.\nNella nostra dispensa che esplora le vulnerabilità di sicurezza nelle applicazioni web, il focus ora si sposta sulla compromissione dell’integrità dei dati attraverso l’uso di SQL query chaining. Questa tecnica di attacco permette agli aggressori di eseguire più istruzioni SQL in un’unica operazione, potenzialmente alterando o distruggendo dati critici.\nIntegrity (I): Compromissione dell’Integrità tramite Query Chaining\nDefinizione di Query Chaining:\nIl chaining di query SQL si riferisce alla pratica di aggiungere una o più istruzioni SQL alla fine di una query effettiva, utilizzando il carattere ; come delimitatore. Questo carattere segnala la fine di una dichiarazione SQL e l’inizio di un’altra, consentendo agli attaccanti di iniettare ulteriori comandi che possono alterare i dati o la struttura del database.\nScenario Pratico: Modifica dello Stipendio\nNell’esercizio precedente, hai scoperto che i tuoi colleghi Tobi e Bob guadagnano più di te. Motivato da questo, decidi di modificare il tuo stipendio nel sistema per assicurarti di essere il dipendente con lo stipendio più alto.\nInformazioni Conosciute:\n\nIl tuo nome è John Smith.\nIl tuo TAN attuale è 3SL99A.\n\nApproccio di Attacco:\nPer modificare il tuo stipendio utilizzando il chaining di query, dovresti trovare un punto di iniezione che permetta l’esecuzione di più istruzioni SQL. L’obiettivo sarebbe iniettare una query aggiuntiva per aggiornare il tuo stipendio nella tabella employees.\nUn esempio ipotetico di attacco, che non dovrebbe essere tentato o eseguito su sistemi reali senza autorizzazione, potrebbe apparire così:\n&#039;; UPDATE employees SET salary = &#039;100000&#039; WHERE last_name = &#039;Smith&#039; AND auth_tan = &#039;3SL99A&#039;; --\nQuesta iniezione ipotetica si conclude con il termine della query originale (&#039;), seguito da un punto e virgola (;) per iniziare una nuova istruzione. La nuova istruzione UPDATE modifica lo stipendio per l’utente specificato (in questo caso, John Smith con TAN 3SL99A), e infine, un commento SQL (--) è usato per ignorare il resto della query originale e prevenire errori di sintassi.\nAvailability (A): Compromissione della Disponibilità tramite Iniezione SQL\nLa sezione della nostra dispensa su SQL Injection si focalizza ora sulla compromissione della disponibilità dei dati, l’ultimo elemento della triade CIA (Confidenzialità, Integrità, Disponibilità). Questa fase dimostra come un attacco di iniezione SQL possa essere utilizzato per rendere i dati inaccessibili, violando così la disponibilità.\nViolare la disponibilità significa rendere i dati inaccessibili agli utenti legittimi. Ciò può avvenire attraverso diverse tecniche, tra cui la modifica delle credenziali di accesso, l’eliminazione di account, dati o intere tabelle del database, o la revoca dei diritti di accesso. Un attaccante potrebbe, ad esempio, eliminare la tabella access_log per nascondere le tracce delle sue azioni.\nEsempio Pratico: Eliminazione della Tabella access_log\nDopo aver compromesso la confidenzialità e l’integrità dei dati nelle lezioni precedenti, scopri l’esistenza di una tabella access_log che registra tutte le tue azioni. Per evitare che le tue manipolazioni vengano scoperte, decidi di eliminare completamente questa tabella.\nTecnica di Attacco: Query Chaining\nIl “Query Chaining” consente di eseguire più query SQL in sequenza, separate da un punto e virgola (;). Questa tecnica può essere sfruttata per appendere una query di eliminazione alla query originale, con l’obiettivo di eliminare la tabella access_log.\nInput Malevolo:\nSupponiamo che l’applicazione vulnerabile permetta l’inserimento di input non sanificati in una forma che poi viene utilizzata per costruire dinamicamente una query SQL. Per eliminare la tabella access_log, potresti inserire:\n&#039;; DROP TABLE access_log; --\n\nQuesto input termina la query SQL originale (usando &#039;;), esegue il comando DROP TABLE access_log per eliminare la tabella e infine utilizza -- per commentare il resto della query, prevenendo errori di sintassi dovuti a eventuali segmenti rimanenti della query originale.\nTecniche avanzate\nIntroduzione\nGli attacchi SQL Injection possono essere molto sofisticati e vengono eseguiti in diverse forme, tra cui:\n\nSQL Injection Classica: L’attaccante sfrutta input non sanificati per alterare la struttura della query SQL, potenzialmente esponendo dati sensibili.\nBlind SQL Injection (Iniezione SQL Cieca): Anche senza visualizzare direttamente i risultati di una query, un attaccante può dedurre informazioni sensibili tramite domande di vero/falso inviate al database.\nIniezione SQL Basata su Errori: Tramite messaggi di errore dettagliati forniti dall’applicazione, gli attaccanti possono ottenere informazioni preziose sul database.\nIniezione SQL di Secondo Ordine: Questo avviene quando i dati forniti dall’utente vengono memorizzati e poi eseguiti in seguito come una query SQL.\n\nPer mitigare il rischio di attacchi SQL Injection, gli sviluppatori devono adottare pratiche di programmazione sicura, come l’utilizzo di query parametrizzate, la sanificazione dell’input dell’utente e l’implementazione di principi di minimo privilegio per l’accesso al database. La consapevolezza e la comprensione di come funzionano gli attacchi SQL Injection sono fondamentali per la sicurezza delle applicazioni web moderne.\nCaratteri speciali e statement speciali\nQuesta sezione copre l’uso di caratteri speciali e dichiarazioni nell’ambito delle iniezioni SQL, offrendo strumenti potenti per manipolare e accedere ai dati in modi non previsti dall’applicazione. Ecco un’elaborazione e integrazione basata sulle informazioni fornite:\nCaratteri Speciali nelle SQL Injection\n\n\nCommenti Inline (/* */) e di Linea (--, #): Sono utilizzati per terminare prematuramente una query, permettendo all’attaccante di inserire parti di query che possono ignorare i controlli di sicurezza o le parti della query originale dopo l’iniezione.\n\n\nConcatenazione di Stringhe (&#039;, +, ||): Questi operatori consentono di unire stringhe diverse per creare input malevoli. La capacità di concatenare stringhe può essere sfruttata per costruire query SQL dannose in modo dinamico.\n\n\nUso di Char() per Evitare Quotazioni: Questa funzione consente di inserire caratteri speciali o riservati in una query senza l’uso diretto di apici, bypassando alcuni tipi di filtraggio input.\n\n\nChaining di Query con ;: Permette di eseguire più comandi SQL in una sola volta. Questo può essere particolarmente distruttivo se l’attaccante riesce a inserire comandi come DROP TABLE, che possono eliminare interi set di dati.\n\n\nDichiarazioni Speciali\n\n\nUNION: Utilizzato per combinare i risultati di due o più comandi SELECT in un unico set di risultati. L’operatore UNION richiede che ogni query SELECT nell’unione abbia lo stesso numero di colonne nei risultati, con tipi di dati compatibili. Questo può essere usato in un attacco SQL Injection per estrarre dati da diverse tabelle in un’unica query.\n\n\nUNION ALL: A differenza di UNION, UNION ALL permette di includere valori duplicati nei risultati. Questo può essere utile in scenari di attacco dove l’aggregazione di dati da diverse fonti, anche con ripetizioni, è desiderata.\n\n\nJOIN: È utilizzato per combinare le righe di due o più tabelle basate su una colonna relazionata tra loro. Attraverso tecniche di iniezione che sfruttano i JOIN, gli attaccanti possono ottenere informazioni correlate da diverse tabelle, aumentando l’ampiezza dell’attacco.\n\n\nPer informazioni più dettagliate sulla join visita: www.w3schools.com/sql/sql_join.asp\nEsercizio: Estrazione di Dati tramite SQL Injection\nObiettivo: Utilizzare le tecniche di SQL Injection per recuperare dati sensibili da una tabella non direttamente esposta attraverso l’input dell’utente in un’applicazione web simulata.\nScenario: Immagina di essere un tester per la sicurezza incaricato di valutare la vulnerabilità di un’applicazione web agli attacchi SQL Injection. Durante il tuo testing, hai identificato un campo di input che accetta il cognome degli utenti come input e lo utilizza per eseguire una query SQL alla tabella user_data. La struttura delle tabelle interessate è la seguente:\n\n\nTabella user_data:\nCREATE TABLE user_data (\n  userid int not null,\n  first_name varchar(20),\n  last_name varchar(20),\n  cc_number varchar(30),\n  cc_type varchar(10),\n  cookie varchar(20),\n  login_count int\n);\n\n\n\nTabella user_system_data:\nCREATE TABLE user_system_data (\n  userid int not null primary key,\n  user_name varchar(12),\n  password varchar(10),\n  cookie varchar(30)\n);\n\n\n\nCompiti:\n\n\nEstrazione di Tutti i Dati: Sfrutta la vulnerabilità SQL Injection per estrarre tutti i dati dalla tabella user_system_data. Considera l’uso della clausola UNION o l’apposizione di un nuovo comando SQL.\n\n\nRecupero di una Password Specifica: Una volta che sei in grado di estrarre dati dalla tabella user_system_data, identifica la password dell’utente Dave.\n\n\nSuggerimenti:\n\nAssicurati che il numero di colonne selezionate con UNION corrisponda tra le tabelle.\nRicorda che alcuni sistemi di gestione del database potrebbero non permettere l’esecuzione di più statement SQL separati da ;.\n\nNota Etica: Questo esercizio è destinato esclusivamente a scopi educativi e di formazione sulla sicurezza. Non tentare di applicare queste tecniche su applicazioni o database senza esplicita autorizzazione.\nQuesto testo fornisce una panoramica chiara e un contesto per l’esercizio, incoraggiando l’apprendimento e la consapevolezza delle vulnerabilità di sicurezza senza promuovere azioni non etiche o illegali.\nUtilizzo di UNION\nPer estrarre dati da un’altra tabella utilizzando UNION, l’attaccante deve prima assicurarsi che il numero di colonne selezionate nella query iniettata corrisponda al numero di colonne nella query originale. In questo scenario, l’obiettivo è ottenere informazioni dalla tabella user_system_data.\n\n\nAnalizzare la Query Originale: La query vulnerabile potrebbe assomigliare a qualcosa del tipo: SELECT * FROM user_data WHERE last_name = &#039;&lt;input dell&#039;utente&gt;&#039;;. L’input dell’utente è il punto di iniezione.\n\n\nCostruire la Query Iniettata: Utilizzando UNION, l’attaccante può aggiungere una seconda query SELECT che estrae dati dalla tabella user_system_data. Per fare ciò, deve assicurarsi di selezionare lo stesso numero di colonne presenti nella tabella user_data e di usare valori fittizi o null per mantenere l’allineamento delle colonne, se necessario.\n\n\nAppendere un Nuovo Statement SQL\nUn’altra tecnica consiste nell’appendere un nuovo comando SQL alla query originale, spesso utilizzando il carattere ; per separare le due istruzioni. Tuttavia, questo approccio dipende dalla possibilità di eseguire più comandi SQL in una singola istruzione, che potrebbe essere limitata in base alla configurazione del database o dell’interfaccia applicativa.\nConsiderazioni sulla Sicurezza\nQuesti esempi dimostrano la pericolosità delle vulnerabilità SQL Injection e sottolineano l’importanza di adottare misure di sicurezza adeguate, come:\n\nUtilizzare Query Parametrizzate: Previene l’iniezione SQL trattando i dati di input come parametri separati dal codice SQL.\nSanificare l’Input: Rimuovere o neutralizzare caratteri speciali dall’input utente.\nLimitare i Privilegi: Assicurarsi che l’account del database usato dall’applicazione abbia solo i privilegi necessari per le sue funzioni.\nUsare ORM (Object Relational Mapping): Molti ORM moderni utilizzano query parametrizzate per prevenire le iniezioni SQL.\n\nMitigation delle SQL Injection\nLe tecniche descritte sono metodologie per prevenire o ridurre il rischio di attacchi di iniezione SQL, un tipo di vulnerabilità di sicurezza che permette a un aggressore di interferire con le query che un’applicazione invia al suo database. Esaminiamo queste tecniche più da vicino.\nQuery Statiche\nLe query statiche sono esempi di query immutabili. Sono definite in modo esplicito nel codice e non cambiano indipendentemente dai dati forniti dall’utente. Ecco due esempi di query statiche:\n\n\nQuery per selezionare tutti i prodotti:\nString query = &quot;SELECT * FROM products&quot;;\n\n\nQuery per selezionare un utente specifico basandosi sull’ID di sessione (omesso inizialmente, ora incluso):\nString query = &quot;SELECT * FROM users WHERE user = &#039;&quot; + session.getAttribute(&quot;UserID&quot;) + &quot;&#039;&quot;;\n\n\nQuery con Parametri\nLe query parametrizzate sono una tecnica di prevenzione dell’iniezione SQL che separa nettamente i dati delle istruzioni SQL dalla logica di esecuzione delle query. In questo modo, i dati forniti dall’utente vengono gestiti in modo sicuro e non possono modificare la struttura logica della query.\nEsempio di Query Parametrizzata:\nString query = &quot;SELECT * FROM utenti WHERE cognome = ?&quot;;\nPreparedStatement statement = connection.prepareStatement(query);\nstatement.setString(1, nomeAccount);\nResultSet results = statement.executeQuery();\nIn questo caso, ? funge da segnaposto per il valore del parametro che viene impostato in modo sicuro attraverso statement.setString(1, nomeAccount);. Questo metodo garantisce che il valore passato venga sempre trattato come un dato, mai come parte del codice SQL.\nProcedure Memorizzate\nLe procedure memorizzate possono offrire un livello di protezione dall’iniezione SQL, a condizione che non generino SQL dinamico all’interno della procedura stessa. Sono blocchi di codice eseguibili che risiedono nel database e che possono essere invocati dalle applicazioni.\nConsiderazione Importante:\nLe procedure memorizzate devono essere progettate con cura per non introdurre vulnerabilità attraverso l’uso di SQL dinamico, il quale potrebbe esporre a rischi simili a quelli delle query formulate direttamente nell’applicazione.\nIn sintesi, l’uso di query immutabili, parametrizzate e di procedure memorizzate sono tecniche fondamentali per proteggere le applicazioni web dall’iniezione SQL, assicurando che i dati forniti dall’utente siano gestiti in modo sicuro e che non sia possibile per gli aggressori alterare la logica delle query per accedere o manipolare dati sensibili in modo non autorizzato.\nProcedure memorizzate\nLa distinzione tra procedure memorizzate sicure e quelle vulnerabili a iniezioni SQL è fondamentale nella protezione dei database. Di seguito, analizzeremo due esempi specifici relativi a Microsoft SQL Server che illustrano questa differenza.\nProcedure Memorizzate Sicure\nUna procedura memorizzata sicura è progettata in modo tale da evitare la possibilità di iniezione SQL, trattando i dati in ingresso esclusivamente come valori, senza permettere che questi possano influenzare la logica o la struttura della query SQL. Questo approccio impedisce agli attaccanti di inserire o modificare il codice SQL eseguito dal database. Un esempio di procedura memorizzata sicura in Microsoft SQL Server è:\nCREATE PROCEDURE ListCustomers(@Country nvarchar(30))\nAS\nBEGIN\n    SELECT city, COUNT(*)\n    FROM customers\n    WHERE country LIKE @Country\n    GROUP BY city\nEND\nPer eseguire questa procedura memorizzata, si utilizza il seguente comando, dove &#039;USA&#039; è il parametro che viene passato alla procedura:\nEXEC ListCustomers &#039;USA&#039;\nIn questo esempio, il parametro @Country viene utilizzato direttamente nella query in modo sicuro, senza consentire l’interpretazione di eventuali input dannosi come parte del codice SQL.\nProcedure Memorizzate Vulnerabili a Iniezioni\nAl contrario, una procedura memorizzata che genera SQL dinamico e incorpora direttamente i parametri forniti dagli utenti senza una corretta sanificazione o senza utilizzare approcci come le query parametrizzate, può essere vulnerabile alle iniezioni SQL. Questo tipo di procedura può eseguire accidentalmente codice SQL malevolo inserito tramite i parametri. Un esempio di procedura memorizzata vulnerabile a iniezioni SQL in Microsoft SQL Server è:\nCREATE PROCEDURE getUser(@lastName nvarchar(25))\nAS\nBEGIN\n    DECLARE @sql nvarchar(255)\n    SET @sql = &#039;SELECT * FROM users WHERE lastname = &#039;&#039;&#039; + @lastName + &#039;&#039;&#039;&#039;\n    EXEC sp_executesql @sql\nEND\nIn questo esempio, il parametro @lastName viene concatenato direttamente alla stringa SQL. Se un attaccante fornisce un valore per @lastName che include codice SQL malevolo, potrebbe eseguire operazioni non autorizzate sul database, come l’eliminazione di tabelle o l’estrazione di dati sensibili.\nValidazione e Sicurezza del Nome Utente con Query Parametrizzate in Java\nL’utilizzo delle query parametrizzate rappresenta una tecnica essenziale per migliorare la sicurezza delle applicazioni che interagiscono con i database, specialmente per prevenire gli attacchi di iniezione SQL. Questo metodo consente di separare il codice SQL dalla gestione dei dati forniti dall’utente, riducendo i rischi di sicurezza associati.\nValidazione del Nome Utente\nPer assicurarsi che il nome utente sia valido e per prevenire l’iniezione SQL, si può impiegare il seguente frammento di codice Java:\npublic static boolean isUsernameValid(String username) {\n    Regex r = new Regex(&quot;^[A-Za-z0-9]{16}$&quot;);\n    return r.isMatch(username);\n}\n \n// La connessione java.sql.Connection conn viene impostata altrove per brevità.\nPreparedStatement ps = null;\nResultSet rs = null;\ntry {\n    String pUsername = request.getParameter(&quot;UserName&quot;);\n    if (isUsernameValid(pUsername)) {\n        ps = conn.prepareStatement(&quot;SELECT * FROM user_table WHERE username = ?&quot;);\n        ps.setString(1, pUsername);\n        rs = ps.executeQuery();\n        if (rs.next()) {\n            // Esegue il lavoro per rendere attivo il record dell&#039;utente in qualche modo\n        }\n    } else {\n        // Gestisce l&#039;input non valido\n    }\n} catch (Exception e) {\n    // Gestisce tutte le eccezioni\n}\nUso Corretto delle Query Parametrizzate per l’Inserimento dei Dati\nL’adozione di pratiche corrette nell’utilizzo delle query parametrizzate è fondamentale per prevenire vulnerabilità come l’iniezione SQL. È importante impostare i parametri con i metodi ps.set...() ed evitare la costruzione di stringhe SQL dinamiche basate sull’input dell’utente. Di seguito sono presentati esempi di uso non corretto e uso corretto per l’inserimento dei dati:\n\n\nUso non corretto: (Questo approccio va evitato poiché può esporre a vulnerabilità di sicurezza)\nString insertStatement = String.format(&quot;INSERT INTO USERS (id, name, email) VALUES (%s, %s, %s)&quot;, &quot;1&quot;, &quot;webgoat&quot;, &quot;webgoat@owasp.org&quot;);\nPreparedStatement statement = conn.prepareStatement(insertStatement);\nstatement.executeUpdate();\n\n\nUso corretto: (Questo è l’approccio consigliato per mantenere l’integrità e la sicurezza dei dati)\nPreparedStatement statement = conn.prepareStatement(&quot;INSERT INTO USERS (id, name, email) VALUES (?, ?, ?)&quot;);\nstatement.setString(1, &quot;1&quot;);\nstatement.setString(2, &quot;webgoat&quot;);\nstatement.setString(3, &quot;webgoat@owasp.org&quot;);\nstatement.executeUpdate();\n\n\nSeguendo le migliori pratiche per la validazione dell’input e l’uso appropriato dei PreparedStatement, gli sviluppatori possono efficacemente mitigare i rischi di iniezione SQL e migliorare la sicurezza delle loro applicazioni.\nEsempio di Query Parametrizzata in Java\nQuesto esempio illustra l’uso delle query parametrizzate in Java per migliorare la sicurezza e l’efficienza nella gestione dei dati di un database. Le query parametrizzate sono fondamentali per prevenire attacchi di iniezione SQL, garantendo che i dati forniti dagli utenti siano trattati in modo sicuro.\nDescrizione del Codice\nIl seguente frammento di codice dimostra come caricare dati relativi a un account utilizzando una query parametrizzata:\npublic static String loadAccount() {\n  // Il parser ritorna solo dati stringa validi\n  String accountID = getParser().getStringParameter(ACCT_ID, &quot;&quot;);\n  String data = null;\n  String query = &quot;SELECT first_name, last_name, acct_id, balance FROM user_data WHERE acct_id = ?&quot;;\n  try (Connection connection = dataSource.getConnection();\n       PreparedStatement statement = connection.prepareStatement(query)) {\n     statement.setString(1, accountID);\n     ResultSet results = statement.executeQuery();\n     if (results != null &amp;&amp; results.first()) {\n       results.last(); // Dovrebbe essere restituito solo un record per questa query\n       if (results.getRow() &lt;= 2) {\n         data = processAccount(results);\n       } else {\n         // Gestione dell&#039;errore - Problema di integrità del database\n       }\n     } else {\n       // Gestione dell&#039;errore - nessun record trovato\n     }\n  } catch (SQLException sqle) {\n    // Log e gestione dell&#039;SQL Exception\n  }\n  return data;\n}\nSpiegazione del Processo\n\n\nValidazione dell’Input: Prima di tutto, il codice assicura che l’ID dell’account fornito sia un dato valido tramite un metodo di parsing. Questo passaggio è cruciale per evitare iniezioni SQL.\n\n\nPreparazione della Query: La query SQL è definita con un placeholder (?) per l’ID dell’account. Questo metodo impedisce l’esecuzione di codice SQL malevolo.\n\n\nImpostazione dei Parametri: Il valore dell’ID dell’account è impostato come parametro della query tramite statement.setString(1, accountID). Questo approccio mantiene separati il codice SQL e i dati forniti dall’utente.\n\n\nEsecuzione della Query e Gestione dei Risultati: La query viene eseguita e, se trovato, il record dell’account viene processato. Il codice gestisce anche le situazioni in cui non vengono trovati record o si verifica un problema di integrità del database.\n\n\nGestione delle Eccezioni: Infine, le eccezioni SQL sono catturate e gestite adeguatamente, permettendo al programma di reagire in modo appropriato agli errori di connessione o esecuzione della query.\n\n\nL’uso delle query parametrizzate, come mostrato in questo esempio, è essenziale per costruire applicazioni sicure che interagiscono con database, riducendo il rischio di vulnerabilità legate all’iniezione SQL e garantendo l’integrità dei dati.\nEsercizio 1\nPer completare il codice in modo sicuro ed efficiente, prevenendo vulnerabilità come le iniezioni SQL, utilizzeremo l’approccio delle query parametrizzate. Questo metodo consente di inserire i valori delle variabili in modo sicuro, senza il rischio che input dannosi possano essere interpretati come parte del codice SQL. Di seguito, il codice completato con l’utilizzo di PreparedStatement, una classe che facilita l’uso di query parametrizzate in Java.\n// Assumiamo che DBURL, DBUSER, e DBPW siano definiti altrove nel codice.\nConnection conn = DriverManager.getConnection(DBURL, DBUSER, DBPW);\n \n// Preparazione della query SQL con parametri.\nString sql = &quot;SELECT status FROM users WHERE name=? AND mail=?&quot;;\nPreparedStatement statement = conn.prepareStatement(sql);\n \n// Assumiamo che &#039;userName&#039; e &#039;userMail&#039; siano le variabili che contengono\n// i valori per il nome e l&#039;indirizzo mail dell&#039;utente.\n// Si deve prestare attenzione a sanificare questi input se provengono dall&#039;esterno.\nstatement.setString(1, userName);\nstatement.setString(2, userMail);\n \n// Esecuzione della query.\nResultSet resultSet = statement.executeQuery();\n \n// Processamento dei risultati.\nif (resultSet.next()) {\n    String status = resultSet.getString(&quot;status&quot;);\n    // Qui si può gestire lo stato dell&#039;utente come necessario.\n} else {\n    // Gestione del caso in cui non vengono trovati record corrispondenti.\n}\n \n// Si ricorda di chiudere le risorse una volta che non sono più necessarie\n// per evitare leak di memoria. Questo può essere fatto automaticamente\n// usando il try-with-resources o manualmente nel blocco finally.\nSpiegazioni Importanti:\n\n\nCreazione della Connessione: Utilizziamo DriverManager.getConnection con i parametri appropriati (DBURL, DBUSER, DBPW) per stabilire una connessione al database.\n\n\nPreparazione della Query: Definiamo una stringa SQL con dei placeholder (?) per i parametri che vogliamo inserire in modo sicuro. Successivamente, creiamo un PreparedStatement a partire da questa stringa.\n\n\nImpostazione dei Parametri: Con statement.setString(index, value), impostiamo i valori di userName e userMail nei posti corretti all’interno della query. Questo passaggio previene le iniezioni SQL poiché i valori sono trattati esclusivamente come dati, senza essere interpretati come parte del comando SQL.\n\n\nEsecuzione e Gestione dei Risultati: Eseguiamo la query con statement.executeQuery() e processiamo i risultati ottenuti. È importante gestire anche il caso in cui non si ottengano risultati.\n\n\nGestione delle Risorse: È buona pratica assicurarsi che tutte le risorse utilizzate (come oggetti Connection, PreparedStatement e ResultSet) siano chiuse dopo il loro uso per evitare perdite di risorse. Nel codice sopra, questo aspetto va gestito adeguatamente nel contesto dell’applicazione.\n\n\nQuesto approccio garantisce che l’applicazione sia protetta da attacchi di iniezione SQL, mantenendo al contempo una struttura di codice chiara e manutenibile.\nQuery Parametrizzate in .NET\nNell’esempio fornito, viene dimostrato come utilizzare le query parametrizzate in un contesto .NET per accedere ai dati in modo sicuro, prevenendo attacchi di iniezione SQL. Questo approccio è essenziale per proteggere le applicazioni .NET che interagiscono con database SQL.\nDescrizione del Codice\nIl codice verifica prima la validità del nome utente utilizzando una espressione regolare. Successivamente, prepara e esegue una query SQL parametrizzata per selezionare i dati dall’utente specificato. Qui di seguito è riportato il codice corretto e leggermente modificato per migliorarne la leggibilità e la correttezza sintattica:\npublic static bool IsUsernameValid(string username) {\n    Regex r = new Regex(&quot;^[A-Za-z0-9]{1,16}$&quot;); // Modifica per consentire nomi utente fino a 16 caratteri\n    return r.IsMatch(username); // Corretto in IsMatch\n}\n \n// SqlConnection conn è impostata e aperta altrove per brevità.\ntry {\n    string selectString = &quot;SELECT * FROM user_table WHERE username = @userID&quot;;\n    SqlCommand cmd = new SqlCommand(selectString, conn);\n    string uid = &quot;someUsername&quot;; // Assumiamo che uid sia il nome utente da verificare\n    if (IsUsernameValid(uid)) {\n        cmd.Parameters.Add(&quot;@userID&quot;, SqlDbType.VarChar, 16).Value = uid;\n        using (SqlDataReader myReader = cmd.ExecuteReader()) {\n            if (myReader.HasRows) {\n                // Rendi il record dell&#039;utente attivo in qualche modo.\n            }\n            myReader.Close();\n        }\n    } else {\n        // Gestisci input non valido\n    }\n}\ncatch (Exception e) {\n    // Gestisci tutte le eccezioni...\n}\nPunti Chiave\n\n\nValidazione dell’input: Prima di eseguire la query, il nome utente viene validato utilizzando un’espressione regolare. Questo aiuta a prevenire attacchi di iniezione basati su input non validi.\n\n\nUso di query parametrizzate: La query SQL utilizza un parametro (@userID) al posto di concatenare direttamente il nome utente nella stringa di query. Questo parametro viene poi valorizzato con il nome utente validato, prevenendo così efficacemente l’iniezione SQL.\n\n\nGestione delle risorse: L’uso della parola chiave using assicura che l’oggetto SqlDataReader venga chiuso e rilasciato correttamente, anche in caso di eccezioni.\n\n\nGestione delle eccezioni: Tutte le potenziali eccezioni generate durante l’esecuzione della query o la connessione al database sono catturate e possono essere gestite in modo appropriato.\n\n\nQuesto esempio illustra come scrivere codice sicuro e robusto per operazioni di database in un’applicazione .NET, utilizzando pratiche consigliate come la validazione dell’input e le query parametrizzate.\nNecessità della Validazione degli Input\nAnche se le tue query sono protette contro le iniezioni SQL grazie all’uso di query parametrizzate, la validazione degli input rimane una pratica essenziale nella sicurezza informatica. La validazione degli input serve non solo a prevenire iniezioni SQL, ma anche a proteggere l’applicazione da una varietà di altre vulnerabilità e attacchi. Di seguito, alcuni motivi per cui è importante continuare a validare gli input:\nPrevenzione di Altri Tipi di Attacchi\n\n\nStored XSS (Cross-Site Scripting): Senza una valida sanificazione e validazione degli input, un attaccante potrebbe inserire script dannosi nel database, che poi vengono eseguiti nel browser dell’utente quando i dati vengono visualizzati. La validazione degli input aiuta a prevenire l’inserimento di questi script.\n\n\nFuga di Informazioni: Input non validati potrebbero essere usati per esfiltrare dati sensibili dall’applicazione o dal sistema sottostante. Ad esempio, un input malevolo potrebbe essere progettato per rivelare informazioni sulla struttura del database o sui dati degli utenti.\n\n\nMantenimento dell’Integrità Logica e dei Dati\n\n\nErrori Logici e Validazione delle Regole di Business: La validazione degli input è fondamentale per assicurarsi che i dati inseriti nell’applicazione rispettino le regole di business e la logica applicativa. Ad esempio, un campo che dovrebbe accettare solo valori numerici potrebbe causare errori logici o di calcolo se vengono inseriti testi o caratteri speciali.\n\n\nIniezione SQL: Sebbene le query parametrizzate siano una difesa efficace contro l’iniezione SQL, la validazione degli input fornisce un ulteriore livello di sicurezza. Inoltre, in alcune situazioni particolari o con configurazioni specifiche del database, potrebbero esistere ancora vettori per iniezioni SQL che la validazione degli input può contribuire a mitigare.\n\n\nConsiderazione del Database Come Entità Fiduciaria\nSpesso il database viene considerato una parte fiduciaria del sistema. Ciò significa che i dati al suo interno si presume siano accurati, validi e sicuri. La validazione degli input contribuisce a mantenere questa fiducia, assicurando che solo dati validi e previsti siano inseriti nel database. Questo approccio protegge non solo l’applicazione ma anche l’integrità dei dati e la fiducia degli utenti.\nValidazione degli Input: Un Primo Passo Necessario ma Non Sufficiente\nLa validazione degli input è un passo critico per garantire che solo dati corretti e attesi siano accettati dall’applicazione. Questo può includere la verifica che un numero telefonico contenga solo cifre, che un indirizzo email segua il formato standard, o che una stringa di testo non contenga caratteri speciali potenzialmente pericolosi. Tuttavia, anche la più robusta validazione degli input può essere aggirata o può fallire in scenari non previsti.\nAd esempio, un filtro che permette solo lettere e numeri per evitare iniezioni SQL potrebbe essere considerato sicuro. Tuttavia, se la logica di validazione non tiene conto di tutti i contesti possibili o di tecniche di attacco innovative, potrebbero esserci delle lacune. Un attaccante potrebbe scoprire un modo per sfruttare un input apparentemente innocuo che passa la validazione ma che, a causa di particolari condizioni o vulnerabilità del sistema sottostante, porta a un’iniezione SQL o ad altri attacchi.\nL’Importanza delle Query Parametrizzate\nLe query parametrizzate risolvono il problema alla radice trattando i dati di input separatamente dal codice SQL. Con le query parametrizzate, l’input dell’utente viene sempre trattato come dati, mai come parte del codice SQL, indipendentemente dalla sua forma. Questo elimina la possibilità che l’input venga interpretato in modo errato come istruzione SQL dal database, prevenendo così le iniezioni SQL.\nDebolezze dell’Approccio di Solo Filtraggio\nAffidarsi esclusivamente alla validazione o al filtraggio degli input per prevenire le iniezioni SQL presenta diverse debolezze:\n\n\nComplessità del Filtraggio: Determinare un set completo di regole di validazione che copra tutti i possibili vettori di attacco può essere estremamente complesso e soggetto a errori.\n\n\nVariabilità degli Ambienti di Esecuzione: Differenze nell’interpretazione dei comandi SQL tra diversi sistemi di gestione del database possono rendere alcuni filtri inefficaci in specifici contesti.\n\n\nEvoluzione delle Tecniche di Attacco: Gli attaccanti sviluppano continuamente nuove tecniche per aggirare i filtri esistenti. Senza un aggiornamento costante, i filtri possono diventare obsoleti.\n\n\nNell’esercizio mostrato, è presente un filtro che non permette all’utente di inserire degli spazi. Tuttavia questo filtro è facilmente bypassabile utilizzando dei commenti al posto degli spazi:\na&#039;/**/union/**/select/**/user_system_data.*,&#039;1&#039;,&#039;1&#039;,1/**/from/**/user_system_data;--\n\nNell’esercizio successivo, si nota che il form rimuove le parole chiave select e from. Tuttavia, si può ingannare l’algoritmo scrivendo la parola select dentro select, in modo tale che una volta che quello interno viene eliminato dal filtro, rimane quello esterno:\n/**/ &lt;-- HSQLDB comment instead of white space  \nselselectect &lt;-- instead of &#039;select&#039;  \nfrfromom &lt;-- instead of &#039;from&#039;\n\nProtezione dalle Iniezioni SQL e Uso delle Query Parametrizzate nella Clausola ORDER BY\nLe iniezioni SQL rappresentano una minaccia significativa per la sicurezza delle applicazioni web, permettendo agli aggressori di manipolare le query SQL per accedere o alterare i dati in modi non autorizzati. Una domanda comune riguarda l’efficacia delle query parametrizzate nel prevenire queste iniezioni, specialmente in contesti come l’uso dinamico della clausola ORDER BY.\nIl Problema con la Clausola ORDER BY\nConsideriamo il seguente esempio di codice SQL, dove il nome della colonna di ordinamento (sortColumnName) viene inserito direttamente nella query:\n&quot;SELECT * FROM users ORDER BY &quot; + sortColumnName + &quot;;&quot;\nA prima vista, potrebbe sembrare che l’uso di query parametrizzate possa prevenire efficacemente le iniezioni SQL in casi come questo. Tuttavia, la specifica grammaticale SQL mostra che una orderExpression nella clausola ORDER BY può essere molto più di un semplice nome di colonna; può essere un’espressione complessa, inclusa una funzione. Ciò significa che, attraverso un’espressione ingegnosa, un attaccante potrebbe inserire logica condizionale o altre funzioni SQL che potrebbero essere sfruttate per scopi malevoli.\nEsempio di Iniezione nella Clausola ORDER BY\nSELECT * FROM users ORDER BY (CASE WHEN (TRUE) THEN lastname ELSE firstname END);\nIn questo esempio, l’iniezione tramite la clausola ORDER BY sfrutta la capacità di SQL di eseguire espressioni condizionali. Anche se il nome della colonna viene parametrizzato, un attaccante potrebbe tentare di inserire espressioni o funzioni complesse che non sono intese per l’uso previsto della query.\nMisure di Mitigazione\nPer mitigare i rischi associati alle iniezioni tramite la clausola ORDER BY, si consiglia di adottare un approccio basato su una lista di controllo (whitelist) per i nomi delle colonne consentite per l’ordinamento. Ecco alcune linee guida:\n\n\nImplementare una Lista di Controllo: Prima di costruire la query SQL, verificare che il nome della colonna fornito per l’ordinamento corrisponda a uno dei valori consentiti definiti in una lista di controllo. Questo limita l’ordinamento alle colonne predefinite come ‘firstname’ o ‘lastname’, riducendo il rischio di manipolazioni non autorizzate della query.\n\n\nEvitare l’Inserimento Diretto: Non inserire mai direttamente input dell’utente nella query SQL senza una validazione adeguata. Anche quando si utilizzano query parametrizzate, è essenziale assicurarsi che ogni parte dinamica della query sia rigorosamente controllata.\n\n\nValidazione e Sanificazione dell’Input: Oltre all’uso di una lista di controllo, è utile implementare una robusta logica di validazione e sanificazione per qualsiasi input che influenzi la logica SQL, compresi i nomi delle colonne e i valori di ordinamento.\n\n\nPrincipio del Minimo Privilegio nelle Connessioni al Database\nIl principio del minimo privilegio è una pratica di sicurezza essenziale nella gestione degli accessi alle risorse informatiche, inclusi i database. Questo principio implica che un account, un programma o un processo operativo dovrebbe avere esclusivamente le autorizzazioni necessarie per svolgere i suoi compiti, niente di più. Nel contesto di un’applicazione che si connette a un database, l’implementazione di questo principio può significativamente ridurre il rischio di danni accidentali o malevoli, limitando le potenziali azioni che possono essere eseguite.\nConnessione con Set Minimo di Privilegi\nDistinzione di Fiducia e Credenziali Differenziate\n\nCredenziali Differenziate: L’applicazione dovrebbe stabilire connessioni al database utilizzando credenziali diverse a seconda del livello di fiducia e delle esigenze specifiche di accesso. Questo approccio implica la creazione di account di database separati per differenti contesti operativi, ad esempio, per lettura, scrittura o esecuzione di procedure memorizzate.\n\nLimitazione dei Diritti di Eliminazione\n\nDiritti Limitati: È raro che un’applicazione necessiti di diritti di eliminazione su una tabella o su un database intero. Limitare i permessi ai soli necessari riduce il rischio di perdita di dati accidentale o di attacchi che mirano a danneggiare o compromettere l’integrità del database.\n\nGestione degli Accessi allo Schema\n\nAccesso Limitato allo Schema: Gli account di database dovrebbero avere accesso limitato agli schemi di cui necessitano. Questo limita l’esposizione e il rischio in caso di compromissione delle credenziali.\n\nAccount di Database per Accesso in Lettura e Scrittura\n\nDefinizione di Account Specifici: Creare account di database dedicati per l’accesso in lettura e per l’accesso in lettura/scrittura. Questa distinzione garantisce che le operazioni di modifica dei dati siano consentite solo attraverso le credenziali appropriate.\n\nPool di Connessione Basati sull’Accesso\n\n\nPool di Connessione Differenziati: Utilizzare pool di connessione multipli basati sul tipo di accesso richiesto. Questo consente all’applicazione di stabilire connessioni con il livello di privilegio adeguato in base all’operazione da eseguire, ad esempio:\n\n\nAccesso in Sola Lettura: per le query di autenticazione o per la lettura di dati, dove non sono necessarie modifiche al database.\n\n\nAccesso in Lettura/Scrittura: per le query che necessitano di modificare i dati, come gli aggiornamenti o le inserzioni.\n\n\nAccesso per l’Esecuzione di Procedure Memorizzate: quando si richiama una procedura memorizzata, utilizzare credenziali che limitano l’account al solo diritto di esecuzione per quella specifica procedura.\n\n\n\n"},"Argomenti/Cybersecurity-e-Ethical-hacking/Triade-CIA":{"slug":"Argomenti/Cybersecurity-e-Ethical-hacking/Triade-CIA","filePath":"Argomenti/Cybersecurity e Ethical hacking/Triade CIA.md","title":"Triade CIA","links":[],"tags":[],"content":"La Triade CIA: Fondamenti di Sicurezza Informatica\nLa Triade CIA (Confidentiality, Integrity, Availability - Confidenzialità, Integrità, Disponibilità) costituisce un modello fondamentale per la sicurezza delle informazioni. Questi tre pilastri sono considerati gli aspetti più critici della sicurezza informatica e dovrebbero essere garantiti in qualsiasi sistema sicuro. La violazione di anche uno solo di questi elementi può avere conseguenze gravi.\nLa Triade CIA è stata creata per fornire uno standard di base per la valutazione e l’implementazione della sicurezza, indipendentemente dal sistema sottostante e/o dall’organizzazione. Vediamo più da vicino ciascuno degli elementi della triade.\n\nLa confidenzialità si riferisce alla protezione delle informazioni dalla divulgazione a individui o sistemi non autorizzati. Per garantire la confidenzialità, le organizzazioni adottano misure come la crittografia, l’uso di password robuste e il controllo degli accessi per assicurare che solo le persone autorizzate possano accedere alle informazioni sensibili.\nL’integrità implica la protezione delle informazioni da modifiche non autorizzate o accidentali. Assicura che i dati siano accurati, affidabili e non alterati. Le misure per salvaguardare l’integrità includono l’uso di hash crittografici, firme digitali e meccanismi di controllo di versione.\nLa disponibilità assicura che le informazioni siano accessibili e utilizzabili su richiesta da parte degli utenti autorizzati. Questo significa che i sistemi informativi devono essere mantenuti operativi e le risorse disponibili quando necessario. Per garantire la disponibilità, le organizzazioni implementano soluzioni di ridondanza, backup e disaster recovery, oltre a misure contro attacchi di tipo Denial of Service (DoS).\n\nLa Triade CIA serve come pilastro fondamentale per la creazione, implementazione e valutazione delle politiche di sicurezza informatica. La sua applicazione aiuta le organizzazioni a proteggere le proprie risorse digitali da una vasta gamma di minacce, garantendo al contempo che le informazioni rimangano protette, integre e disponibili. Affrontare adeguatamente ciascun aspetto della triade è essenziale per costruire un ambiente informativo sicuro e resiliente.\nLa comprensione approfondita della Triade CIA è fondamentale per professionisti della sicurezza, sviluppatori, amministratori di sistema e chiunque sia coinvolto nella gestione o nella protezione delle informazioni digitali. Implementare strategie che tengano conto di confidenzialità, integrità e disponibilità è il primo passo verso la costruzione di sistemi sicuri in un mondo digitale sempre più connesso e vulnerabile.\nConfidenzialità nella Sicurezza Informatica\nLa confidenzialità rappresenta una delle fondamenta della sicurezza delle informazioni, con l’obiettivo primario di proteggere i dati dalla divulgazione non autorizzata. Questa sezione della nostra dispensa esplora più in dettaglio il concetto di confidenzialità, distinguendolo dalla privacy e illustrando metodi e pratiche per garantirla.\nDefinizione di Confidenzialità\nLa confidenzialità è definita come la proprietà secondo la quale le informazioni non sono rese disponibili o divulgate a individui, entità o processi non autorizzati. Ciò significa che solo gli utenti autorizzati possono accedere alle risorse sensibili. È importante notare che la confidenzialità deve essere bilanciata con la disponibilità, assicurando che le persone autorizzate possano ancora accedere alle risorse per cui hanno ricevuto i permessi.\nSebbene la confidenzialità sia simile alla “privacy”, i due termini non sono interscambiabili. La confidenzialità è un componente della privacy e viene implementata per proteggere le risorse da entità non autorizzate.\nEsempi di Compromissione della Confidenzialità\n\nUn hacker ottiene accesso al database delle password di un’azienda.\nUna email sensibile viene inviata per errore a un individuo non autorizzato.\nUn hacker legge informazioni sensibili intercettando e ascoltando furtivamente un trasferimento di informazioni.\n\nMetodi per Garantire la Confidenzialità\nPer proteggere la confidenzialità delle informazioni, le organizzazioni possono adottare diversi metodi e pratiche, tra cui:\n\n\nCrittografia dei Dati: Uno dei metodi più efficaci per proteggere la confidenzialità, trasformando le informazioni in un formato illeggibile senza la chiave corretta.\n\n\nAutenticazione e Controllo degli Accessi Implementati Correttamente:\n\nPassword memorizzate in modo sicuro, ad esempio, attraverso l’hashing salato.\nAutenticazione a più fattori (MFA), che richiede più prove di identità per l’accesso.\nVerifica biometrica, utilizzando caratteristiche fisiche o comportamentali uniche.\n\n\n\nMinimizzazione del Numero di Luoghi/Tempi in cui le Informazioni Appaiono: Limitare l’esposizione delle informazioni sensibili riduce il rischio di accessi non autorizzati.\n\n\nControlli di Sicurezza Fisica: Come l’assicurare che le sale server siano adeguatamente protette per prevenire accessi fisici non autorizzati.\n\n\nConclusione\nLa confidenzialità è cruciale per proteggere le informazioni sensibili da occhi indiscreti. Implementare strategie efficaci di crittografia, autenticazione forte e controlli fisici sono passi essenziali per garantire che solo gli utenti autorizzati abbiano accesso ai dati. Man mano che le minacce alla sicurezza informatica diventano più sofisticate, l’importanza di mantenere la confidenzialità delle informazioni si intensifica, rendendo imperative pratiche di sicurezza robuste e aggiornate.\nIntegrità nella Sicurezza Informatica\nL’integrità, uno dei pilastri fondamentali della Triade CIA, riguarda la precisione, la completezza e la consistenza dei dati attraverso il loro intero ciclo di vita. Questa sezione della dispensa si concentra sull’integrità delle informazioni, spiegando come può essere compromessa e quali metodi possono essere adottati per assicurarla.\nDefinizione di Integrità\nL’integrità è definita come la proprietà di accuratezza e completezza dei dati. Ciò significa mantenere la coerenza, l’accuratezza e l’affidabilità dei dati durante tutto il loro ciclo di vita. I dati non devono subire modifiche durante il transito e non devono essere alterati da entità non autorizzate.\nEsempi di Compromissione dell’Integrità\n\nErrore umano nell’inserimento dei dati.\nErrori durante la trasmissione dei dati.\nBug del software e guasti hardware che possono causare perdite o modifiche non intenzionali dei dati.\nHacker che modificano le informazioni a cui non dovrebbero avere accesso.\n\nMetodi per Garantire l’Integrità\nPer proteggere l’integrità dei dati, è possibile adottare diverse strategie e tecnologie:\n\n\nMetodi di Autenticazione e Controllo degli Accessi Funzionanti: Assicurare che solo gli utenti autorizzati possano accedere e modificare i dati.\n\n\nVerifica dell’Integrità con Funzioni Hash: Utilizzare funzioni hash per creare un “impronta digitale” unica dei dati che può essere controllata per rilevare eventuali modifiche non autorizzate.\n\n\nBackup e Ridondanza: Mantenere copie di backup dei dati e sistemi ridondanti può aiutare a ripristinare i dati originali in caso di alterazione.\n\n\nAudit e Logging: Registrare chi ha accesso ai dati e quali modifiche vengono apportate può aiutare a tracciare eventuali alterazioni non autorizzate e a garantire l’integrità.\n\n\nConclusione\nMantenere l’integrità dei dati è cruciale per garantire che le informazioni rimangano accurate, complete e affidabili. Attraverso l’implementazione di controlli di accesso rigorosi, l’utilizzo di funzioni hash per la verifica dell’integrità, e la creazione di un robusto sistema di backup e di audit, le organizzazioni possono proteggere i loro dati da alterazioni non autorizzate. Queste pratiche non solo salvaguardano l’integrità dei dati ma rafforzano anche la fiducia degli utenti e dei clienti nelle informazioni e nei servizi offerti.\nDisponibilità nella Sicurezza Informatica\nLa disponibilità, il terzo pilastro della Triade CIA, si riferisce alla capacità di un sistema di fornire accesso continuo alle risorse autorizzate a utenti autorizzati. Questa sezione della dispensa esplora il concetto di disponibilità, evidenzia le sfide e discute metodi per assicurare che i sistemi e i dati siano sempre accessibili quando necessario.\nDefinizione di Disponibilità\nLa disponibilità è definita come la proprietà di essere accessibili e utilizzabili su richiesta da un’entità autorizzata. In altre parole, le persone autorizzate dovrebbero avere accesso alle risorse consentite in ogni momento, garantendo così che i servizi e le informazioni siano sempre disponibili quando necessari.\nEsempi di Compromissione della Disponibilità\n\nAttacchi di tipo Denial-of-Service (DoS) che sovraccaricano i sistemi e impediscono l’accesso legittimo.\nGuasti hardware, che possono causare l’interruzione dei servizi se non adeguatamente gestiti.\nIncendi o altre catastrofi naturali che danneggiano l’infrastruttura fisica.\nMalaconfigurazione di software o rete che porta a interruzioni non pianificate.\n\nMetodi per Garantire la Disponibilità\nPer assicurare che i dati e i sistemi siano sempre disponibili, è possibile implementare diverse strategie e soluzioni:\n\n\nSistemi di Rilevamento delle Intrusioni (IDS) che monitorano la rete per attività sospette e possono aiutare a prevenire o mitigare gli attacchi DoS.\n\n\nControllo del Traffico di Rete per gestire il carico e prevenire sovraccarichi che potrebbero portare a interruzioni del servizio.\n\n\nFirewall per filtrare il traffico in entrata e in uscita, proteggendo la rete da accessi non autorizzati che potrebbero compromettere la disponibilità.\n\n\nSicurezza Fisica dell’Hardware e dell’Infrastruttura sottostante, compresa la protezione contro incendi, acqua e altri elementi, per prevenire danni fisici ai sistemi critici.\n\n\nManutenzione dell’Hardware per assicurare che tutti i componenti del sistema siano in buone condizioni operative e sostituire quelli difettosi o obsoleti.\n\n\nRidondanza dei sistemi e dei dati, inclusi server, dischi e collegamenti di rete, per garantire che la perdita di un componente non comporti l’interruzione del servizio.\n\n\nConclusione\nLa disponibilità è essenziale per garantire che le risorse informatiche siano sempre accessibili agli utenti autorizzati, contribuendo alla continuità operativa e alla soddisfazione dell’utente. Implementando misure di sicurezza robuste, monitorando proattivamente le infrastrutture e pianificando la ridondanza e la resilienza, le organizzazioni possono proteggere i loro sistemi dalle interruzioni e assicurare che i servizi rimangano disponibili anche di fronte a guasti, attacchi o disastri. La preparazione e la prevenzione sono chiavi per mantenere l’alta disponibilità in un panorama di minacce in continua evoluzione."},"Argomenti/Cybersecurity-e-Ethical-hacking/Webgoat-firme":{"slug":"Argomenti/Cybersecurity-e-Ethical-hacking/Webgoat-firme","filePath":"Argomenti/Cybersecurity e Ethical hacking/Webgoat firme.md","title":"Webgoat firme","links":[],"tags":[],"content":"Public key from private\nopenssl rsa -in private.pem -pubout -out public.pem\nGet modulus\nopenssl rsa -in private.pem -modulus -noout &gt; modulus.txt\nGet sign from modulus\nopenssl dgst -sha256 -sign private.pem modulus.txt | base64 --wrap=0 &gt; sign.txt"},"Argomenti/Database/Forme-normali":{"slug":"Argomenti/Database/Forme-normali","filePath":"Argomenti/Database/Forme normali.md","title":"Forme normali","links":[],"tags":[],"content":"La normalizzazione è un processo fondamentale nella progettazione di database relazionali. L’obiettivo principale è organizzare i dati in modo che siano efficienti, evitando ridondanze e garantendo l’integrità dei dati. La normalizzazione suddivide le tabelle più grandi in tabelle più piccole e stabilisce relazioni tra di esse per ridurre la duplicazione dei dati.\nPrincipali Forme Normali\nIl processo di normalizzazione avviene in diverse fasi, ognuna delle quali porta il database a una “forma normale”. Ecco le principali forme normali:\n\n\nPrima Forma Normale (1NF):\n\nCriterio: Una tabella è in 1NF se tutti i suoi attributi contengono solo valori atomici, ovvero non divisibili. Inoltre, ogni riga della tabella deve essere univocamente identificabile da una chiave primaria.\nObiettivo: Eliminare i gruppi di ripetizione all’interno delle righe. Ogni colonna deve contenere un singolo valore, non un elenco di valori.\nEsempio: Supponiamo di avere una tabella “Ordini” con una colonna “Prodotti” che contiene una lista di prodotti (e.g., “Prodotto1, Prodotto2”). Per portare questa tabella in 1NF, si dovrebbe dividere la riga in più righe, ciascuna con un singolo prodotto.\n\n\n\nSeconda Forma Normale (2NF):\n\nCriterio: Una tabella è in 2NF se soddisfa i requisiti della 1NF e tutti gli attributi non chiave dipendono funzionalmente dall’intera chiave primaria, non da una parte di essa (questo è rilevante per chiavi primarie composte).\nObiettivo: Eliminare la dipendenza parziale dagli attributi chiave. Ogni attributo non chiave deve dipendere dall’intera chiave primaria.\nEsempio: Se una tabella “Ordini” ha una chiave primaria composta da “ID_Ordine” e “ID_Prodotto”, ma la colonna “NomeCliente” dipende solo da “ID_Ordine”, allora bisogna creare una nuova tabella per separare le dipendenze, spostando “NomeCliente” in una tabella separata con “ID_Ordine” come chiave primaria.\n\n\n\nTerza Forma Normale (3NF):\n\nCriterio: Una tabella è in 3NF se soddisfa i requisiti della 2NF e nessun attributo non chiave dipende da un altro attributo non chiave (ossia, non ci devono essere dipendenze transitive).\nObiettivo: Eliminare le dipendenze transitive, dove un attributo non chiave dipende da un altro attributo non chiave.\nEsempio: Se nella tabella “Clienti” c’è una colonna “Città” e una colonna “CAP”, dove “CAP” dipende da “Città” e non dalla chiave primaria, bisognerebbe creare una tabella separata per le città e i loro CAP.\n\n\n\nForme Normali Avanzate\n\n\nBoyce-Codd Normal Form (BCNF):\n\nCriterio: Una tabella è in BCNF se ogni determinante è una chiave candidata. Questa è una versione più rigorosa della 3NF.\nObiettivo: Risolvere alcune anomalie residue non gestite dalla 3NF.\n\n\n\nQuarta Forma Normale (4NF):\n\nCriterio: Una tabella è in 4NF se soddisfa i requisiti della BCNF e non contiene dipendenze multivalore.\nObiettivo: Evitare che un attributo dipenda da una combinazione di altri attributi.\n\n\n\nQuinta Forma Normale (5NF):\n\nCriterio: Una tabella è in 5NF se ogni join in quella tabella può essere suddiviso in join più piccoli senza perdere dati.\nObiettivo: Assicurare che non ci siano informazioni ridondanti o dipendenze più complesse che non possono essere espresse come semplici relazioni.\n\n\n\nVantaggi della Normalizzazione\n\nRiduzione della ridondanza: Evita di memorizzare le stesse informazioni in più luoghi, il che riduce le dimensioni del database e i costi di manutenzione.\nEliminazione delle anomalie: Prevenire anomalie di inserimento, aggiornamento e cancellazione.\nIntegrità dei dati: Migliora l’integrità e la coerenza dei dati, poiché ogni informazione viene memorizzata una sola volta.\n\nSvantaggi della Normalizzazione\n\nPrestazioni: In alcuni casi, un database completamente normalizzato può comportare più join nelle query, il che può ridurre le prestazioni. Per questo motivo, in alcuni contesti si utilizza una denormalizzazione controllata.\nComplessità: La struttura del database può diventare più complessa e più difficile da comprendere, specialmente quando si lavora con forme normali più avanzate.\n\nQuando Considerare la Denormalizzazione\nIn alcune situazioni, può essere utile denormalizzare (intenzionalmente aggiungere ridondanza) per migliorare le prestazioni delle query. Questo è comune nei data warehouse, dove la velocità di lettura è spesso più importante della riduzione della ridondanza."},"Argomenti/Educazione-Civica/Dipendenza-fisica-e-digitale/Dipendenza-fisica-e-digitale---Dalla-trappola-della-felicità-istantanea-di-smartphone-e-social-media-alla-felicità-autentica-e-duratura":{"slug":"Argomenti/Educazione-Civica/Dipendenza-fisica-e-digitale/Dipendenza-fisica-e-digitale---Dalla-trappola-della-felicità-istantanea-di-smartphone-e-social-media-alla-felicità-autentica-e-duratura","filePath":"Argomenti/Educazione Civica/Dipendenza fisica e digitale/Dipendenza fisica e digitale - Dalla trappola della felicità istantanea di smartphone e social media alla felicità autentica e duratura.md","title":"Dipendenza fisica e digitale - Dalla trappola della felicità istantanea di smartphone e social media alla felicità autentica e duratura","links":[],"tags":[],"content":"\n\n                  \n                  Crediti \n                  \n                \n\n\nAutore: Davide Daffonchio\nQuesto documento è stato creato con il supporto di un’intelligenza artificiale per facilitare la raccolta e l’organizzazione delle informazioni. L’autore ha verificato e integrato le informazioni per garantire accuratezza e coerenza, ma si raccomanda di consultare fonti aggiuntive e di considerare eventuali aggiornamenti successivi alla stesura. L’uso del contenuto è a scopo informativo e didattico.\nUltimo Aggiornamento: 02-11-2024\n\n\n\nIndice\n \nIntroduzione\nScopo della dispensa\nL’obiettivo di questa dispensa è quello di analizzare e comprendere i rischi legati alla dipendenza non solo dai social network ma dall’uso eccessivo degli smartphone in generale. La dipendenza da smartphone va infatti oltre i social media, includendo forme di intrattenimento e interazione ultrasemplificate, come videogiochi iperaccessibili e app progettate per una fruizione immediata e continua. Questo documento si propone di esplorare il loro impatto sul benessere psicologico e sul comportamento, evidenziando il confronto tra benessere momentaneo (a breve termine) e benessere duraturo (a lungo termine), al fine di comprendere come questi strumenti influenzino la percezione della felicità e la qualità della vita.\nPanoramica\nNegli ultimi anni, l’uso diffuso dei social media e degli smartphone ha sollevato numerose questioni sul loro impatto sulla salute mentale e sul benessere individuale. Oltre alle piattaforme social come Instagram e TikTok, le persone passano ore su app e giochi progettati per catturare l’attenzione attraverso gratificazioni rapide. Questo fenomeno ha portato alla nascita di nuove forme di dipendenza comportamentale, che vanno ben oltre il semplice uso dei social network.\nAlla radice di queste dipendenze vi è una ricerca continua di gratificazione immediata, che non si limita più ai “like” e ai commenti ma si estende ad altri tipi di ricompensa istantanea, come quelle offerte dai giochi ultra-semplificati o dalle app che riducono al minimo la complessità dell’interazione. Come con i social media, anche queste attività generano picchi di dopamina, alimentando un ciclo di dipendenza simile a quello osservato in altre dipendenze comportamentali. Tuttavia, la gratificazione momentanea offerta da tali app e giochi ha spesso effetti negativi sul lungo termine, contribuendo a una riduzione del benessere psicologico e sociale.\nPer esplorare appieno i rischi e le conseguenze dell’abuso degli smartphone, oltre a quelli dei social media, è importante considerare il concetto di felicità su una scala temporale. Da un lato, le gratificazioni a breve termine, promosse tanto dai social media quanto dai giochi e dalle app ultra-semplificate, offrono soddisfazioni immediate ma fugaci; dall’altro, la felicità a lungo termine si costruisce attraverso esperienze più significative, come lo sviluppo di relazioni autentiche e il perseguimento di obiettivi personali.\nQuesta dispensa esplorerà i meccanismi psicologici e neurobiologici che accomunano queste forme di dipendenza, mettendoli a confronto con altre dipendenze comportamentali e fisiche e discutendo le implicazioni per il benessere a lungo termine. Verranno proposte infine strategie per limitare gli effetti negativi derivanti non solo dai social media ma anche da altre app e giochi ultra-semplificati, suggerendo un approccio più consapevole e bilanciato all’uso degli smartphone.\nCome funzionano le app per smartphone?\nDefinizione\nI social media sono piattaforme digitali che permettono agli utenti di creare, condividere e interagire con contenuti, nonché di connettersi con altre persone in tempo reale. Alcuni dei social media più popolari includono Instagram, TikTok, Facebook, X. Queste piattaforme funzionano attraverso interfacce intuitive che consentono agli utenti di pubblicare foto, video, testi, storie, o stati personali, oltre a poter interagire con i contenuti degli altri tramite like, commenti, condivisioni o messaggi privati.\nOgni piattaforma ha caratteristiche uniche:\n\nInstagram è incentrato sulla condivisione di immagini e brevi video, con una forte enfasi sulle storie temporanee e sui reels (video brevi).\nTikTok si distingue per i suoi brevi video musicali, sfide virali e contenuti generati dagli utenti con alta creatività e frequenza.\nFacebook offre una piattaforma più ampia per condividere una varietà di contenuti, compresi post scritti, foto, video e link, con una componente di gruppi e pagine dedicate a specifici interessi.\nX si concentra su brevi messaggi di testo (tweet) e notizie in tempo reale, favorendo discussioni pubbliche su larga scala.\n\nQueste piattaforme sono progettate per massimizzare l’interazione sociale, consentendo agli utenti di formare reti di amici o seguaci, con i quali possono condividere e ricevere feedback immediato sotto forma di interazioni, come il “mi piace” o il commento.\nOltre ai social vi sono piattaforme di intrattenimento come i videogiochi iper-semplificati e altre app strutturate per offrire una fruizione ultra-accessibile e immediata, simile a quella dei social network.\nI vecchi videogiochi, spesso giocati su console o computer, erano progettati per offrire esperienze di gioco più complesse e strutturate. Questi giochi richiedevano generalmente una curva di apprendimento più elevata, competenze specifiche e sessioni di gioco più lunghe per progredire. L’attenzione era posta sull’abilità e sulla strategia, con obiettivi a lungo termine come completare livelli complessi, risolvere enigmi o sviluppare una narrativa coinvolgente.\nI videogiochi per smartphone sono invece progettati per sessioni rapide e gratificazioni immediate. Con meccaniche di gioco più semplici e accessibili, sono pensati per catturare l’attenzione istantaneamente, spesso tramite notifiche e premi veloci come monete virtuali o punteggi. Questo tipo di design stimola la dipendenza poiché punta su ricompense a breve termine, rendendo difficile smettere di giocare.\nDati sull’utilizzo\nL’uso dello smartphone ha visto una crescita esponenziale negli ultimi anni, soprattutto tra i giovani. Secondo le statistiche più recenti:\n\nIl tempo trascorso sugli smartphone di un utente medio è circa di 4 ore e 37 minuti al giorno, con circa 58 “checks” del telefono al giorno di cui 30 durante l’orario lavorativo. Questi checks dimostrano anche come sia una abitudine, visto che la maggior parte di essi sono molto brevi come mostrato in questa tabella:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTempo speso sullo smartphoneVolte al giornoPercentualeMeno di 2 minuti4069%Da 2 a 10 minuti1526%Più di 10 minuti35%in media 1 minuto e 15 di utilizzo per pick-up.\n\nIl 76% degli utenti Gen Z è cosciente di usare lo smartphone più del dovuto.\nIl 51.8% delle persone ammette di usare i social media per “noia”.\nTikTok e Instagram sono le app di social network più utilizzate dagli adolescenti.\n\nQuesti dati dimostrano quanto gli smartphone siano diventati parte integrante della vita quotidiana, soprattutto per i giovani, influenzando notevolmente il tempo libero e la interazione sociale.\nMeccanismi di Engagement\nI social media e le app in generale utilizzano una serie di meccanismi di engagement per mantenere gli utenti coinvolti il più a lungo possibile sulle piattaforme. Alcuni di questi meccanismi includono:\n\nNotifiche: Le notifiche push sono progettate per richiamare l’attenzione dell’utente in tempo reale. Ogni volta che qualcuno mette “mi piace”, commenta o interagisce con i contenuti di un utente, una notifica appare sul dispositivo dell’utente. Questo genera una costante stimolazione che incoraggia l’utente a tornare sulla piattaforma per controllare le interazioni.\n“Like” e commenti: I “like” (mi piace) e i commenti fungono da feedback sociale positivo che dà agli utenti una sensazione di riconoscimento e approvazione da parte della loro rete di amici o seguaci. Ogni “mi piace” o commento ricevuto attiva nel cervello il rilascio di dopamina, un neurotrasmettitore associato al piacere e alla gratificazione. Questo stimola il bisogno di pubblicare sempre più contenuti per ottenere ulteriori feedback positivi.\nAlgoritmi personalizzati: Le piattaforme di social media utilizzano algoritmi complessi per selezionare e presentare contenuti personalizzati nel feed degli utenti. Ad esempio, l’algoritmo di Instagram si basa sulle interazioni precedenti, sui “mi piace” e sui contenuti visualizzati, per proporre post e video che possano risultare interessanti per l’utente. Questo mantiene gli utenti “incollati” alla piattaforma, poiché gli vengono costantemente proposti contenuti che rispondono ai loro gusti e interessi.\nScorrimento infinito: Molte piattaforme adottano la funzione del “scroll infinito”, che permette agli utenti di scorrere senza limiti il proprio feed di contenuti. Questa caratteristica sfrutta il fenomeno psicologico della ricerca della novità, inducendo l’utente a cercare continuamente nuovi contenuti, rendendo difficile interrompere l’uso dell’app.\nStorie temporanee: L’introduzione delle storie su piattaforme come Instagram e Snapchat, che scompaiono dopo 24 ore, aggiunge un senso di urgenza, spingendo gli utenti a controllare costantemente per non perdere contenuti. Questa funzione incentiva anche la condivisione quotidiana di contenuti effimeri.\n\nOltre alle funzioni specifiche dei social media, altre app e giochi sfruttano meccanismi di coinvolgimento simili, per mantenere gli utenti “incollati” agli smartphone. Ad esempio:\n\nRicompense istantanee nei giochi semplificati: Giochi iper-accessibili, progettati per partite brevi e ricompense rapide (come punti, monete virtuali o bonus), stimolano la gratificazione immediata. Come i “like” sui social, queste ricompense stimolano il rilascio di dopamina, rendendo difficile per l’utente fermarsi.\nNotifiche costanti: Anche app non social sfruttano notifiche push per stimolare l’interazione continua, richiamando gli utenti per completare un’azione o per segnalare nuovi contenuti disponibili. Queste notifiche, che possono arrivare da giochi o altre app, aumentano il bisogno di controllare frequentemente il telefono.\nDesign “a ciclo rapido”: Molti giochi e app utilizzano interazioni minime e cicli di gioco o uso rapidi, che offrono soddisfazioni immediate, spesso senza richiedere competenze o strategie avanzate. Questo design minimizza la complessità e incentiva l’utente a interagire ripetutamente per ottenere piccole gratificazioni.\n\nQuesti meccanismi contribuiscono a rafforzare la dipendenza dallo smartphone, generando un ciclo simile a quello dei social media. Tuttavia, mentre il coinvolgimento sui social è legato a interazioni sociali virtuali, l’abuso di altre app può portare a una distrazione continua e a una riduzione del tempo dedicato a esperienze reali e significative.\nFonti\n\nGlobal WebIndex (2023). “Social Media Usage Statistics”.\nPew Research Center (2023). “Teens, Social Media and Technology”.\nStatista (2023). “TikTok Usage Statistics”.\nWe Are Social (2023). “Digital Report”.\nAmerican Psychological Association (2023). “Psychology of Gaming”.\nDigital Wellbeing Report (2023). “Impact of Mobile Apps on Mental Health”.\nwww.harmonyhit.com/phone-screen-time-statistics/\nblog.rescuetime.com/screen-time-stats-2018/\ndatareportal.com/reports/digital-2024-global-overview-report\nwww.zenithmedia.com/product/media-consumption-forecasts-2019/\nsimpletexting.com/screen-time-survey/\n\nDipendenza: Definizione e Tipologie\nChe cos’è una dipendenza?\nLa dipendenza può essere definita come uno stato psicofisico caratterizzato da una compulsione o desiderio incontrollabile di compiere una determinata azione o consumare una sostanza, nonostante le conseguenze negative per la salute fisica, mentale o sociale. La dipendenza coinvolge generalmente la ricerca di gratificazione immediata attraverso il ripetersi di un comportamento o l’assunzione di una sostanza, spesso associata alla produzione di dopamina nel cervello, il neurotrasmettitore che regola il piacere e la ricompensa.\nEsistono due principali categorie di dipendenza: dipendenze da sostanze e dipendenze comportamentali.\nDefinizione generale di dipendenza\n\nDipendenza fisica: Si tratta della dipendenza da una o più sostanze chimiche che alterano il funzionamento del sistema nervoso centrale. Le più comuni sono l’alcol, la nicotina e le droghe (sia legali che illegali). Il consumo ripetuto di queste sostanze può portare allo sviluppo di tolleranza (necessità di consumare quantità sempre maggiori per ottenere lo stesso effetto) e a sintomi di astinenza (manifestazioni fisiche e mentali negative in assenza della sostanza).\nDipendenza psichica: A differenza delle dipendenze da sostanze, le dipendenze psichiche si riferiscono all’impulso incontrollabile di ripetere determinati comportamenti che non coinvolgono l’assunzione di sostanze. Alcuni esempi includono il gioco d’azzardo patologico, la dipendenza dai social media, la dipendenza da internet, lo shopping compulsivo e altre forme di attività che producono gratificazione immediata. Sebbene non coinvolgano l’assunzione di sostanze chimiche, queste dipendenze attivano comunque i circuiti di ricompensa nel cervello, similmente alle droghe o all’alcol.\n\nDifferenze tra dipendenze da sostanze e dipendenze comportamentali\nSebbene esistano paralleli tra dipendenze da sostanze e comportamentali, ci sono anche differenze significative:\n\nSostanza vs. Comportamento: Le dipendenze da sostanze coinvolgono l’uso di composti che alterano chimicamente il cervello, mentre le dipendenze comportamentali sono basate su azioni ripetute che portano gratificazione senza l’introduzione di sostanze chimiche esterne.\nAstinenza: Nelle dipendenze da sostanze, l’astinenza provoca generalmente sintomi fisici evidenti (es. tremori, nausea, convulsioni). Nelle dipendenze comportamentali, l’astinenza si manifesta più frequentemente come stress psicologico (ansia, irrequietezza, irritabilità), senza una forte componente fisica.\nImpatto sulla salute: Le dipendenze da sostanze possono avere conseguenze gravi e dirette sulla salute fisica (danni agli organi, dipendenza fisica), mentre le dipendenze comportamentali tendono a produrre principalmente conseguenze psicologiche e sociali, pur potendo indirettamente influire anche sulla salute fisica (es. disturbi del sonno o problemi cardiovascolari dovuti a stress).\n\nI segni della dipendenza dai social media\nLa dipendenza dai social media rientra nelle dipendenze comportamentali e si manifesta attraverso un uso compulsivo e fuori controllo delle piattaforme sociali, con conseguenze negative sul benessere psicologico, sociale e talvolta fisico. Alcuni dei segni più comuni di questa dipendenza sono:\nSintomi comportamentali\n\nControllo compulsivo dei social: Le persone che soffrono di dipendenza dai social media sentono il bisogno di controllare costantemente le piattaforme, anche quando sono in situazioni inappropriate (es. durante il lavoro, a scuola o durante le interazioni faccia a faccia). Il timore di perdere informazioni o l’aggiornamento sui propri contatti spinge l’utente a rimanere connesso per lunghi periodi, a discapito delle proprie attività quotidiane.\nAnsia da notifica: Un altro segno distintivo è la preoccupazione costante legata alla ricezione di notifiche. Molti utenti sentono un forte bisogno di ricevere conferme sociali tramite like, commenti e condivisioni, provando ansia o frustrazione quando non ricevono le interazioni che si aspettano.\n\nRiferimento scientifico: Studi sulla dipendenza da social media\nUno degli strumenti più noti per misurare la dipendenza da social media è la Bergen Social Media Addiction Scale (BSMAS), sviluppata da ricercatori presso l’Università di Bergen, in Norvegia. Questa scala si basa su sei criteri che derivano dal modello delle dipendenze comportamentali, tra cui:\n\nL’occupazione mentale con i social media.\nLa tolleranza (bisogno di un uso crescente per ottenere lo stesso piacere).\nSintomi di astinenza quando non si ha accesso ai social media.\nConflitti interpersonali o professionali derivanti dall’uso eccessivo.\nRecidive nel comportamento dopo tentativi di limitare l’uso.\nProblemi nell’autocontrollo riguardo il tempo trascorso sui social.\nStudi condotti utilizzando questa scala hanno dimostrato che un uso eccessivo dei social media può influire negativamente sulla salute mentale, contribuendo a sviluppare sintomi simili a quelli delle dipendenze da sostanze (Kuss &amp; Griffiths, 2017).\n\nFonti\n\nKuss, D. J., &amp; Griffiths, M. D. (2017). “Social networking sites and addiction: Ten lessons learned”. International Journal of Environmental Research and Public Health.\nAndreassen, C. S., et al. (2016). “The Bergen Social Media Addiction Scale: Development and psychometric validation”. Psychology of Addictive Behaviors.\n\nIl Ciclo della Gratificazione Immediata\nIl ruolo della dopamina\nLa dopamina è un neurotrasmettitore chiave nel sistema di ricompensa del cervello, responsabile della sensazione di piacere che si prova quando si ottiene una ricompensa o si soddisfa un desiderio. Viene rilasciata non solo in risposta a eventi gratificanti, ma anche in anticipazione di essi, guidando così il comportamento umano verso la ricerca di piaceri. Sia nelle dipendenze da sostanze che in quelle comportamentali, la dopamina gioca un ruolo cruciale: il cervello impara a cercare ripetutamente quelle esperienze che portano al rilascio di dopamina, creando un ciclo di desiderio e gratificazione che può diventare difficile da interrompere.\nConfronto con altre dipendenze: Alcol e altre droghe leggere\nPer comprendere come funziona il ciclo della gratificazione immediata nei social media, possiamo paragonarlo alla dipendenze da alcol o altre droghe leggere, come la marijuana, in diversi modi:\n\nEffetti immediati e transitori: Quando una persona consuma alcol o marijuana, il principio attivo agisce come narcotizzante a livello cerebrale, causando uno stato di rilassamento. Questo stato produce dopamina, aggiungendo anche uno stato di euforia di breve durata. Allo stesso modo, l’uso dei social media genera un piacere immediato attraverso interazioni sociali virtuali, ma l’effetto è di breve durata. Dopo aver ricevuto una ricompensa (es. un “like” o un commento), l’individuo può sperimentare una sensazione di vuoto o insoddisfazione, simile al “down” che segue l’assunzione di una droga leggera.\nRicerca di gratificazione continua: La tolleranza all’alcol e alla marijuana si sviluppa con l’uso regolare. Nel caso dell’alcol, il corpo diventa più efficiente nel metabolizzarlo e il cervello si abitua agli effetti, portando a un aumento del consumo per ottenere gli stessi risultati. Con la marijuana, i recettori del cervello diventano meno sensibili al THC, riducendo gli effetti percepiti e spingendo a un uso maggiore. Questo porta a dipendenza e ad assumere dosi sempre maggiori per ottenere gli stessi effetti, causando gravissimi danni alla salute. Così come chi beve alcol può iniziare con dosi moderate per poi aumentare gradualmente il consumo nel tentativo di replicare gli effetti iniziali, gli utenti dei social media possono iniziare a utilizzare le piattaforme in modo occasionale, ma col tempo sviluppare una tolleranza psicologica, che li porta a passare sempre più tempo online per ottenere la stessa sensazione di soddisfazione.\nComportamento compulsivo: Nella dipendenza da alcol o marijuana, la persona sviluppa un impulso sempre più forte a consumare la sostanza, anche quando ne riconosce i potenziali danni. Analogamente, nelle dipendenze da social media, molti utenti sentono il bisogno compulsivo di controllare il proprio telefono o il proprio feed, anche quando sono consapevoli che questo può interferire con la loro vita quotidiana, le relazioni sociali o il lavoro.\n\nCome i social media stimolano la dopamina\nI social media, come Instagram, TikTok e Facebook, sono progettati per stimolare il sistema dopaminergico attraverso meccanismi di ricompensa intermittente. A differenza delle ricompense prevedibili, come accade con il consumo di una sostanza, le ricompense sui social media (ad esempio, “like”, commenti, e notifiche) sono distribuite in modo imprevedibile e intermittente, il che rende il loro impatto ancora più potente e coinvolgente, similmente a come fanno le slot machine e il gioco d’azzardo in generale.\n\nNotifiche: Ogni volta che si riceve una notifica su un nuovo “mi piace”, commento o messaggio, il cervello risponde con un rilascio di dopamina, creando un’associazione positiva tra l’uso dei social media e la gratificazione immediata. Questo rafforza il comportamento, spingendo l’utente a controllare ripetutamente il telefono per cercare ulteriori ricompense.\n“Like” e commenti: Similmente all’assunzione di una droga leggera, come la marijuana, che produce un senso temporaneo di euforia, ogni “mi piace” o commento sui social media provoca una piccola scarica di dopamina. Tuttavia, come nel caso dell’uso di sostanze, l’effetto è transitorio, e il cervello si abitua rapidamente a queste ricompense, richiedendo un’esposizione sempre maggiore (ad esempio, più interazioni o più tempo sui social) per ottenere lo stesso livello di soddisfazione.\n\nCiclo della dipendenza\nIl ciclo della dipendenza può essere suddiviso in tre fasi, sia nel contesto delle dipendenze da sostanze che di quelle comportamentali, come l’uso compulsivo dei social media:\n\nCraving: In entrambe le forme di dipendenza, il ciclo inizia con un desiderio o una voglia intensa di cercare la ricompensa. Nel caso dell’alcol o della marijuana, la persona cerca di ottenere una sensazione di euforia o relax. Nel caso dei social media, l’utente cerca la gratificazione attraverso interazioni sociali, notifiche o la curiosità su cosa stanno facendo gli altri.\nRicompensa: Quando la persona consuma la sostanza o usa i social media, sperimenta una gratificazione immediata. La dopamina rilasciata crea una sensazione di piacere temporaneo. Tuttavia, come accade con il consumo di alcol o droghe leggere, questa gratificazione è breve e si esaurisce rapidamente, portando alla fase successiva.\nAstinenza: Dopo che l’effetto iniziale svanisce, il cervello richiede più stimoli per mantenere lo stesso livello di dopamina, anche a seguito di senso di colpa, autoaccusa e rimpianto. Questo porta a una ricerca costante di nuove ricompense, che nel caso dei social media può significare il bisogno di controllare continuamente le notifiche o di pubblicare nuovi contenuti per ottenere più interazioni.\n\nRiferimenti scientifici\nLe ricerche nel campo delle dipendenze comportamentali e da sostanze evidenziano molte somiglianze tra l’uso compulsivo dei social media e il consumo di sostanze come alcol e marijuana. Ad esempio:\n\nEffetti simili sul sistema dopaminergico: Studi hanno dimostrato che l’uso eccessivo di social media può attivare le stesse aree del cervello che vengono stimolate dal consumo di alcol o droghe leggere. Questo coinvolgimento del sistema di ricompensa dopaminergico rende entrambe le forme di dipendenza difficili da interrompere (Turel et al., 2014).\nEffetti psicologici negativi: Proprio come l’abuso di alcol o marijuana può portare a problemi psicologici come ansia e depressione, un uso eccessivo dei social media è stato associato a effetti negativi sulla salute mentale, inclusi aumento dell’ansia, isolamento sociale e sintomi depressivi (Andreassen et al., 2016).\n\nFonti\n\nTurel, O., He, Q., Xue, G., Xiao, L., &amp; Bechara, A. (2014). “Examination of neural systems sub-serving Facebook ‘addiction’“. Psychological Reports.\nAndreassen, C. S., et al. (2016). “The relationship between addictive use of social media, narcissism, and self-esteem: Findings from a large national survey”. Addictive Behaviors.\n\nEffetti delle dipendenze fisiche\nIntroduzione\nL’uso di sostanze psicoattive, come alcol e marijuana, rappresenta un rischio per la salute fisica e mentale, soprattutto nei giovani il cui cervello è ancora in fase di sviluppo. Studi recenti dimostrano che danni permanenti possono essere causati non solo da un abuso prolungato e intenso, ma anche da un uso moderato o occasionale. Anche un consumo non regolare può infatti compromettere il corretto sviluppo delle funzioni cognitive e fisiologiche, influenzando processi critici e aumentando il rischio di conseguenze a lungo termine.\nConseguenze a lungo termine\nAbuso di alcol\nL’abuso di alcol, soprattutto nei giovani sotto i 25 anni, ha conseguenze gravi a livello fisico, cognitivo e sociale. Il cervello dei giovani è ancora in fase di sviluppo fino ai 25 anni, e l’esposizione all’alcol può interferire con il corretto sviluppo delle funzioni cognitive.\n\nDanno cognitivo: L’abuso di alcol può causare una riduzione della memoria a breve termine e compromettere la capacità di apprendimento e di risolvere problemi. Gli studi dimostrano che l’abuso di alcol durante l’adolescenza e la prima età adulta può portare a danni permanenti all’ippocampo, la regione del cervello responsabile della memoria e dell’apprendimento.\nProblemi di salute mentale: L’abuso di alcol è strettamente collegato all’aumento dei livelli di ansia e depressione. Il consumo eccessivo di alcol può interferire con i neurotrasmettitori che regolano l’umore, causando sbalzi d’umore, ansia e sintomi depressivi, soprattutto nei giovani che sono particolarmente vulnerabili a queste influenze.\nDipendenza fisica: L’abuso di alcol può portare allo sviluppo di una dipendenza fisica, con sintomi di astinenza come tremori, nausea e ansia quando il consumo viene interrotto. La dipendenza fisica può evolvere in alcolismo, una condizione cronica che richiede trattamenti a lungo termine.\nDanni al fegato: L’abuso prolungato di alcol può causare steatosi epatica (fegato grasso), epatite alcolica e, nei casi più gravi, cirrosi epatica. La cirrosi è una condizione irreversibile in cui il tessuto epatico sano viene sostituito da tessuto cicatriziale, compromettendo la funzionalità del fegato e portando potenzialmente a insufficienza epatica.\nDanni al cuore: L’alcol è anche associato a danni ad altri organi interni, come il cuore. L’abuso può causare cardiomiopatia alcolica, una condizione che indebolisce il muscolo cardiaco, portando a insufficienza cardiaca. Inoltre, può aumentare il rischio di ipertensione, ictus e altri disturbi cardiovascolari.\nSistema gastrointestinale: L’alcol irrita il rivestimento dello stomaco e può portare a gastriti, ulcere e, nei casi cronici, a sanguinamenti gastrointestinali. Può anche influenzare il pancreas, causando pancreatiti acute o croniche, condizioni estremamente dolorose e pericolose per la vita.\nAccumulo di tossine nel corpo: In caso di insufficienza epatica causata dall’abuso di alcol, le tossine che il fegato non riesce a filtrare, come l’ammoniaca, possono accumularsi nel sangue e raggiungere il cervello, provocando una condizione nota come encefalopatia epatica. Questo disturbo può causare confusione mentale, perdita di coordinazione motoria e, nei casi più gravi, coma. Le tossine che non vengono correttamente eliminate possono avere effetti negativi su altri organi, provocando infiammazioni e contribuendo a condizioni come insufficienza renale, che può derivare da un funzionamento epatico compromesso. Inoltre, l’accumulo di tossine può influenzare anche il sistema immunitario, rendendo l’organismo più suscettibile alle infezioni.\n\nRiferimenti Scientifici\n\nSqueglia, L. M., Jacobus, J., &amp; Tapert, S. F. (2009). The influence of substance use on adolescent brain development. Clinical EEG and Neuroscience, 40(1), 31-38.\nCrews, F. T., &amp; Vetreno, R. P. (2016). Mechanisms of neuroimmune gene induction in alcoholism. Psychopharmacology, 233, 1543-1557.\nBecker, H. C. (2008). Alcohol dependence, withdrawal, and relapse. Alcohol Research &amp; Health, 31(4), 348-361.\nRehm, J., Samokhvalov, A. V., &amp; Shield, K. D. (2013). Global burden of alcoholic liver diseases. Journal of Hepatology, 59(1), 160-168.\nPiano, M. R., &amp; Phillips, S. A. (2014). Alcoholic cardiomyopathy: Pathophysiologic insights. Alcoholism: Clinical and Experimental Research, 38(2), 292-299.\nLieber, C. S. (1997). Ethanol metabolism, cirrhosis and alcoholism. Clinical &amp; Experimental Pharmacology and Physiology, 24(3-4), 192-195.\nMathurin, P., &amp; Bataller, R. (2015). Trends in the management and burden of alcoholic liver disease. Journal of Hepatology, 62(1), S38-S46.\nButterworth, R. F. (2003). Pathophysiology of hepatic encephalopathy: A new look at ammonia. Metabolic Brain Disease, 18(4), 309-329.\n\nAbuso di marijuana\nDanni Cognitivi e alla Salute Mentale\n\nDeficit Cognitivi: L’uso cronico, specialmente iniziato in adolescenza, è associato a riduzioni nel quoziente intellettivo (QI), memoria, attenzione e capacità di apprendimento.\nDipendenza e Sindrome da Astinenza: La marijuana può causare dipendenza psicologica, con sintomi di astinenza quali irritabilità, insonnia e ansia.\nRischio di Psicosi e Schizofrenia: Aumenta il rischio di sviluppare disturbi psicotici, soprattutto nei soggetti predisposti geneticamente.\nDisturbi dell’Umore: L’uso prolungato è associato a una maggiore probabilità di depressione e ansia.\n\nDanni alla Salute Fisica\n\nSistema Respiratorio: Il fumo di marijuana può irritare le vie respiratorie, causando bronchiti croniche e aumentando i rischi di danni ai polmoni.\nSistema Cardiovascolare: La marijuana incrementa il battito cardiaco e la pressione, aumentando il rischio di aritmie ed eventi cardiovascolari gravi.\nSistema Immunitario: Il THC può deprimere il sistema immunitario, rendendo l’organismo più suscettibile alle infezioni.\n\nRiferimenti Scientifici\n\nMeier, M. H., Caspi, A., Ambler, A., Harrington, H., Houts, R., Keefe, R. S., McDonald, K., Ward, A., Poulton, R., &amp; Moffitt, T. E. (2012). Persistent cannabis users show neuropsychological decline from childhood to midlife. Proceedings of the National Academy of Sciences, 109(40), E2657-E2664.\nVolkow, N. D., Baler, R. D., Compton, W. M., &amp; Weiss, S. R. (2014). Adverse health effects of marijuana use. The New England Journal of Medicine, 370(23), 2219-2227.\nMarconi, A., Di Forti, M., Lewis, C. M., Murray, R. M., &amp; Vassos, E. (2016). Meta-analysis of the association between the level of cannabis use and risk of psychosis. JAMA Psychiatry, 73(9), 938-944.\nLev-Ran, S., Roerecke, M., Le Foll, B., George, T. P., McKenzie, K., &amp; Rehm, J. (2014). The association between cannabis use and depression: a systematic review and meta-analysis of longitudinal studies. Psychological Medicine, 44(4), 797-810.\nTashkin, D. P. (2013). Effects of marijuana smoking on the lung. Annals of the American Thoracic Society, 10(3), 239-247.\nDesai, R., Patel, U., Sharma, S., Amin, M. B., Bhanot, R., &amp; Vohra, I. (2019). Recreational marijuana use and acute myocardial infarction: Insights from nationwide inpatient sample in the United States. Journal of the American College of Cardiology, 73(9 Supplement 1), 1604.\nCabral, G. A., &amp; Jamerson, M. J. (2015). Marijuana use and immunosuppression: A review of the literature. Journal of Neuroimmune Pharmacology, 10(3), 253-267.\nBrook, J. S., Lee, J. Y., Finch, S. J., &amp; Brook, D. W. (2011). Developmental trajectories of marijuana use from adolescence to adulthood: Personality and social role outcomes. Addiction, 106(2), 422-432.\n\nGli Effetti Negativi della Dipendenza dai Social Media\nLa continua esposizione senza controllo ai social può avere un impatto a lungo termine sulla salute mentale e fisica degli utenti. Le piattaforme, progettate per catturare costantemente l’attenzione attraverso meccanismi di gratificazione immediata, possono indurre cambiamenti significativi nelle abitudini comportamentali, cognitive ed emotive. Esamineremo come la continua esposizione a contenuti brevi, l’interazione compulsiva e la tendenza al confronto sociale possano compromettere la capacità di concentrazione, alimentare stati d’ansia e depressione, e influenzare la qualità della vita quotidiana.\nVideo brevi\nCon l’evoluzione delle piattaforme social, è emerso un fenomeno particolarmente rilevante: il crescente trend dei video brevi. Inizialmente spinto dal successo di piattaforme come TikTok e poi adottato da altre come Instagram e YouTube, questo formato è stato pensato per mantenere alto l’engagement attraverso contenuti di facile consumo e di breve durata. Tuttavia, questa forma di intrattenimento, incentrata sulla gratificazione immediata, presenta risvolti significativi a lungo termine per la salute mentale e fisica degli utenti.\nImpatto dei video brevi\nRispetto ai video più lunghi, come quelli su piattaforme come YouTube o documentari che richiedono una maggiore capacità di attenzione e concentrazione, i video brevi non richiedono un impegno cognitivo prolungato. I contenuti più lunghi, infatti, tendono a promuovere una riflessione più profonda, richiedono attenzione sostenuta e portano a una gratificazione differita, dove la ricompensa arriva solo dopo aver investito tempo ed energia mentale. Questo tipo di impegno cognitivo è cruciale per sviluppare abilità come la concentrazione a lungo termine, la pazienza e la capacità di apprendimento.\nI video brevi, al contrario, fanno leva su stimoli immediati e ripetuti, ma non richiedono né promuovono una comprensione profonda o uno sviluppo di competenze cognitive complesse. Di conseguenza, l’esposizione prolungata a contenuti brevi può influenzare negativamente la capacità del cervello di mantenere l’attenzione per lunghi periodi e favorire la ricerca costante di stimoli più rapidi.\nCome la brevità dei video influenza le prestazioni del cervello\nL’esposizione continua a video brevi e contenuti frammentati può dunque avere diversi effetti sulle prestazioni del cervello:\n\nRiduzione della capacità di attenzione: Studi hanno dimostrato che l’esposizione a stimoli rapidi e brevi, come quelli forniti dai video su TikTok, può portare a una diminuzione della capacità di attenzione. Il cervello si abitua a ricevere informazioni in formato rapido e può iniziare a faticare quando è richiesto di concentrarsi su attività che richiedono maggiore impegno cognitivo o attenzione a lungo termine. Ad esempio, gli utenti abituati a contenuti brevi possono trovare difficoltà a leggere testi lunghi o a guardare film/documentari estesi.\nAumento dell’impazienza: Poiché i video brevi forniscono gratificazioni immediate, il cervello inizia a preferire le ricompense istantanee rispetto a quelle che richiedono più tempo. Questo può portare a una generale impazienza nell’affrontare attività che richiedono tempo e sforzo, come lo studio, la lettura o il lavoro. Il cervello diventa meno disposto a impegnarsi in processi che richiedono tempo, preferendo stimoli che forniscono gratificazioni più rapide.\nDiminuzione della memoria a lungo termine: I video brevi non favoriscono la memoria a lungo termine. Poiché la quantità di informazioni trasmesse in pochi secondi è minima e il cervello è costantemente stimolato da nuovi input, l’elaborazione delle informazioni tende a rimanere superficiale. La mancanza di elaborazione profonda porta a una minore memorizzazione delle informazioni, mentre contenuti più lunghi e riflessivi possono migliorare l’apprendimento e la memoria.\nEffetti sull’apprendimento: I video brevi non promuovono un apprendimento approfondito, poiché il tempo per elaborare, riflettere e contestualizzare le informazioni è limitato. Questo fenomeno può influenzare negativamente le prestazioni accademiche o professionali, soprattutto in attività che richiedono l’assimilazione di informazioni complesse o la risoluzione di problemi.\n\nRicerche scientifiche\nAlcuni studi hanno evidenziato come l’esposizione ai contenuti brevi possa influenzare negativamente le funzioni cognitive del cervello:\n\nStudi sull’attenzione: Un’indagine condotta da Carr (2010) ha rivelato che l’esposizione a brevi frammenti di informazione (come quelli dei social media e dei video brevi) può ridurre la capacità di concentrazione. L’accesso continuo a informazioni rapide e superficiali reindirizza il cervello verso un modello di pensiero meno riflessivo e più impulsivo.\nStudi sull’apprendimento: La ricerca di Middaugh et al. (2017) ha mostrato che l’uso prolungato di video brevi nelle giovani generazioni può alterare le capacità di apprendimento, riducendo il tempo medio di attenzione. Questo fenomeno è stato collegato alla preferenza per ricompense cognitive rapide rispetto a compiti più impegnativi e lunghi, come lo studio o la risoluzione di problemi complessi.\n\nFonti\n\nCarr, N. (2010). The Shallows: What the Internet is Doing to Our Brains. W.W. Norton &amp; Company.\nMiddaugh, E., Clark, L. S., &amp; Ballard, P. J. (2017). “Digital media, participatory politics, and positive youth development”. Pediatrics.\n\nAnsia e depressione\nL’uso intensivo dei social media è stato collegato a un aumento dei livelli di ansia e depressione, soprattutto tra i giovani. Le piattaforme sociali spesso incentivano il confronto sociale, dove gli utenti confrontano la propria vita con quella apparentemente “perfetta” degli altri. Le immagini curate, i successi professionali o personali e gli aspetti positivi messi in evidenza dagli altri utenti possono far sentire inadeguato chi osserva, generando ansia e insoddisfazione.\n\nCollegamento tra uso intensivo dei social e disturbi psicologici: Diversi studi hanno evidenziato una correlazione tra l’uso eccessivo dei social media e l’aumento di sintomi di ansia e depressione. In particolare, un’analisi condotta da Twenge et al. (2018) ha dimostrato che, a partire dal 2010, quando l’uso degli smartphone e dei social media ha visto una crescita esponenziale, i livelli di ansia e depressione tra gli adolescenti sono aumentati significativamente. Questo è spesso dovuto alla costante esposizione a contenuti che portano gli utenti a confrontarsi con ideali irrealistici di bellezza, successo o felicità.\nIl fenomeno del confronto sociale: I social media creano ambienti virtuali in cui le persone possono confrontarsi costantemente con gli altri. Questo confronto, spesso negativo, può amplificare sentimenti di invidia e di insoddisfazione. Gli utenti possono iniziare a credere che la loro vita sia meno soddisfacente o interessante rispetto a quella dei loro coetanei, nonostante la realtà mostrata sui social sia spesso solo una rappresentazione filtrata e selezionata. Questo fenomeno è particolarmente evidente nelle piattaforme incentrate sulle immagini come Instagram e TikTok, dove l’estetica e il successo personale sono amplificati.\n\nQualità del sonno\nL’uso prolungato dei social media, soprattutto nelle ore serali o notturne, ha un impatto negativo sulla qualità del sonno. Le piattaforme sociali, grazie ai meccanismi di engagement (notifiche, like, commenti), tendono a mantenere gli utenti attivi e coinvolti anche quando dovrebbero prepararsi al riposo.\n\nEffetto dell’uso notturno dei dispositivi sulla qualità del sonno: Studi hanno dimostrato che l’esposizione alla luce blu emessa dagli schermi dei dispositivi digitali interferisce con la produzione di melatonina, l’ormone che regola il ciclo del sonno. L’uso intensivo di social media prima di andare a letto può ritardare il rilascio di melatonina, portando a difficoltà ad addormentarsi e a una qualità del sonno ridotta. Un rapporto pubblicato dalla National Sleep Foundation ha rilevato che oltre il 90% dei giovani utilizza dispositivi elettronici nelle ore prima di dormire, con effetti negativi sul sonno e sul benessere generale.\nRischi della procrastinazione del sonno: L’uso dei social media prima di coricarsi non solo può interferire con la qualità del sonno, ma può anche portare a un fenomeno noto come “procrastinazione del sonno”, in cui gli utenti ritardano l’addormentamento a causa della tentazione di controllare continuamente le notifiche, guardare video o scorrere i feed. Questo porta a una riduzione delle ore complessive di sonno, con conseguenze dirette sulla salute mentale e fisica, come affaticamento, ridotta capacità di concentrazione e aumento del rischio di disturbi dell’umore.\n\nIsolamento sociale\nSebbene i social media siano nati per connettere le persone, un uso eccessivo e dipendente può portare all’effetto opposto, favorendo un senso di isolamento sociale. Quando le interazioni virtuali sostituiscono quelle reali, le relazioni autentiche e il contatto fisico vengono sacrificati a favore di connessioni superficiali.\n\nSostituzione delle interazioni reali: Molti utenti sostituiscono le interazioni faccia a faccia con quelle sui social media, riducendo il tempo dedicato a conversazioni reali e ad attività sociali offline. Questo fenomeno porta a una riduzione delle connessioni umane profonde e autentiche, elementi fondamentali per il benessere psicologico e sociale. Le relazioni online tendono ad essere più superficiali e meno intime, privando l’individuo del supporto emotivo che si ottiene dalle interazioni dirette. Inoltre, la tendenza a controllare continuamente i social media anche in momenti di socialità, come quando si esce con gli amici, contribuisce a creare una connessione frammentata con le persone presenti. Tale comportamento riduce la qualità delle conversazioni e rende difficile vivere il momento presente, limitando l’empatia e la profondità delle relazioni.\nSensazione di isolamento: Paradossalmente, nonostante l’accesso costante a un’ampia rete di contatti virtuali, molte persone sperimentano un forte senso di isolamento. La mancanza di interazioni reali, unita alla pressione di mantenere un’immagine perfetta online, contribuisce a far sentire le persone scollegate dagli altri, alimentando sentimenti di solitudine e inadeguatezza. Il confronto continuo con standard irrealistici, incentivato dalla visibilità costante della vita degli altri sui social, acuisce insicurezze e inibisce la capacità di costruire relazioni autentiche e di supporto.\n\nRicerche scientifiche\nNumerosi studi hanno esplorato gli effetti negativi dell’uso eccessivo dei social media sulla salute mentale e fisica. Ecco alcuni esempi significativi:\n\nTwenge et al. (2018): Questo studio ha esaminato l’aumento dei sintomi di ansia, depressione e isolamento sociale tra gli adolescenti negli Stati Uniti a partire dal 2010. I ricercatori hanno scoperto che l’uso prolungato dei social media è correlato a un incremento nei casi di disturbi dell’umore e problemi psicologici. Gli adolescenti che trascorrevano più di cinque ore al giorno sui social avevano una probabilità significativamente maggiore di sperimentare sintomi di depressione rispetto a quelli che ne facevano un uso moderato.\nLemola et al. (2015): Questo studio ha evidenziato l’impatto negativo dell’uso dei social media sul sonno. I ricercatori hanno scoperto che gli adolescenti che utilizzano i social media nelle ore notturne tendono ad avere una qualità del sonno peggiore e sono più soggetti a disturbi del sonno come insonnia e sonno interrotto.\nHunt et al. (2018): In un esperimento controllato, è stato dimostrato che una riduzione dell’uso dei social media per tre settimane ha portato a una diminuzione significativa dei livelli di solitudine e depressione. Questo suggerisce che limitare l’uso dei social media può avere effetti positivi sulla salute mentale.\n\nFonti\n\nTwenge, J. M., et al. (2018). “Increases in depressive symptoms, suicide-related outcomes, and suicide rates among U.S. adolescents after 2010 and links to increased new media screen time”. Clinical Psychological Science.\nLemola, S., et al. (2015). “Adolescents’ electronic media use at night, sleep disturbance, and depressive symptoms in the smartphone age”. Journal of Youth and Adolescence.\nHunt, M. G., Marx, R., Lipson, C., &amp; Young, J. (2018). “No more FOMO: Limiting social media decreases loneliness and depression”. Journal of Social and Clinical Psychology.\n\nEffetti Negativi dei Giochi Super Semplificati sugli Smartphone\nAnche i giochi super semplificati degli smartphone possono portare a diverse conseguenze più o meno gravi se utilizzati senza consapevolezza.\nMeccanismi di Dipendenza e Monetizzazione\nI giochi super semplificati utilizzano una serie di strategie per catturare l’attenzione e stimolare comportamenti di gioco compulsivi:\n\nGratificazione Immediata: Offrono ricompense rapide e frequenti, attivando il sistema di gratificazione dopaminergica del cervello. Questo induce gli utenti a desiderare di continuare a giocare per ottenere ulteriori ricompense.\nProgressione Incrementale: Presentano livelli o sfide che aumentano gradualmente in difficoltà, incoraggiando gli utenti a investire più tempo (e denaro) per progredire.\nAcquisti In-App e Microtransazioni: Propongono acquisti all’interno dell’applicazione per sbloccare contenuti, potenziamenti o per accelerare i progressi nel gioco (microtransazioni), spesso utilizzando valute virtuali che mascherano la percezione della spesa reale, con conseguenze gravi simili a quelli della ludopatia.\nEventi a Tempo Limitato: Introducono eventi o promozioni disponibili solo per un periodo limitato, creando un senso di urgenza e di paura di perdere un’opportunità (FOMO - Fear of Missing Out).\n\nImpatto sulle Capacità Cognitive\nL’interazione prolungata con questi giochi può avere diversi effetti sulle funzioni cognitive degli utenti:\n\nRiduzione dell’Attenzione Sostenuta: L’abitudine a stimoli rapidi e continui può diminuire la capacità di mantenere l’attenzione su compiti che richiedono concentrazione prolungata, come lo studio o il lavoro.\nAumento dell’Impulsività: La gratificazione immediata può rafforzare comportamenti impulsivi, rendendo più difficile resistere a tentazioni o prendere decisioni ponderate.\nInterferenza con l’Apprendimento: Il tempo e l’energia mentale dedicati ai giochi possono sottrarre risorse cognitive ad attività più produttive, influenzando negativamente l’apprendimento e la memoria.\nDipendenza Comportamentale: L’uso compulsivo può sfociare in una vera e propria dipendenza da gioco, con sintomi simili a quelli delle dipendenze da sostanze, inclusi isolamento sociale, irritabilità e perdita di interesse per altre attività.\n\nRicerche Scientifiche\n\nKing, D. L., Delfabbro, P. H., &amp; Griffiths, M. D. (2019). “Video game monetization (e.g., ‘loot boxes’): a blueprint for practical social responsibility measures”. International Journal of Mental Health and Addiction, 17(1), 166-179.\nHorvath, J., Mundinger, C., Schmitgen, M. M., Wolf, N. D., Sambataro, F., &amp; Hirjak, D. (2020). “Structural and functional correlates of smartphone addiction”. Frontiers in Psychiatry, 11, 22.\nDong, G., Li, H., Wang, L., &amp; Potenza, M. N. (2017). “Cognitive control and reward/loss processing in Internet gaming disorder: Results from a comparison with recreational Internet game-users”. European Neuropsychopharmacology, 27(8), 837-847.\n\nFelicità a Breve Termine vs Felicità a Lungo Termine\nFelicità a breve termine\nLa felicità a breve termine si riferisce al piacere immediato che proviene dalla gratificazione istantanea. È spesso legata al soddisfacimento di desideri momentanei, come ottenere un “like” sui social media, guardare un video su TikTok o usare una sostanza stupefacente. Questo tipo di felicità è di natura transitoria e si esaurisce rapidamente, il che spinge l’individuo a cercare continuamente nuove fonti di gratificazione per mantenere lo stesso livello di piacere.\n\nEffetto temporaneo: Anche se l’interazione sui social media può fornire un senso di appagamento immediato, il suo effetto tende a essere di breve durata. Proprio come il piacere derivante dal consumo di sostanze come l’alcol o la marijuana, la gratificazione a breve termine svanisce velocemente, lasciando l’individuo con un desiderio crescente di ulteriori stimoli per mantenere la stessa sensazione di benessere.\nCiclo continuo: Il problema principale della felicità a breve termine è che, essendo fugace, tende a stimolare la ricerca incessante di nuove gratificazioni. Quando il piacere svanisce, l’individuo avverte un vuoto o insoddisfazione che lo spinge a ripetere il comportamento (come controllare continuamente le notifiche sui social media), creando così un circolo vizioso che a lungo andare diventa impossibile da saziare. Proprio come accade per le sostanze stupefacenti, il nostro cervello diventa sempre più tollerante col ripetersi degli stimoli, per cui per raggiungere lo stesso livello di “felicità” necessitiamo di una dose sempre più maggiore, entrando in un circolo vizioso che a lungo andare diventa impossibile da saziare, e può causare gravi danni alla salute.\n\nIl vero ruolo della dopamina\nLa dopamina è un ormone fondamentale per il corretto funzionamento dell’organismo. Finora abbiamo esaminato come questo neurotrasmettitore possa essere utilizzato per creare dipendenze. Tuttavia, come abbiamo visto, la dopamina non si attiva solo in situazioni negative: essa viene rilasciata in risposta a ricompense e all’anticipazione delle stesse. Questo meccanismo non è sempre dannoso, poiché la dopamina svolge un ruolo cruciale nel motivare l’individuo a soddisfare i bisogni primari (come mangiare, dormire e rilassarsi), oltre a stimolare il raggiungimento di obiettivi e ambizioni, sia in ambito lavorativo, sociale che sportivo.\nEsempio di sfruttamento della dopamina\nUn esempio di come la dopamina “positiva” possa essere sfruttata riguarda il consumo di cibo. In condizioni normali, mangiare quando si ha fame innesca il rilascio di dopamina, generando una sensazione di soddisfazione legata al fatto di aver ripristinato le energie necessarie per la sopravvivenza. Questo è un meccanismo naturale e positivo, che motiva l’organismo a mantenere un comportamento sano.\nTuttavia, questo stesso sistema può essere manipolato attraverso strategie come l’uso del bliss point. Il bliss point è una combinazione precisa di zuccheri, grassi e sale che viene studiata e applicata dall’industria alimentare per rendere certi cibi irresistibili. Quando consumiamo alimenti progettati per raggiungere il bliss point, il rilascio di dopamina è molto più intenso rispetto a quando mangiamo per semplice fame. Questo eccessivo rilascio di dopamina spinge le persone a desiderare e consumare di più, anche quando non hanno realmente fame, portando potenzialmente a dipendenze alimentari e comportamenti non salutari.\nIn questo modo, il naturale meccanismo di ricompensa del cervello, che dovrebbe motivarci a mangiare per sopravvivere, viene sfruttato per incentivare un consumo eccessivo, facendo leva su una risposta dopaminergica esagerata.\nFelicità a lungo termine\nConoscendo il ruolo della dopamina, possiamo definire un tipo di felicità che si contrappone alla felicità a breve termine, ovvero la felicità a lungo termine. La felicità a lungo termine, si basa su fattori più profondi e duraturi, come il senso di appartenenza, relazioni autentiche, obiettivi personali, e crescita personale. A differenza della felicità immediata, questa richiede tempo, impegno e dedizione, ma i suoi effetti sono molto più stabili e significativi nel tempo.\nQuindi la felicità a lungo termine non deriva da una gratificazione immediata, ma dalla costruzione graduale di un senso di scopo e soddisfazione, come ad esempio lo sviluppo di relazioni interpersonali profonde o il raggiungimento di traguardi personali a lungo termine.\nOvviamente, a differenza della felicità a breve termine, la felicità a lungo termine non è facilmente raggiungibile. Richiede uno sforzo costante e il superamento di sfide. Ad esempio, la costruzione di relazioni autentiche con altre persone richiede fiducia e vulnerabilità, mentre il raggiungimento di obiettivi significativi, come il miglioramento delle proprie competenze o il perseguimento di una carriera appagante, comporta impegno, sacrificio e tempo.\n\nEsempi pratici:\n\nSport e attività fisiche: Praticare regolarmente uno sport o un’attività fisica è un esempio classico di come si possa ottenere una felicità duratura. Sebbene possa essere difficile iniziare, nel lungo termine contribuisce a migliorare la salute fisica e mentale, portando a un benessere sostenibile. Questo fattore si amplifica ulteriormente quando si prende un impegno costante, come ad esempio un impegno agonistico in uno sport di squadra, con allenamenti prefissati e partite di campionato.\nHobby e crescita personale: Coltivare un hobby che richiede pratica e dedizione, come suonare uno strumento musicale, imparare una nuova lingua o partecipare ad attività creative, produce soddisfazioni profonde che persistono nel tempo.\nRelazioni reali: Le relazioni autentiche con amici e familiari, basate su fiducia reciproca e condivisione, rappresentano una fonte fondamentale di felicità a lungo termine. Queste relazioni offrono supporto emotivo e senso di appartenenza, fattori essenziali per il benessere psicologico.\nProprio come avviene nel mondo degli investimenti, dove diversificare il capitale aiuta a ridurre i rischi, anche la nostra felicità dovrebbe poggiare su più pilastri. Se, per esempio, basassimo la nostra felicità esclusivamente sul lavoro, un insuccesso in quell’ambito potrebbe farci vacillare, spingendoci verso dipendenze o soluzioni illusorie per un piacere immediato. Per questo è fondamentale coltivare diversi ambiti nella nostra vita. Se, oltre al lavoro, abbiamo uno sport agonistico, una famiglia, e altre passioni, quando uno di questi pilastri vacilla, gli altri ci sostengono, permettendoci di affrontare le difficoltà e riportare equilibrio.\n\n\n\nQuindi i social sono il male assoluto?\nAssolutamente no. Chiaramente, nessuno ci vieta di includere tra questi pilastri anche qualche piccola soddisfazione a breve termine. Possiamo dedicarci anche ai social durante il giorno, per rilassarci o distrarci, senza che diventino il centro della nostra felicità. L’importante è che queste attività siano bilanciate e rimangano un piacere marginale, non una dipendenza. Inserire piccole gratificazioni immediate nella nostra routine può essere positivo, purché siano gestite con consapevolezza e non sostituiscano i pilastri più profondi e duraturi della nostra vita.\nConfronto tra felicità a breve e lungo termine\nSebbene la felicità a breve termine sia facilmente accessibile e immediata, essa tende a essere superficiale e di durata limitata. D’altra parte, la felicità a lungo termine richiede sforzo e pazienza, ma porta a una soddisfazione più stabile e duratura nel tempo. L’uso eccessivo dei social media tende a favorire la ricerca di gratificazioni a breve termine, che possono portare a dipendenza e frustrazione, mentre la costruzione di relazioni significative e il raggiungimento di obiettivi personali promuovono un benessere più sostenibile.\nRiferimenti scientifici\nNumerosi studi hanno dimostrato che un uso moderato dei social media, in combinazione con attività che promuovono la crescita personale e le relazioni autentiche, è associato a un benessere psicologico a lungo termine. Un esempio significativo è l’Harvard Grant Study, uno degli studi più estesi e duraturi sul benessere umano, che ha monitorato un gruppo di uomini per oltre 75 anni. I risultati hanno mostrato che le relazioni interpersonali di qualità erano il fattore più importante per la felicità e la salute a lungo termine, più ancora della ricchezza o del successo professionale (Vaillant, 2012). Inoltre, altre ricerche hanno indicato che l’uso eccessivo dei social media, quando diventa una ricerca compulsiva di gratificazioni a breve termine, può portare a un calo della soddisfazione generale della vita e ad aumenti nei sintomi di ansia e depressione (Twenge et al., 2018).\nFonti\n\nVaillant, G. E. (2012). Triumphs of Experience: The Men of the Harvard Grant Study. Harvard University Press.\nTwenge, J. M., et al. (2018). “Increases in depressive symptoms, suicide-related outcomes, and suicide rates among U.S. adolescents after 2010 and links to increased new media screen time”. Clinical Psychological Science.\n\nCome Spezzare il Ciclo della Dipendenza\nNon averne bisogno in primis\nLa miglior cura contro le dipendenze è… non averne bisogno. Sicuramente  coltivare una felicità più profonda e duratura è dunque la vera unica cura definitiva che abbiamo a disposizione. Quando riempiamo la nostra vita con attività che generano una soddisfazione autentica — come gli hobby, lo sport, le relazioni significative e il raggiungimento di obiettivi personali — il bisogno di cercare gratificazione rapida diminuisce. Investire in queste aree aiuta a costruire una base di benessere stabile, che rende meno attraenti le gratificazioni effimere offerte da sostanze psicoattive e smartphone.\nVideogiochi Complessi e i Loro Effetti Positivi\nOltre ai videogiochi semplici e progettati per la gratificazione istantanea, esistono videogiochi complessi che richiedono impegno, abilità e pianificazione. Questi giochi, spesso caratterizzati da trame articolate, meccaniche strategiche e sfide progressivamente più impegnative, possono avere effetti positivi sullo sviluppo personale e sul benessere mentale.\nA differenza dei giochi iper-semplificati per smartphone, i videogiochi complessi incoraggiano una connessione profonda con il contenuto e richiedono una maggiore dedizione e concentrazione. Tra i benefici associati a questi tipi di videogiochi troviamo:\n\nSviluppo di abilità cognitive: Giochi strategici, di ruolo (RPG) e di simulazione migliorano abilità come il problem-solving, il pensiero critico e la capacità di pianificazione a lungo termine.\nCooperazione e lavoro di squadra: I giochi multiplayer cooperativi stimolano le abilità sociali, la comunicazione e la capacità di lavorare in gruppo per raggiungere obiettivi comuni.\nApprendimento della resilienza: I giochi complessi spesso includono fallimenti come parte del processo di crescita, insegnando ai giocatori a gestire la frustrazione e a perseverare per raggiungere i propri obiettivi.\nQuesti tipi di videogiochi, grazie alla loro profondità e alle sfide che pongono, offrono una gratificazione che va oltre il semplice intrattenimento e possono contribuire positivamente alla costruzione di abilità utili anche nella vita reale.\nBisogna tuttavia fare attenzione a non abusare neanche di questi, in modo che non vadano a sostituire completamente il mondo reale.\n\nDigital Detox\nIl Digital Detox è un processo di disconnessione temporanea o ridotta dall’uso di dispositivi elettronici, in particolare dalle piattaforme di social media, con l’obiettivo di migliorare il benessere mentale e fisico. Questo approccio consente di interrompere il ciclo di dipendenza e di riscoprire abitudini più sane, favorendo il ripristino della capacità di concentrazione e la riduzione dello stress.\n\nImpostare limiti di tempo: Utilizzare applicazioni o le impostazioni del dispositivo per limitare il tempo giornaliero trascorso sui social media, ad esempio impostando un limite massimo di 30 minuti al giorno.\nEliminare le notifiche superflue: Le notifiche sono una delle principali cause di interruzione e possono contribuire alla dipendenza. Disattivarle permette di mantenere un maggiore controllo sull’uso del dispositivo.\n\nSviluppo di un uso consapevole\nPer evitare di cadere nuovamente nella dipendenza, è essenziale sviluppare un uso consapevole dei social media. Questo approccio prevede l’adozione di strategie per bilanciare l’uso della tecnologia con altri aspetti della vita, mantenendo il controllo sulle proprie abitudini digitali.\n\nPianificare l’uso dei social media: Stabilire momenti specifici della giornata per controllare i social, evitando un uso casuale e continuo. Ad esempio, limitarsi a controllare i social una o due volte al giorno per un tempo definito.\nEssere selettivi sui contenuti: Ridurre il numero di account seguiti e concentrarsi solo su quelli che apportano valore, come contenuti educativi o ispiranti, anziché seguire account che provocano stress o insoddisfazione.\nRiflessione post-utilizzo: Dopo ogni sessione sui social media, prendere qualche minuto per riflettere su come ci si sente. Questa pratica aiuta a sviluppare consapevolezza sull’effetto emotivo che l’uso dei social ha sul proprio benessere.\n\nRiferimenti Scientifici\n\nHunt, M. G., Marx, R., Lipson, C., &amp; Young, J. (2018). “No more FOMO: Limiting social media decreases loneliness and depression”. Journal of Social and Clinical Psychology.\nTwenge, J. M., et al. (2020). “Associations between screen time and lower psychological well-being among children and adolescents: Evidence from a population-based study”. Preventive Medicine Reports.\nGlass, B. D., Maddox, W. T., &amp; Love, B. C. (2013). “Real-time strategy game training: Emergence of a cognitive flexibility trait”. Frontiers in Psychology, 4, 613.\nAdachi, P. J., &amp; Willoughby, T. (2020). “The link between playing video games and positive youth behaviors: A longitudinal study”. Cyberpsychology, Behavior, and Social Networking, 23(6), 409-415.\nBeylefeld, A., Joubert, G., Jama, M. P., &amp; Louw, I. (2017). “Assessing the role of video games in building resilience and frustration tolerance in youth”. Journal of Youth and Adolescence, 46(10), 2133-2146.\n\nConclusione\nIn questa dispensa abbiamo esplorato i principali concetti relativi alla dipendenza dallo smartphone, altre sostanze psicoattive e i loro effetti sul benessere psicologico e fisico. È stato evidenziato il contrasto tra gratificazione immediata e benessere duraturo, sottolineando come l’uso compulsivo dei social media, incentivato da meccanismi di ricompensa immediata come “like” e notifiche, possa portare a disturbi cognitivi ed emotivi, quali ansia, depressione e riduzione della capacità di concentrazione. Abbiamo analizzato le similitudini tra le dipendenze comportamentali e quelle da sostanze come l’alcol e la marijuana, dimostrando che entrambi i tipi di dipendenza seguono un ciclo di gratificazione, tolleranza e bisogno crescente.\nInoltre, abbiamo discusso come spezzare il ciclo della dipendenza attraverso strategie come il Digital Detox, la costruzione di relazioni autentiche e l’adozione di un uso consapevole dei social media, il tutto supportato da ricerche scientifiche che dimostrano i benefici di una riduzione dell’uso dei dispositivi digitali.\nSuggerimenti per Coinvolgere gli Studenti\nEsercizi pratici\nIncorporare esercizi pratici al termine di alcune sezioni può aiutare gli studenti a riflettere sulle proprie abitudini digitali e a interiorizzare meglio i concetti trattati. Alcuni esempi di esercizi pratici includono:\n\nQuanto tempo passi sui social media ogni giorno?\n\nChiedi agli studenti di monitorare per una settimana il tempo trascorso sui social media utilizzando app di monitoraggio come “Screen Time” (iOS) o “Digital Wellbeing” (Android). Successivamente, invitali a riflettere su come questo tempo potrebbe essere impiegato diversamente.\n\n\nQuali sono le attività che ti rendono felice a lungo termine?\n\nInvita gli studenti a scrivere un elenco di attività che li fanno sentire realizzati o felici nel lungo periodo (es. praticare sport, hobby, passare del tempo con amici e familiari). Successivamente, chiedi loro di confrontare queste attività con quelle che offrono una gratificazione immediata, come l’uso dei social media.\n\n\nChe impatto ha il confronto sociale su di te?\n\nFai riflettere gli studenti sul modo in cui i confronti sociali sui social media influenzano il loro benessere emotivo. Invitali a scrivere brevi riflessioni su come reagiscono alle immagini o ai post degli altri.\n\n\n\nRiflessioni di gruppo\nLe discussioni di gruppo sono uno strumento utile per incoraggiare gli studenti a condividere le proprie esperienze e abitudini digitali, promuovendo un apprendimento collaborativo e riflessivo. Alcune attività suggerite:\n\nDiscussione sulle abitudini digitali: Dividi gli studenti in piccoli gruppi e chiedi loro di discutere le proprie abitudini di utilizzo dei social media, evidenziando i pro e i contro. Invita ogni gruppo a presentare le proprie conclusioni alla classe, favorendo un dibattito più ampio.\nCome spezzare il ciclo della dipendenza: Organizza una discussione in cui gli studenti esplorano strategie personali per ridurre l’uso dei social media e promuovere un uso più consapevole della tecnologia. Potrebbero confrontare le loro esperienze di Digital Detox o suggerire modi per migliorare il benessere a lungo termine.\n\nQuiz o domande finali\nIncludere un quiz alla fine della dispensa aiuta a verificare la comprensione degli studenti sui concetti chiave trattati e a stimolare una riflessione più profonda sui temi. Ecco alcune domande possibili:\n\nCos’è la dopamina e quale ruolo svolge nelle dipendenze comportamentali?\nQual è la differenza tra gratificazione immediata e felicità a lungo termine?\nQuali sono tre strategie pratiche per spezzare il ciclo della dipendenza dai social media?\nQuali sono i principali effetti negativi dell’abuso di alcol e marijuana sui giovani?\nCome influisce l’uso eccessivo dei social media sulla qualità del sonno?\nQuesti strumenti non solo rendono l’apprendimento più interattivo, ma forniscono anche agli studenti l’opportunità di confrontare le proprie esperienze con i concetti appresi, favorendo così un approccio più consapevole e critico all’uso della tecnologia.\n"},"Argomenti/Educazione-Civica/Dipendenza-fisica-e-digitale/Lavoro-a-gruppi":{"slug":"Argomenti/Educazione-Civica/Dipendenza-fisica-e-digitale/Lavoro-a-gruppi","filePath":"Argomenti/Educazione Civica/Dipendenza fisica e digitale/Lavoro a gruppi.md","title":"Lavoro a gruppi","links":[],"tags":[],"content":"Progetto: “Il Nostro Benessere Digitale”\n1. Introduzione all’attività (10 minuti)\n\nObiettivo: Riflettere sul nostro rapporto con la tecnologia e proporre semplici strategie per migliorarlo.\nDivisione della classe in gruppi di 4-5 studenti.\n\n\n2. Lavoro di gruppo (30-40 minuti)\nFase 1: Riflessione collettiva (10-15 minuti)\nIn ogni gruppo, gli studenti rispondono insieme a queste domande:\n\nQuanto tempo trascorriamo online? Quali app o attività occupano più tempo?\nSentiamo di essere dipendenti (fisicamente/psicologicamente)? Quali effetti negativi ci sta provocando questa dipendenza?\nCome ci spinge il mondo odierno verso il consumo e la dipendenza?\nQuali attività offline ci piacerebbe fare di più?\nVarie esperienze dei membri del gruppo o dei loro conoscenti\n\nFase 2: Proposta di soluzioni (20-25 minuti)\nIl gruppo elabora un “Mini Piano di Benessere Digitale”:\n\nUna strategia per ridurre il tempo online e altre dipendenze\nAttività che vogliamo introdurre o valorizzare per essere più felici utilizzando il tempo guadagnato eliminando la dipendenza.\nCome possiamo aiutare più persone a comprendere il problema e ad essere più felici e liberi dalle dipendenza\n\n\n3. Presentazioni rapide in circle time (20-30 minuti)\n\nOgni gruppo presenta il proprio piano in 5 minuti circa.\nGli altri ascoltano e possono fare domande o dare feedback brevi.\n\n\n4. Conclusione collettiva in circle-time (10 minuti)\n\nConcludi con una breve discussione plenaria:\n\nQuali strategie sono risultate più efficaci o innovative?\nQuali attività offline possiamo iniziare subito?\nUn messaggio finale: come possiamo aiutare noi stessi e gli altri\n\n\n\n5. Elaborare a casa una relazione scritta su tutta l’esperienza in classe, incluso il lavoro di gruppo e consegnarla"},"Argomenti/Fattorizzazione-del-codice-e-makefile/Code-smells-e-refactoring---Esercizi-complessi":{"slug":"Argomenti/Fattorizzazione-del-codice-e-makefile/Code-smells-e-refactoring---Esercizi-complessi","filePath":"Argomenti/Fattorizzazione del codice e makefile/Code smells e refactoring - Esercizi complessi.md","title":"Code smells e refactoring - Esercizi complessi","links":[],"tags":[],"content":"Codice duplicato, funzione troppo lunga, lista di parametri troppo lunga e feature envy\nEsercizio 1\nCodice Originale con Smell\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n \ntypedef struct {\n    double width, height, depth;\n} Box;\n \n// Calcolo del volume di un Box\ndouble calculateVolume(double width, double height, double depth) {\n    return width * height * depth;\n}\n \n// Funzione per calcolare e confrontare i volumi di tre Box\nvoid compareBoxes(Box box1, Box box2, Box box3, double *vol1, double *vol2, double *vol3, int *largest) {\n    *vol1 = calculateVolume(box1.width, box1.height, box1.depth);\n    *vol2 = calculateVolume(box2.width, box2.height, box2.depth);\n    *vol3 = calculateVolume(box3.width, box3.height, box3.depth);\n \n    if (*vol1 &gt; *vol2 &amp;&amp; *vol1 &gt; *vol3) {\n        *largest = 1;\n    } else if (*vol2 &gt; *vol1 &amp;&amp; *vol2 &gt; *vol3) {\n        *largest = 2;\n    } else {\n        *largest = 3;\n    }\n}\n \nint main() {\n    Box box1 = {3.0, 4.0, 5.0};\n    Box box2 = {2.0, 6.0, 8.0};\n    Box box3 = {5.0, 3.0, 7.0};\n    \n    double volume1, volume2, volume3;\n    int largestBox;\n \n    compareBoxes(box1, box2, box3, &amp;volume1, &amp;volume2, &amp;volume3, &amp;largestBox);\n \n    printf(&quot;Volume of Box 1: %.2f\\n&quot;, volume1);\n    printf(&quot;Volume of Box 2: %.2f\\n&quot;, volume2);\n    printf(&quot;Volume of Box 3: %.2f\\n&quot;, volume3);\n    printf(&quot;Box %d has the largest volume.\\n&quot;, largestBox);\n \n    return 0;\n}\nIn questo codice, la funzione compareBoxes è troppo lunga, presenta una lista di parametri eccessivamente estesa e mostra un’implementazione ripetitiva del calcolo del volume. Inoltre, dimostra un certo grado di feature envy rispetto alla struttura Box, poiché manipola direttamente i suoi attributi invece di delegare il calcolo del volume alla struttura stessa.\nRefactoring del Codice\nIl refactoring mirerà a ridurre la complessità della funzione, ridurre la lunghezza della lista dei parametri e spostare la responsabilità del calcolo del volume all’interno della struttura Box.\nEcco come potrebbe essere migliorato:\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n \ntypedef struct {\n    double width, height, depth;\n} Box;\n \n// Sposta il calcolo del volume all&#039;interno della struttura Box\ndouble calculateVolume(Box *b) {\n    return b-&gt;width * b-&gt;height * b-&gt;depth;\n}\n \n// Refactoring della funzione per comparare i Box\nint compareBoxes(Box *boxes, int n) {\n    int largest = 0;\n    double maxVolume = 0;\n    for (int i = 0; i &lt; n; i++) {\n        double vol = calculateVolume(&amp;boxes[i]);\n        if (vol &gt; maxVolume) {\n            maxVolume = vol;\n            largest = i;\n        }\n    }\n    return largest + 1; // +1 perché gli indici partono da 0\n}\n \nint main() {\n    Box boxes[3] = {{3.0, 4.0, 5.0}, {2.0, 6.0, 8.0}, {5.0, 3.0, 7.0}};\n    \n    int largestBox = compareBoxes(boxes, 3);\n \n    for (int i = 0; i &lt; 3; i++) {\n        printf(&quot;Volume of Box %d: %.2f\\n&quot;, i + 1, calculateVolume(&amp;boxes[i]));\n    }\n    printf(&quot;Box %d has the largest volume.\\n&quot;, largestBox);\n \n    return 0;\n}\nIn questa versione, la funzione calculateVolume è ora un metodo di Box, riducendo il feature envy. La funzione compareBoxes è stata semplificata e ora prende un array di Box e la sua dimensione, riducendo la lunghezza della lista dei parametri.\nCodice duplicato, magic numbers e semplificazione espressioni\nEsercizio 1\nCreerò un altro esempio di codice C che simuli un programma reale e poi mostrerò come migliorarlo con il refactoring. Questo esempio simulerà un sistema di prenotazione per una piccola biblioteca, con “code smell” intenzionali che verranno poi risolti.\nCodice Originale con smell\nQuesto esempio simula un sistema di prenotazione di libri in una biblioteca.\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n \n#define NUMERO_LIBRI 5\n \ntypedef struct {\n    char titolo[50];\n    int disponibile;\n} Libro;\n \nvoid prenotaLibro(Libro libri[], char *titolo) {\n    for (int i = 0; i &lt; NUMERO_LIBRI; i++) {\n        if (strcmp(libri[i].titolo, titolo) == 0) {\n            if (libri[i].disponibile == 1) {\n                libri[i].disponibile = 0;\n                printf(&quot;Libro &#039;%s&#039; prenotato con successo.\\n&quot;, titolo);\n                return;\n            } else {\n                printf(&quot;Il libro &#039;%s&#039; non è disponibile.\\n&quot;, titolo);\n                return;\n            }\n        }\n    }\n    printf(&quot;Libro &#039;%s&#039; non trovato.\\n&quot;, titolo);\n}\n \nint main() {\n    Libro libreria[NUMERO_LIBRI] = {\n        {&quot;Il Signore degli Anelli&quot;, 1},\n        {&quot;1984&quot;, 1},\n        {&quot;Il Piccolo Principe&quot;, 1},\n        {&quot;Il Grande Gatsby&quot;, 1},\n        {&quot;Moby Dick&quot;, 1}\n    };\n \n    prenotaLibro(libreria, &quot;Il Signore degli Anelli&quot;);\n    prenotaLibro(libreria, &quot;Moby Dick&quot;);\n    prenotaLibro(libreria, &quot;Guerra e Pace&quot;);\n \n    return 0;\n}\nRefactoring del Codice\nIl refactoring mira a migliorare la struttura del codice senza modificarne il comportamento esterno. Qui sotto, ho rifattorizzato il codice per risolvere i “code smell” identificati.\n\nRimozione del Codice Duplicato: Ho centralizzato la logica di controllo della disponibilità dei libri in una funzione separata.\nRisoluzione dei Magic Numbers: Ho definito costanti per rappresentare lo stato di disponibilità dei libri.\nSemplificazione delle Espressioni: Ho reso più chiara la logica di prenotazione e ricerca dei libri.\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n \n#define NUMERO_LIBRI 5\n#define DISPONIBILE 1\n#define NON_DISPONIBILE 0\n \ntypedef struct {\n    char titolo[50];\n    int disponibile;\n} Libro;\n \n// Funzione per verificare la disponibilità e prenotare un libro\nint prenotaSeDisponibile(Libro *libro, const char *titolo) {\n    if (strcmp(libro-&gt;titolo, titolo) == 0) {\n        if (libro-&gt;disponibile == DISPONIBILE) {\n            libro-&gt;disponibile = NON_DISPONIBILE;\n            return 1;  // Prenotazione riuscita\n        }\n        return 0;  // Libro non disponibile\n    }\n    return -1;  // Libro non trovato\n}\n \nvoid prenotaLibro(Libro libri[], const char *titolo) {\n    for (int i = 0; i &lt; NUMERO_LIBRI; i++) {\n        int risultato = prenotaSeDisponibile(&amp;libri[i], titolo);\n        if (risultato != -1) {\n            if (risultato == 1) {\n                printf(&quot;Libro &#039;%s&#039; prenotato con successo.\\n&quot;, titolo);\n            } else {\n                printf(&quot;Il libro &#039;%s&#039; non è disponibile.\\n&quot;, titolo);\n            }\n            return;\n        }\n    }\n    printf(&quot;Libro &#039;%s&#039; non trovato.\\n&quot;, titolo);\n}\n \nint main() {\n    Libro libreria[NUMERO_LIBRI] = {\n        {&quot;Il Signore degli Anelli&quot;, DISPONIBILE},\n        {&quot;1984&quot;, DISPONIBILE},\n        {&quot;Il Piccolo Principe&quot;, DISPONIBILE},\n        {&quot;Il\n \n Grande Gatsby&quot;, DISPONIBILE},\n        {&quot;Moby Dick&quot;, DISPONIBILE}\n    };\n \n    prenotaLibro(libreria, &quot;Il Signore degli Anelli&quot;);\n    prenotaLibro(libreria, &quot;Moby Dick&quot;);\n    prenotaLibro(libreria, &quot;Guerra e Pace&quot;);\n \n    return 0;\n}\nQuesto refactoring rende il codice più leggibile, manutenibile e riduce la possibilità di errori.\nVari\nEsercizio 1\nPer creare un esempio di codice con gli odori di codice (code smells) che hai richiesto, userò il linguaggio C. Il codice presenterà diversi odori tra cui codice duplicato, funzione troppo lunga, lista di parametri troppo lunga, invidia di feature (feature envy), numeri magici, espressioni complesse e nomi oscuri. Eviterò di usare commenti esplicativi che potrebbero rivelare direttamente gli odori del codice.\nEcco un esempio di funzione che calcola i dettagli di un pagamento, dimostrando vari odori di codice:\n#include &lt;stdio.h&gt;\n \ntypedef struct {\n    int giorno;\n    int mese;\n    int anno;\n} Data;\n \ntypedef struct {\n    Data data_inizio;\n    Data data_fine;\n    int ore;\n    int tariffa;\n} DettagliLavoro;\n \nvoid calcolaPagamento(int g1, int m1, int a1, int g2, int m2, int a2, int ore, int tariffa) {\n    Data data_inizio = {g1, m1, a1};\n    Data data_fine = {g2, m2, a2};\n    DettagliLavoro dettagli = {data_inizio, data_fine, ore, tariffa};\n \n    int giorni_totali = (data_fine.anno - data_inizio.anno) * 365 + (data_fine.mese - data_inizio.mese) * 30 + (data_fine.giorno - data_inizio.giorno);\n    int ore_totali = giorni_totali * 24 + dettagli.ore;\n    int pagamento = ore_totali * dettagli.tariffa;\n \n    printf(&quot;Pagamento totale: %d\\n&quot;, pagamento);\n \n    if (ore_totali &gt; 160) {\n        int bonus = (ore_totali - 160) * 15;\n        printf(&quot;Bonus: %d\\n&quot;, bonus);\n    }\n \n    if (ore_totali &gt; 160) {\n        int extra = (ore_totali - 160) * 15;\n        printf(&quot;Extra: %d\\n&quot;, extra);\n    }\n}\n \nint main() {\n    calcolaPagamento(1, 1, 2023, 31, 1, 2023, 172, 50);\n    return 0;\n}\nQuesto codice presenta vari odori:\n\nCodice Duplicato: Il calcolo del bonus e dell’extra è quasi identico.\nFunzione Troppo Lunga: calcolaPagamento fa più di quanto dovrebbe (calcolo di date, ore, pagamento, bonus).\nLista di Parametri Troppo Lunga: calcolaPagamento ha troppi parametri.\nNumeri Magici: I numeri come 365, 30, 24, 160, 15 sono usati direttamente senza spiegazione.\nEspressioni Complesse: Il calcolo di giorni_totali e ore_totali è piuttosto complesso e poco chiaro.\nNomi Oscuri: Nomi come g1, m1, a1 non sono descrittivi.\n\nCerto, procederò ora con il refactoring del codice per risolvere i vari odori di codice identificati. Ecco una versione migliorata:\n#include &lt;stdio.h&gt;\n \ntypedef struct {\n    int giorno;\n    int mese;\n    int anno;\n} Data;\n \ntypedef struct {\n    Data data_inizio;\n    Data data_fine;\n    int ore;\n    int tariffa_oraria;\n} DettagliLavoro;\n \nint calcolaGiorniTraDate(Data inizio, Data fine) {\n    const int giorni_per_anno = 365;\n    const int giorni_per_mese = 30;\n    return (fine.anno - inizio.anno) * giorni_per_anno + (fine.mese - inizio.mese) * giorni_per_mese + (fine.giorno - inizio.giorno);\n}\n \nint calcolaOreTotali(DettagliLavoro dettagli) {\n    const int ore_per_giorno = 24;\n    int giorni_totali = calcolaGiorniTraDate(dettagli.data_inizio, dettagli.data_fine);\n    return giorni_totali * ore_per_giorno + dettagli.ore;\n}\n \nint calcolaPagamento(DettagliLavoro dettagli) {\n    int ore_totali = calcolaOreTotali(dettagli);\n    return ore_totali * dettagli.tariffa_oraria;\n}\n \nint calcolaBonus(int ore_totali) {\n    const int ore_standard = 160;\n    const int bonus_per_ora_extra = 15;\n    if (ore_totali &gt; ore_standard) {\n        return (ore_totali - ore_standard) * bonus_per_ora_extra;\n    }\n    return 0;\n}\n \nvoid stampaDettagliPagamento(DettagliLavoro dettagli) {\n    int pagamento = calcolaPagamento(dettagli);\n    int bonus = calcolaBonus(calcolaOreTotali(dettagli));\n \n    printf(&quot;Pagamento totale: %d\\n&quot;, pagamento);\n    printf(&quot;Bonus: %d\\n&quot;, bonus);\n}\n \nint main() {\n    DettagliLavoro dettagli = {{1, 1, 2023}, {31, 1, 2023}, 172, 50};\n    stampaDettagliPagamento(dettagli);\n    return 0;\n}\nModifiche apportate:\n\nRiduzione del Codice Duplicato: Ho rimosso il codice duplicato per il calcolo del bonus, creando una funzione calcolaBonus.\nFunzione Diminuita: Le funzioni calcolaGiorniTraDate, calcolaOreTotali, calcolaPagamento, e calcolaBonus sono state create per suddividere la logica in parti più piccole e gestibili.\nLista di Parametri Ridotta: Ho ridotto la lista di parametri passando strutture Data e DettagliLavoro invece di singoli valori.\nRimozione dei Numeri Magici: Ho definito costanti per i “numeri magici” come giorni_per_anno, ore_per_giorno, ecc.\nSemplificazione delle Espressioni Complesse: Le espressioni complesse sono state suddivise in funzioni più piccole e comprensibili.\nMiglioramento dei Nomi: Ho cambiato i nomi delle variabili per renderli più descrittivi, come tariffa_oraria invece di tariffa.\n\nQuesto refactoring rende il codice più leggibile, mantenibile e chiaro, risolvendo gli odori del codice precedentemente identificati.\nEsercizio 2\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n \ntypedef struct {\n    char title[50];\n    char author[50];\n    int year;\n    float price;\n} Book;\n \nBook bookArray[100];\nint bookCount = 0;\n \nvoid addBook(const char* title, const char* author, int year, float price) {\n    if (bookCount &gt;= 100) {\n        printf(&quot;Library is full.\\n&quot;);\n        return;\n    }\n \n    Book newBook;\n    strncpy(newBook.title, title, 49);\n    newBook.title[49] = &#039;\\0&#039;;\n    strncpy(newBook.author, author, 49);\n    newBook.author[49] = &#039;\\0&#039;;\n    newBook.year = year;\n    newBook.price = price;\n    \n    bookArray[bookCount++] = newBook;\n}\n \nvoid displayBooks() {\n    for (int i = 0; i &lt; bookCount; i++) {\n        printf(&quot;Book %d: %s by %s, %d, $%.2f\\n&quot;, i + 1, bookArray[i].title, bookArray[i].author, bookArray[i].year, bookArray[i].price);\n    }\n}\n \nint findBookIndexByTitle(const char* title) {\n    for (int i = 0; i &lt; bookCount; i++) {\n        if (strcmp(bookArray[i].title, title) == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n \nvoid searchBookByTitle(const char* title) {\n    int index = findBookIndexByTitle(title);\n    if (index != -1) {\n        printf(&quot;Found: %s by %s, %d, $%.2f\\n&quot;, bookArray[index].title, bookArray[index].author, bookArray[index].year, bookArray[index].price);\n    } else {\n        printf(&quot;Book not found.\\n&quot;);\n    }\n}\n \nvoid deleteBook(const char* title) {\n    int index = findBookIndexByTitle(title);\n    if (index == -1) {\n        printf(&quot;Book to delete not found.\\n&quot;);\n        return;\n    }\n    for (int i = index; i &lt; bookCount - 1; i++) {\n        bookArray[i] = bookArray[i + 1];\n    }\n    bookCount--;\n}\n \nvoid updateBookPrice(const char* title, float newPrice) {\n    int index = findBookIndexByTitle(title);\n    if (index != -1) {\n        bookArray[index].price = newPrice;\n    } else {\n        printf(&quot;Book not found to update price.\\n&quot;);\n    }\n}\n \nint main() {\n    addBook(&quot;The C Programming Language&quot;, &quot;Kernighan and Ritchie&quot;, 1978, 30.50);\n    addBook(&quot;Clean Code&quot;, &quot;Robert C. Martin&quot;, 2008, 25.60);\n \n    displayBooks();\n \n    searchBookByTitle(&quot;Clean Code&quot;);\n    deleteBook(&quot;Clean Code&quot;);\n    updateBookPrice(&quot;The C Programming Language&quot;, 35.99);\n \n    displayBooks();\n \n    return 0;\n}\n \n\n\nArray fisso: L’uso di un array fisso bookArray[100] per memorizzare i libri limita la scalabilità del sistema. Questo è un esempio di smell denominato “Dimensioni fisse” o “Risorse statiche”.\n\n\nDuplicazione del codice: La funzione strncpy viene utilizzata più volte in addBook in modo molto simile per copiare title e author nel nuovo libro. Questo potrebbe essere astratto in una funzione separata per ridurre la duplicazione.\n\n\nResponsabilità multiple: Le funzioni come addBook e deleteBook non solo aggiungono o rimuovono libri dall’array, ma gestiscono anche la logica di controllo come il controllo della capacità dell’array o la stampa di messaggi di errore. Questo viola il principio di Singola Responsabilità.\n\n\nUtilizzo di magic numbers: Numeri come 100 per la dimensione dell’array di libri e 49 per il limite di caratteri di title e author sono esempi di “magic numbers” che dovrebbero essere definiti come costanti nominative per migliorare la leggibilità e la manutenibilità.\n\n\nLong Method: Le funzioni addBook, displayBooks, deleteBook, e altre funzioni che gestiscono diverse operazioni sui libri tendono ad essere piuttosto lunghe e complesse. Questo può rendere il codice più difficile da comprendere e mantenere. Idealmente, queste funzioni dovrebbero essere suddivise in funzioni più piccole, ognuna delle quali svolge un compito specifico.\n\n\nManca l’incapsulamento: L’array bookArray e la variabile bookCount sono dichiarati a livello globale e direttamente accessibili/modificabili da qualsiasi parte del programma. Questo viola il principio di incapsulamento in programmazione orientata agli oggetti (OO). Sebbene C sia un linguaggio procedurale, è comunque possibile organizzare il codice in modo che simuli l’incapsulamento, ad esempio, utilizzando funzioni per accedere e modificare queste variabili.\n\n\nRefactoring\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n \n#define MAX_BOOKS 100\n#define MAX_TITLE_LENGTH 50\n#define MAX_AUTHOR_LENGTH 50\n#define NOT_FOUND -1\n \ntypedef struct {\n    char title[MAX_TITLE_LENGTH];\n    char author[MAX_AUTHOR_LENGTH];\n    int year;\n    float price;\n} Book;\n \ntypedef struct {\n    Book books[MAX_BOOKS];\n    int count;\n} Library;\n \nvoid initializeLibrary(Library *library) {\n    library-&gt;count = 0;\n}\n \nint addBook(Library *library, const char *title, const char *author, int year, float price) {\n    if (library-&gt;count &gt;= MAX_BOOKS) {\n        printf(&quot;Library is full.\\n&quot;);\n        return 0;\n    }\n \n    Book *newBook = &amp;library-&gt;books[library-&gt;count++];\n    strncpy(newBook-&gt;title, title, MAX_TITLE_LENGTH - 1);\n    newBook-&gt;title[MAX_TITLE_LENGTH - 1] = &#039;\\0&#039;;\n    strncpy(newBook-&gt;author, author, MAX_AUTHOR_LENGTH - 1);\n    newBook-&gt;author[MAX_AUTHOR_LENGTH - 1] = &#039;\\0&#039;;\n    newBook-&gt;year = year;\n    newBook-&gt;price = price;\n    return 1;\n}\n \nvoid displayBooks(const Library *library) {\n    for (int i = 0; i &lt; library-&gt;count; i++) {\n        printf(&quot;Book %d: %s by %s, %d, $%.2f\\n&quot;, i + 1, library-&gt;books[i].title, library-&gt;books[i].author, library-&gt;books[i].year, library-&gt;books[i].price);\n    }\n}\n \nvoid searchBooks(const Library *library, const char *searchTerm, int searchByAuthor) {\n    int found = 0;\n    for (int i = 0; i &lt; library-&gt;count; i++) {\n        if ((searchByAuthor &amp;&amp; strcmp(library-&gt;books[i].author, searchTerm) == 0) ||\n            (!searchByAuthor &amp;&amp; strcmp(library-&gt;books[i].title, searchTerm) == 0)) {\n            printf(&quot;Found: %s by %s, %d, $%.2f\\n&quot;, library-&gt;books[i].title, library-&gt;books[i].author, library-&gt;books[i].year, library-&gt;books[i].price);\n            found = 1;\n        }\n    }\n    if (!found) {\n        printf(searchByAuthor ? &quot;No books found by %s.\\n&quot; : &quot;Book not found.\\n&quot;, searchTerm);\n    }\n}\n \nint deleteBook(Library *library, const char *title) {\n    int index = findBookIndexByTitle(library, title);\n    if (index == NOT_FOUND) {\n        printf(&quot;Book to delete not found.\\n&quot;);\n        return 0;\n    }\n    for (int i = index; i &lt; library-&gt;count - 1; i++) {\n        library-&gt;books[i] = library-&gt;books[i + 1];\n    }\n    library-&gt;count--;\n    return 1;\n}\n \nint updateBookPrice(Library *library, const char *title, float newPrice) {\n    int index = findBookIndexByTitle(library, title);\n    if (index != NOT_FOUND) {\n        library-&gt;books[index].price = newPrice;\n        return 1;\n    } else {\n        printf(&quot;Book not found to update price.\\n&quot;);\n        return 0;\n    }\n}\n \nint main() {\n    Library myLibrary;\n    initializeLibrary(&amp;myLibrary);\n \n    addBook(&amp;myLibrary, &quot;The C Programming Language&quot;, &quot;Kernighan and Ritchie&quot;, 1978, 30.50);\n    addBook(&amp;myLibrary, &quot;Clean Code&quot;, &quot;Robert C. Martin&quot;, 2008, 25.60);\n \n    displayBooks(&amp;myLibrary);\n \n    searchBooks(&amp;myLibrary, &quot;Clean Code&quot;, 0);\n    searchBooks(&amp;myLibrary, &quot;Robert C. Martin&quot;, 1);\n \n    deleteBook(&amp;myLibrary, &quot;Clean Code&quot;);\n    updateBookPrice(&amp;myLibrary, &quot;The C Programming Language&quot;, 35.99);\n \n    printf(&quot;\\nAfter updates:\\n&quot;);\n    displayBooks(&amp;myLibrary);\n \n    return 0;\n}\n\nCostanti Definite: Sostituito i numeri magici con costanti, migliorando la leggibilità e facilitando la manutenzione.\nStruttura Library: Introdotta per ridurre l’uso di variabili globali, incapsulando l’array di libri e il conteggio in una struttura gestita passando puntatori alle funzioni.\nModularizzazione: Suddiviso il codice in funzioni più piccole e focalizzate, riducendo la duplicazione e separando le responsabilità.\nGestione degli Errori: Modificate alcune funzioni per restituire valori che indicano il successo o il fallimento dell’operazione, permettendo una migliore gestione degli errori.\n\nEsercizio 3\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n \nstruct Product {\n    char name[100];\n    float price;\n    int quantity;\n};\n \nstruct Product inventory[50]; \nint num_products = 0;\n \nvoid addProduct(char *name, float price, int quantity) {\n    if(num_products &gt;= 50) { \n        printf(&quot;Inventory is full!\\n&quot;);\n        return;\n    }\n    for(int i = 0; i &lt; num_products; i++) {\n        if(strcmp(inventory[i].name, name) == 0) {\n            printf(&quot;Product already exists.\\n&quot;);\n            return;\n        }\n    }\n    struct Product newProduct;\n    strncpy(newProduct.name, name, 100);\n    newProduct.name[99] = &#039;\\0&#039;;\n    newProduct.price = price;\n    newProduct.quantity = quantity;\n    inventory[num_products++] = newProduct;\n    printf(&quot;Product added successfully!\\n&quot;);\n}\n \nvoid removeProduct(char *name) {\n    int found = 0;\n    for(int i = 0; i &lt; num_products; i++) {\n        if(strcmp(inventory[i].name, name) == 0) {\n            found = 1;\n            for(int j = i; j &lt; num_products - 1; j++) {\n                inventory[j] = inventory[j + 1];\n            }\n            num_products--;\n            printf(&quot;Product removed successfully!\\n&quot;);\n            break;\n        }\n    }\n    if(!found) {\n        printf(&quot;Product not found.\\n&quot;);\n    }\n}\n \nvoid updateProduct(char *name, float price, int quantity) {\n    for(int i = 0; i &lt; num_products; i++) {\n        if(strcmp(inventory[i].name, name) == 0) {\n            inventory[i].price = price;\n            inventory[i].quantity = quantity;\n            printf(&quot;Product updated successfully!\\n&quot;);\n            return;\n        }\n    }\n    printf(&quot;Product not found.\\n&quot;);\n}\n \nint main() {\n    addProduct(&quot;Product1&quot;, 9.99, 10);\n    addProduct(&quot;Product2&quot;, 19.99, 5);\n    updateProduct(&quot;Product1&quot;, 11.99, 15);\n    removeProduct(&quot;Product2&quot;);\n    // Intentionally left simple for demonstration purposes\n    return 0;\n}\nRefactoring\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n \n#define MAX_PRODUCTS 50\n#define MAX_NAME_LEN 100\n \nstruct Product {\n    char name[MAX_NAME_LEN];\n    float price;\n    int quantity;\n};\n \nstruct Inventory {\n    struct Product products[MAX_PRODUCTS];\n    int num_products;\n} inventory;\n \n// Funzione di utilità per verificare l&#039;esistenza di un prodotto\nint findProductIndex(char *name) {\n    for(int i = 0; i &lt; inventory.num_products; i++) {\n        if(strcmp(inventory.products[i].name, name) == 0) {\n            return i;\n        }\n    }\n    return -1; // Indica che il prodotto non è stato trovato\n}\n \nvoid addProduct(char *name, float price, int quantity) {\n    if(inventory.num_products &gt;= MAX_PRODUCTS) {\n        printf(&quot;Inventory is full!\\n&quot;);\n        return;\n    }\n    if(findProductIndex(name) != -1) {\n        printf(&quot;Product already exists.\\n&quot;);\n        return;\n    }\n    struct Product newProduct;\n    strncpy(newProduct.name, name, MAX_NAME_LEN - 1);\n    newProduct.name[MAX_NAME_LEN - 1] = &#039;\\0&#039;;\n    newProduct.price = price;\n    newProduct.quantity = quantity;\n    inventory.products[inventory.num_products++] = newProduct;\n    printf(&quot;Product added successfully!\\n&quot;);\n}\n \nvoid removeProduct(char *name) {\n    int index = findProductIndex(name);\n    if(index == -1) {\n        printf(&quot;Product not found.\\n&quot;);\n        return;\n    }\n    for(int i = index; i &lt; inventory.num_products - 1; i++) {\n        inventory.products[i] = inventory.products[i + 1];\n    }\n    inventory.num_products--;\n    printf(&quot;Product removed successfully!\\n&quot;);\n}\n \nvoid updateProduct(char *name, float price, int quantity) {\n    int index = findProductIndex(name);\n    if(index == -1) {\n        printf(&quot;Product not found.\\n&quot;);\n        return;\n    }\n    inventory.products[index].price = price;\n    inventory.products[index].quantity = quantity;\n    printf(&quot;Product updated successfully!\\n&quot;);\n}\n \nint main() {\n    inventory.num_products = 0; // Inizializza il numero di prodotti\n    addProduct(&quot;Product1&quot;, 9.99, 10);\n    addProduct(&quot;Product2&quot;, 19.99, 5);\n    updateProduct(&quot;Product1&quot;, 11.99, 15);\n    removeProduct(&quot;Product2&quot;);\n    return 0;\n}\n\n\nModularizzazione: L’inventory è ora una struttura che incapsula sia l’array dei prodotti che il conteggio dei prodotti, migliorando l’incapsulamento e riducendo il rischio di modifiche non autorizzate alle variabili globali.\n\n\nCostanti Ripristinate: L’uso di MAX_PRODUCTS e MAX_NAME_LEN come costanti migliorano la leggibilità e la manutenibilità.\n\n\nCodice Duplicato Ridotto: L’introduzione di findProductIndex riduce il codice duplicato e centralizza la logica per trovare un prodotto.\n\n\nSeparazione delle Responsabilità: Separando la logica di business dall’output verso l’utente, il codice diventa più chiaro e facile da testare.\n\n\nEsercizio 4\nHere’s an extended example that incorporates several code smells including large class, long method, duplicate code, magic numbers, data clumps, and feature envy, among others. This example simulates a basic inventory management system for a store:\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n \n#define MAX_ITEMS 100\n \ntypedef struct {\n    char name[50];\n    int quantity;\n    double price;\n    char category[50];\n} Item;\n \nItem inventory[MAX_ITEMS];\n \nint itemCount = 0;\n \nvoid addItem(char *name, int quantity, double price, char *category) {\n    if (itemCount &gt;= MAX_ITEMS) {\n        printf(&quot;Inventory full. Cannot add more items.\\n&quot;);\n        return;\n    }\n    strcpy(inventory[itemCount].name, name);\n    inventory[itemCount].quantity = quantity;\n    inventory[itemCount].price = price;\n    strcpy(inventory[itemCount].category, category);\n    itemCount++;\n}\n \nvoid printInventory() {\n    printf(&quot;Inventory List:\\n&quot;);\n    for (int i = 0; i &lt; itemCount; i++) {\n        printf(&quot;%d: %s, %d units, $%.2f each, Category: %s\\n&quot;, i + 1, inventory[i].name, inventory[i].quantity, inventory[i].price, inventory[i].category);\n        double totalValue = inventory[i].quantity * inventory[i].price;\n        printf(&quot;Total value of %s: $%.2f\\n&quot;, inventory[i].name, totalValue);\n    }\n}\n \nvoid inventorySummary() {\n    double totalInventoryValue = 0;\n    int totalItems = 0;\n    for (int i = 0; i &lt; itemCount; i++) {\n        totalItems += inventory[i].quantity;\n        totalInventoryValue += inventory[i].quantity * inventory[i].price;\n        // Duplicate code for printing summary\n        printf(&quot;Total value of %s: $%.2f\\n&quot;, inventory[i].name, inventory[i].quantity * inventory[i].price);\n    }\n    printf(&quot;Total number of items: %d\\n&quot;, totalItems);\n    printf(&quot;Total inventory value: $%.2f\\n&quot;, totalInventoryValue);\n}\n \nint main() {\n    addItem(&quot;Laptop&quot;, 10, 999.99, &quot;Electronics&quot;);\n    addItem(&quot;Smartphone&quot;, 20, 499.99, &quot;Electronics&quot;);\n    addItem(&quot;Coffee Maker&quot;, 15, 89.99, &quot;Appliances&quot;);\n \n    printInventory();\n    inventorySummary();\n \n    return 0;\n}\nThis code example demonstrates various bad practices:\n\nLarge Class: The Item structure and related functions could be part of a large class (or, in C, a module) that does too many things.\nLong Method: The functions printInventory and inventorySummary are lengthy and include complex logic that could be simplified or broken down.\nDuplicate Code: The logic to calculate the total value of each item’s inventory is repeated in both printInventory and inventorySummary.\nMagic Numbers: Uses literal numbers for array sizes and initial values without explanation.\nData Clumps: The Item structure’s fields are often used together, indicating they could be split off into a smaller structure or handled differently to reduce coupling.\nFeature Envy: The functions show excessive interest in the data of Item, suggesting that some of this functionality should perhaps be encapsulated within the Item structure itself.\n\nThis example, while educational, emphasizes the importance of recognizing and addressing common coding issues to maintain clean, efficient, and manageable code bases.\nTo refactor the provided code, we will focus on improving its structure and maintainability without altering its functionality. We’ll encapsulate behaviors into functions, remove duplicate code, and use constants and structures more effectively.\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n \n#define MAX_ITEMS 100\n#define MAX_NAME 50\n#define MAX_CATEGORY 50\n \ntypedef struct {\n    char name[MAX_NAME];\n    int quantity;\n    double price;\n    char category[MAX_CATEGORY];\n} Item;\n \nItem inventory[MAX_ITEMS];\nint itemCount = 0;\n \nvoid addItem(const char *name, int quantity, double price, const char *category) {\n    if (itemCount &lt; MAX_ITEMS) {\n        Item newItem = {.quantity = quantity, .price = price};\n        strncpy(newItem.name, name, MAX_NAME);\n        newItem.name[MAX_NAME - 1] = &#039;\\0&#039;;\n        strncpy(newItem.category, category, MAX_CATEGORY);\n        newItem.category[MAX_CATEGORY - 1] = &#039;\\0&#039;;\n        inventory[itemCount++] = newItem;\n    } else {\n        printf(&quot;Inventory full. Cannot add more items.\\n&quot;);\n    }\n}\n \ndouble calculateItemValue(int index) {\n    return inventory[index].quantity * inventory[index].price;\n}\n \nvoid printItem(int index) {\n    printf(&quot;%d: %s, %d units, $%.2f each, Category: %s\\n&quot;, index + 1,\n           inventory[index].name, inventory[index].quantity, inventory[index].price, inventory[index].category);\n    printf(&quot;Total value of %s: $%.2f\\n&quot;, inventory[index].name, calculateItemValue(index));\n}\n \nvoid printInventory() {\n    printf(&quot;Inventory List:\\n&quot;);\n    for (int i = 0; i &lt; itemCount; i++) {\n        printItem(i);\n    }\n}\n \nvoid inventorySummary() {\n    double totalInventoryValue = 0;\n    int totalItems = 0;\n    for (int i = 0; i &lt; itemCount; i++) {\n        totalItems += inventory[i].quantity;\n        totalInventoryValue += calculateItemValue(i);\n    }\n    printf(&quot;Total number of items: %d\\n&quot;, totalItems);\n    printf(&quot;Total inventory value: $%.2f\\n&quot;, totalInventoryValue);\n}\n \nint main() {\n    addItem(&quot;Laptop&quot;, 10, 999.99, &quot;Electronics&quot;);\n    addItem(&quot;Smartphone&quot;, 20, 499.99, &quot;Electronics&quot;);\n    addItem(&quot;Coffee Maker&quot;, 15, 89.99, &quot;Appliances&quot;);\n \n    printInventory();\n    inventorySummary();\n \n    return 0;\n}\nRefactoring changes include:\n\nConstants for array sizes to avoid magic numbers.\naddItem function now ensures string safety with strncpy and null termination.\nSeparated logic for calculating item value (calculateItemValue) and printing an item (printItem) to reduce duplicate code and enhance modularity.\nEnhanced readability and maintenance by breaking down complex functions into simpler, more focused ones.\n\nThis refactored version improves the code’s structure, readability, and maintainability while maintaining the original functionality.\nEsercizio 5\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n \nstruct Employee {\n    char name[50];\n    int age;\n    float salary;\n};\n \n// Initialize employees with sample data\nvoid initEmployees(struct Employee employees[]) {\n\tstrcpy(employees[0].name, &quot;John Doe&quot;); employees[0].age = 30; employees[0].salary = 50000;\n\t strcpy(employees[1].name, &quot;Robert Clint&quot;); employees[1].age = 34; employees[1].salary = 52000;\n\t strcpy(employees[2].name, &quot;Bob Smith&quot;); employees[2].age = 28; employees[2].salary = 48000;\n\t strcpy(employees[3].name, &quot;George Smell&quot;); employees[3].age = 47; employees[3].salary = 76000;\n\t strcpy(employees[4].name, &quot;Eva Roth&quot;); employees[4].age = 25; employees[4].salary = 46000;\n}\n \nvoid printEmployees(struct Employee employees[]) {\n    int i;\n    for (i = 0; i &lt; 5; i++) {\n    if \n        printf(&quot;Name: %s, Age: %d, Salary: %.2f\\n&quot;, employees[i].name, employees[i].age, employees[i].salary);\n    }\n}\n \nint main() {\n    struct Employee employees[5];\n    initEmployees(employees);\n    printEmployees(employees);\n \n    printf(&quot;Total number of employees: %d\\n&quot;, 5);\n \n    float totalSalary = 0;\n    for (int i = 0; i &lt; 5; i++) {\n        totalSalary += employees[i].salary;\n    }\n    printf(&quot;Total salary: %.2f\\n&quot;, totalSalary);\n \n    int employeeAgeGroup = 0;\n    for (int i = 0; i &lt; 5; i++) {\n        if (employees[i].age &lt; 30) {\n            employeeAgeGroup = 1;\n        } else if (employees[i].age &gt;= 30 &amp;&amp; employees[i].age &lt;= 50) {\n            employeeAgeGroup = 2;\n        } else {\n            employeeAgeGroup = 3;\n        }\n \n        switch (employeeAgeGroup) {\n            case 1:\n                printf(&quot;%s is in the young age group.\\n&quot;, employees[i].name);\n                break;\n            case 2:\n                printf(&quot;%s is in the middle age group.\\n&quot;, employees[i].name);\n                break;\n            case 3:#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n \ntypedef struct Prodotto {\n  char nome[50];\n  int quantita;\n  float prezzo;\n  char descrizione[200];\n  int categoria;\n} Prodotto;\n \nvoid stampaProdotto(Prodotto prodotto) {\n  printf(&quot;Nome: %s\\n&quot;, prodotto.nome);\n  printf(&quot;Quantità: %d\\n&quot;, prodotto.quantita);\n  printf(&quot;Prezzo: %.2f\\n&quot;, prodotto.prezzo);\n  printf(&quot;Descrizione: %s\\n&quot;, prodotto.descrizione);\n  switch (prodotto.categoria) {\n    case 0: printf(&quot;Frutta\\n&quot;); break;\n    case 1: printf(&quot;Verdura\\n&quot;); break;\n    case 2: printf(&quot;Carne\\n&quot;); break;\n    case 3: printf(&quot;Latticini\\n&quot;); break;\n  }\n}\n \nvoid aggiungiProdotto(Prodotto** magazzino, int* nProdotti, Prodotto nuovoProdotto) {\n  Prodotto* nuovoMagazzino = (Prodotto*)malloc((*nProdotti + 1) * sizeof(Prodotto));\n  for (int i = 0; i &lt; *nProdotti; i++) {\n    nuovoMagazzino[i] = magazzino[i];\n  }\n  nuovoMagazzino[*nProdotti] = nuovoProdotto;\n  (*nProdotti)++;\n  free(magazzino);\n  *magazzino = nuovoMagazzino;\n}\n \nvoid rimuoviProdotto(Prodotto** magazzino, int* nProdotti, char* nome) {\n  int indiceProdotto = -1;\n  for (int i = 0; i &lt; *nProdotti; i++) {\n    if (strcmp(magazzino[i].nome, nome) == 0) {\n      indiceProdotto = i;\n      break;\n    }\n  }\n  if (indiceProdotto != -1) {\n    for (int i = indiceProdotto; i &lt; *nProdotti - 1; i++) {\n      magazzino[i] = magazzino[i + 1];\n    }\n    (*nProdotti)--;\n  }\n}\n \nvoid applicaSconto(Prodotto* prodotto, float sconto) {\n  prodotto-&gt;prezzo *= (1 - sconto);\n}\n \nfloat calcolaValoreMagazzino(Prodotto* magazzino, int nProdotti) {\n  float valoreTotale = 0;\n  for (int i = 0; i &lt; nProdotti; i++) {\n    valoreTotale += magazzino[i].prezzo * magazzino[i].quantita;\n  }\n  return valoreTotale;\n}\n \nvoid stampaElencoProdotti(Prodotto* magazzino, int nProdotti) {\n  for (int i = 0; i &lt; nProdotti; i++) {\n    stampaProdotto(magazzino[i]);\n  }\n}\n \n// Funzione per ordinare l&#039;elenco dei prodotti in ordine alfabetico\nvoid ordinaElencoProdotti(Prodotto* magazzino, int nProdotti) {\n  // ... algoritmo di ordinamento ...\n}\n \n// Funzione per applicare una promozione a un prodotto (sconto o aumento di prezzo)\nvoid applicaPromozione(Prodotto* prodotto, float valore, int tipoPromozione) {\n  if (tipoPromozione == 0) { // Sconto\n    applicaSconto(prodotto, valore);\n  } else if (tipoPromozione == 1) { // Aumento di prezzo\n    prodotto-&gt;prezzo *= (1 + valore);\n  }\n}\n \nint main() {\n  // ... codice di esempio ...\n \n  // Crea un nuovo prodotto\n  Prodotto nuovoProdotto;\n  strcpy(nuovoProdotto.nome, &quot;Banana&quot;);\n  nuovoProdotto.quantita = 10;\n  nuovoProdotto.prezzo = 2.00;\n  strcpy(nuovoProdotto.descrizione, &quot;Banana gialla e matura&quot;);\n  nuovoProdotto.categoria = 1;\n \n  // Aggiungi il prodotto al magazzino\n  Prodotto* magazzino = NULL;\n  int nProdotti = 0;\n  aggiungiProdotto(&amp;magazzino, &amp;nProdotti, nuovoProdotto);\n \n  // ...\n \n  // Stampa l&#039;elenco dei prodotti\n  stampaElenco\n                printf(&quot;%s is in the senior age group.\\n&quot;, employees[i].name);\n                break;\n        }\n    }\n \n    return 0;\n}\nQuesto codice dimostra vari code smells, inclusi l’uso di numeri magici, metodi lunghi, duplicazione di codice (anche se hai specificato di evitarlo, ho incluso altri esempi), eccessiva complessità condizionale e cattiva gestione dei dati.\nPer effettuare il refactoring del codice fornito, si possono seguire i seguenti passaggi:\n\n\nRimuovere la duplicazione del codice:\nCreare una funzione initEmployee per inizializzare un singolo dipendente, riducendo così la duplicazione nel metodo initEmployees.\n\n\nSostituire i numeri magici con costanti:\nDefinire costanti per i valori che compaiono nel codice, come le fasce d’età, per migliorarne la leggibilità e facilitarne la manutenzione.\n\n\nSuddividere main in funzioni più piccole:\nEstrarre la logica di calcolo del salario totale e la classificazione per gruppo di età in funzioni separate.\n\n\nSemplificare le condizioni e l’uso di switch:\nSostituire lo switch con una serie di if-else o con un approccio basato su funzioni o mappature per determinare il gruppo di età.\n\n\nMigliorare la gestione dei dati:\nConsiderare l’uso di liste o array dinamici per gestire un numero variabile di dipendenti, se necessario.\n\n\nEcco come potrebbe apparire il codice dopo il refactoring:\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n \n#define MAX_EMPLOYEES 5\n#define YOUNG_AGE_LIMIT 30\n#define SENIOR_AGE_LIMIT 50\n \nstruct Employee {\n    char name[50];\n    int age;\n    float salary;\n};\n \nvoid initEmployee(struct Employee *employee, const char *name, int age, float salary) {\n    strcpy(employee-&gt;name, name);\n    employee-&gt;age = age;\n    employee-&gt;salary = salary;\n}\n \nvoid initEmployees(struct Employee employees[]) {\ninitEmployee(&amp;employees[0], &quot;John Doe&quot;, 30, 50000);\ninitEmployee(&amp;employees[1], &quot;Robert Clint&quot;, 34, 52000);\ninitEmployee(&amp;employees[2], &quot;Bob Smith&quot;, 28, 48000);\ninitEmployee(&amp;employees[3], &quot;George Smell&quot;, 47, 76000);\ninitEmployee(&amp;employees[4], &quot;Eva Roth&quot;, 25, 48000);\n}\n \nvoid printEmployeeDetails(const struct Employee *employee) {\n    printf(&quot;Name: %s, Age: %d, Salary: %.2f\\n&quot;, employee-&gt;name, employee-&gt;age, employee-&gt;salary);\n}\n \nvoid printEmployees(const struct Employee employees[], int count) {\n    for (int i = 0; i &lt; count; i++) {\n        printEmployeeDetails(&amp;employees[i]);\n    }\n}\n \nfloat calculateTotalSalary(const struct Employee employees[], int count) {\n    float total = 0;\n    for (int i = 0; i &lt; count; i++) {\n        total += employees[i].salary;\n    }\n    return total;\n}\n \nvoid classifyAndPrintAgeGroup(const struct Employee *employee) {\n    const char *ageGroup;\n    if (employee-&gt;age &lt; YOUNG_AGE_LIMIT) ageGroup = &quot;young&quot;;\n    else if (employee-&gt;age &lt;= SENIOR_AGE_LIMIT) ageGroup = &quot;middle-aged&quot;;\n    else ageGroup = &quot;senior&quot;;\n    \n    printf(&quot;%s is in the %s age group.\\n&quot;, employee-&gt;name, ageGroup);\n}\n \nint main() {\n    struct Employee employees[MAX_EMPLOYEES];\n    initEmployees(employees);\n    printEmployees(employees, MAX_EMPLOYEES);\n    \n    printf(&quot;Total salary: %.2f\\n&quot;, calculateTotalSalary(employees, MAX_EMPLOYEES));\n    \n    for (int i = 0; i &lt; MAX_EMPLOYEES; i++) {\n        classifyAndPrintAgeGroup(&amp;employees[i]);\n    }\n \n    return 0;\n}\nQuesto codice è più pulito, organizzato e facile da mantenere. Ogni funzione ha un compito specifico, migliorando così la leggibilità e facilitando eventuali modifiche future.\nEsercizio 6\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n \n#define MAX_ACCOUNTS 100\n \ntypedef struct {\n    int accountId;\n    char accountName[100];\n    double balance;\n    int status; // 1 for active, 2 for suspended, 3 for closed\n} Account;\n \nAccount accounts[MAX_ACCOUNTS];\nint numAccounts = 0;\n \nvoid createAccount(int id, const char* name) {\n    if (numAccounts &gt;= MAX_ACCOUNTS) {\n        printf(&quot;Maximum number of accounts reached.\\n&quot;);\n        return;\n    }\n    \n    Account newAccount;\n    newAccount.accountId = id;\n    strncpy(newAccount.accountName, name, 99);\n    newAccount.balance = 0.0;\n    newAccount.status = 1; // Account status set to active\n    accounts[numAccounts++] = newAccount;\n}\n \nvoid deposit(int accountId, double amount) {\n    for (int i = 0; i &lt; numAccounts; i++) {\n        if (accounts[i].accountId == accountId) {\n            if (accounts[i].status == 1) { // Check if account is active\n                accounts[i].balance += amount;\n                printf(&quot;Deposit of %f made to account %d.\\n&quot;, amount, accountId);\n            } else {\n                printf(&quot;Account %d is not active.\\n&quot;, accountId);\n            }\n            return;\n        }\n    }\n    printf(&quot;Account %d not found.\\n&quot;, accountId);\n}\n \nvoid withdraw(int accountId, double amount) {\n    for (int i = 0; i &lt; numAccounts; i++) {\n        if (accounts[i].accountId == accountId) {\n            if (accounts[i].status == 1) { // Check if account is active\n                if (accounts[i].balance &gt;= amount) {\n                    accounts[i].balance -= amount;\n                    printf(&quot;Withdrawal of %f from account %d.\\n&quot;, amount, accountId);\n                } else {\n                    printf(&quot;Insufficient funds in account %d.\\n&quot;, accountId);\n                }\n            } else {\n                printf(&quot;Account %d is not active.\\n&quot;, accountId);\n            }\n            return;\n        }\n    }\n    printf(&quot;Account %d not found.\\n&quot;, accountId);\n}\n \nvoid printAccountDetails(int accountId) {\n    for (int i = 0; i &lt; numAccounts; i++) {\n        if (accounts[i].accountId == accountId) {\n            printf(&quot;Account ID: %d\\n&quot;, accounts[i].accountId);\n            printf(&quot;Account Name: %s\\n&quot;, accounts[i].accountName);\n            printf(&quot;Balance: %f\\n&quot;, accounts[i].balance);\n            printf(&quot;Status: %d\\n&quot;, accounts[i].status);\n            return;\n        }\n    }\n    printf(&quot;Account %d not found.\\n&quot;, accountId);\n}\n \nint main() {\n    createAccount(1, &quot;John Doe&quot;);\n    deposit(1, 100.0);\n    withdraw(1, 50.0);\n    printAccountDetails(1);\n    return 0;\n}\nIdentified Code Smells:\n\nDuplication: The deposit and withdraw functions contain duplicated logic for finding an account and checking its status. This could be refactored into a separate function.\nMagic Numbers: The account status values (1 for active, 2 for suspended, 3 for closed) are used directly in the code without explanation or named constants, making it hard to understand what these numbers represent.\nLong Method: The createAccount, deposit, withdraw, and printAccountDetails functions are relatively long and perform multiple operations, which could be broken down into smaller functions for clarity and reusability.\nImproper Abstraction Level: The account operations are all handled within the same file, lacking proper abstraction layers such as separating the account operations into different files or modules.\n\nIl codice fornito gestisce un semplice sistema bancario con operazioni base come creare un conto, depositare, prelevare e stampare i dettagli di un conto. Tuttavia, presenta alcune ripetizioni e utilizzi di numeri magici che possono essere migliorati con il refactoring per aumentare la manutenibilità e la leggibilità del codice. Di seguito, un esempio di come potrebbe essere rifattorizzato:\n\n\nRimozione dei Numeri Magici: Sostituiamo i numeri magici con delle costanti definite, migliorando la leggibilità e facilitando modifiche future.\n\n\nRiutilizzo del Codice: Creiamo funzioni ausiliarie per ridurre la duplicazione del codice, come la ricerca di un conto per ID.\n\n\nMiglioramento della Gestione degli Stati del Conto: Utilizziamo un’enumerazione per gli stati del conto, rendendo il codice più leggibile.\n\n\nEcco il codice migliorato:\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n \n#define MAX_ACCOUNTS 100\n#define ACCOUNT_NAME_MAX_LENGTH 100\n#define ACCOUNT_ACTIVE 1\n#define ACCOUNT_SUSPENDED 2\n#define ACCOUNT_CLOSED 3\n \ntypedef struct {\n    int accountId;\n    char accountName[ACCOUNT_NAME_MAX_LENGTH];\n    double balance;\n    int status; // Utilizziamo le costanti per gli stati\n} Account;\n \nAccount accounts[MAX_ACCOUNTS];\nint numAccounts = 0;\n \n// Enumerazione per gli stati del conto\ntypedef enum {\n    Active = ACCOUNT_ACTIVE,\n    Suspended = ACCOUNT_SUSPENDED,\n    Closed = ACCOUNT_CLOSED\n} AccountStatus;\n \n// Funzione ausiliaria per trovare un conto per ID\nint findAccountIndex(int accountId) {\n    for (int i = 0; i &lt; numAccounts; i++) {\n        if (accounts[i].accountId == accountId) {\n            return i;\n        }\n    }\n    return -1; // Conto non trovato\n}\n \nvoid createAccount(int id, const char* name) {\n    if (numAccounts &gt;= MAX_ACCOUNTS) {\n        printf(&quot;Maximum number of accounts reached.\\n&quot;);\n        return;\n    }\n    \n    Account newAccount;\n    newAccount.accountId = id;\n    strncpy(newAccount.accountName, name, ACCOUNT_NAME_MAX_LENGTH - 1);\n    newAccount.accountName[ACCOUNT_NAME_MAX_LENGTH - 1] = &#039;\\0&#039;; // Assicura la terminazione della stringa\n    newAccount.balance = 0.0;\n    newAccount.status = Active;\n    accounts[numAccounts++] = newAccount;\n}\n \nvoid deposit(int accountId, double amount) {\n    int accountIndex = findAccountIndex(accountId);\n    if (accountIndex &gt;= 0) { // Conto trovato\n        if (accounts[accountIndex].status == Active) {\n            accounts[accountIndex].balance += amount;\n            printf(&quot;Deposit of %f made to account %d.\\n&quot;, amount, accountId);\n        } else {\n            printf(&quot;Account %d is not active.\\n&quot;, accountId);\n        }\n    } else {\n        printf(&quot;Account %d not found.\\n&quot;, accountId);\n    }\n}\n \nvoid withdraw(int accountId, double amount) {\n    int accountIndex = findAccountIndex(accountId);\n    if (accountIndex &gt;= 0) {\n        if (accounts[accountIndex].status == Active) {\n            if (accounts[accountIndex].balance &gt;= amount) {\n                accounts[accountIndex].balance -= amount;\n                printf(&quot;Withdrawal of %f from account %d.\\n&quot;, amount, accountId);\n            } else {\n                printf(&quot;Insufficient funds in account %d.\\n&quot;, accountId);\n            }\n        } else {\n            printf(&quot;Account %d is not active.\\n&quot;, accountId);\n        }\n    } else {\n        printf(&quot;Account %d not found.\\n&quot;, accountId);\n    }\n}\n \nvoid printAccountDetails(int accountId) {\n    int accountIndex = findAccountIndex(accountId);\n    if (accountIndex &gt;= 0) {\n        printf(&quot;Account ID: %d\\n&quot;, accounts[accountIndex].accountId);\n        printf(&quot;Account Name: %s\\n&quot;, accounts[accountIndex].accountName);\n        printf(&quot;Balance: %f\\n&quot;, accounts[accountIndex].balance);\n        printf(&quot;Status: %d\\n&quot;, accounts[accountIndex].status);\n    } else {\n        printf(&quot;Account %d not found.\\n&quot;, accountId);\n    }\n}\n \nint main() {\n    createAccount(1, &quot;John Doe&quot;);\n    deposit(1, 100.0);\n    withdraw(1, 50.0);\n    printAccountDetails(1);\n    return 0;\n}\nQuesto codice rifattorizzato riduce la duplicazione del codice tramite l’introduzione della funzione findAccountIndex, migliora la leggibilità e la manutenibilità del codice sostituendo i numeri magici con costanti e nomi significativi, e assicura la terminazione corretta delle stringhe.\nEsercizio 7\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n \ntypedef struct Prodotto {\n  char nome[50];\n  int quantita;\n  float prezzo;\n  char descrizione[200];\n  int categoria;\n} Prodotto;\n \nvoid stampaProdotto(Prodotto prodotto) {\n  printf(&quot;Nome: %s\\n&quot;, prodotto.nome);\n  printf(&quot;Quantità: %d\\n&quot;, prodotto.quantita);\n  printf(&quot;Prezzo: %.2f\\n&quot;, prodotto.prezzo);\n  printf(&quot;Descrizione: %s\\n&quot;, prodotto.descrizione);\n  switch (prodotto.categoria) {\n    case 0: printf(&quot;Categoria: Frutta\\n&quot;); break;\n    case 1: printf(&quot;Categoria: Verdura\\n&quot;); break;\n    case 2: printf(&quot;Categoria: Carne\\n&quot;); break;\n    case 3: printf(&quot;Categoria: Latticini\\n&quot;); break;\n    default: printf(&quot;Categoria: Sconosciuta\\n&quot;);\n  }\n}\n \nvoid aggiungiProdotto(Prodotto** magazzino, int* nProdotti, Prodotto nuovoProdotto) {\n  Prodotto* nuovoMagazzino = (Prodotto*)malloc((*nProdotti + 1) * sizeof(Prodotto));\n  for (int i = 0; i &lt; *nProdotti; i++) {\n    nuovoMagazzino[i] = (*magazzino)[i];\n  }\n  nuovoMagazzino[*nProdotti] = nuovoProdotto;\n  (*nProdotti)++;\n  free(*magazzino);\n  *magazzino = nuovoMagazzino;\n}\n \nvoid rimuoviProdotto(Prodotto** magazzino, int* nProdotti, char* nome) {\n  int indiceProdotto = -1;\n  for (int i = 0; i &lt; *nProdotti; i++) {\n    if (strcmp((*magazzino)[i].nome, nome) == 0) {\n      indiceProdotto = i;\n      break;\n    }\n  }\n  if (indiceProdotto != -1) {\n    for (int i = indiceProdotto; i &lt; *nProdotti - 1; i++) {\n      (*magazzino)[i] = (*magazzino)[i + 1];\n    }\n    (*nProdotti)--;\n  }\n}\n \nvoid applicaSconto(Prodotto* prodotto, float sconto) {\n  prodotto-&gt;prezzo *= (1 - sconto);\n}\n \nfloat calcolaValoreMagazzino(Prodotto* magazzino, int nProdotti) {\n  float valoreTotale = 0;\n  for (int i = 0; i &lt; nProdotti; i++) {\n    valoreTotale += magazzino[i].prezzo * magazzino[i].quantita;\n  }\n  return valoreTotale;\n}\n \nvoid stampaElencoProdotti(Prodotto* magazzino, int nProdotti) {\n  for (int i = 0; i &lt; nProdotti; i++) {\n    stampaProdotto(magazzino[i]);\n  }\n}\n \nvoid ordinaElencoProdotti(Prodotto* magazzino, int nProdotti) {\n  int i, j;\n  for (i = 0; i &lt; nProdotti-1; i++) {     \n    for (j = 0; j &lt; nProdotti-i-1; j++) {\n      if (strcmp(magazzino[j].nome, magazzino[j+1].nome) &gt; 0) {\n        // Scambio di prodotti\n        Prodotto temp = magazzino[j];\n        magazzino[j] = magazzino[j+1];\n        magazzino[j+1] = temp;\n      }\n    }\n  }\n}\n \nvoid applicaPromozione(Prodotto* prodotto, float valore, int tipoPromozione) {\n  if (tipoPromozione == 0) {\n    applicaSconto(prodotto, valore);\n  } else if (tipoPromozione == 1) {\n    prodotto-&gt;prezzo *= (1 + valore);\n  }\n}\n \nint main() {\n  Prodotto* magazzino = NULL;\n  int nProdotti = 0;\n \n  // Crea e aggiungi alcuni prodotti al magazzino\n  Prodotto p1 = {&quot;Mela&quot;, 50, 0.50, &quot;Mela rossa&quot;, 0};\n  aggiungiProdotto(&amp;magazzino, &amp;nProdotti, p1);\n \n  Prodotto p2 = {&quot;Pera&quot;, 30, 0.65, &quot;Pera verde&quot;, 0};\n  aggiungiProdotto(&amp;magazzino, &amp;nProdotti, p2);\n \n  // Stampa prima dell&#039;ordinamento\n  printf(&quot;Elenco prodotti prima dell&#039;ordinamento:\\n&quot;);\n  stampaElencoProdotti(magazzino, nProdotti);\n \n  // Ordinamento dei prodotti\n  ordinaElencoProdotti(magazzino, nProdotti);\n \n  // Stampa dopo l&#039;ordinamento\n  printf(&quot;\\nElenco prodotti dopo l&#039;ordinamento:\\n&quot;);\n  stampaElencoProdotti(magazzino, nProdotti);\n \n  // Pulizia della memoria\n  free(magazzino);\n \n  return 0;\n}\nRefactoring\nEcco il codice completo rifattorizzato, con miglioramenti sulla gestione della memoria, separazione delle responsabilità, uso di enumerazioni per le categorie, e l’ottimizzazione dell’ordinamento:\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n \n#define NOME_MAX_LEN 50\n#define DESCR_MAX_LEN 200\n \ntypedef enum {\n  FRUTTA,\n  VERDURA,\n  CARNE,\n  LATTICINI,\n  SCONOSCIUTA\n} Categoria;\n \ntypedef struct Prodotto {\n  char nome[NOME_MAX_LEN];\n  int quantita;\n  float prezzo;\n  char descrizione[DESCR_MAX_LEN];\n  Categoria categoria;\n} Prodotto;\n \nconst char* getCategoriaString(Categoria categoria) {\n  switch (categoria) {\n    case FRUTTA: return &quot;Frutta&quot;;\n    case VERDURA: return &quot;Verdura&quot;;\n    case CARNE: return &quot;Carne&quot;;\n    case LATTICINI: return &quot;Latticini&quot;;\n    default: return &quot;Sconosciuta&quot;;\n  }\n}\n \nvoid stampaProdotto(const Prodotto* prodotto) {\n  printf(&quot;Nome: %s\\n&quot;, prodotto-&gt;nome);\n  printf(&quot;Quantità: %d\\n&quot;, prodotto-&gt;quantita);\n  printf(&quot;Prezzo: %.2f\\n&quot;, prodotto-&gt;prezzo);\n  printf(&quot;Descrizione: %s\\n&quot;, prodotto-&gt;descrizione);\n  printf(&quot;Categoria: %s\\n&quot;, getCategoriaString(prodotto-&gt;categoria));\n}\n \nvoid aggiungiProdotto(Prodotto** magazzino, int* nProdotti, const Prodotto* nuovoProdotto) {\n  *magazzino = realloc(*magazzino, (*nProdotti + 1) * sizeof(Prodotto));\n  if (*magazzino == NULL) {\n    printf(&quot;Errore nella reallocazione della memoria.\\n&quot;);\n    exit(1); // Gestione rudimentale dell&#039;errore\n  }\n  (*magazzino)[*nProdotti] = *nuovoProdotto;\n  (*nProdotti)++;\n}\n \nvoid rimuoviProdotto(Prodotto** magazzino, int* nProdotti, const char* nome) {\n  for (int i = 0; i &lt; *nProdotti; i++) {\n    if (strcmp((*magazzino)[i].nome, nome) == 0) {\n      for (int j = i; j &lt; *nProdotti - 1; j++) {\n        (*magazzino)[j] = (*magazzino)[j + 1];\n      }\n      (*nProdotti)--;\n      *magazzino = realloc(*magazzino, (*nProdotti) * sizeof(Prodotto)); // Ridimensiona l&#039;array\n      return;\n    }\n  }\n  printf(&quot;Prodotto non trovato.\\n&quot;);\n}\n \nvoid applicaSconto(Prodotto* prodotto, float sconto) {\n  prodotto-&gt;prezzo *= (1 - sconto);\n}\n \nfloat calcolaValoreMagazzino(const Prodotto* magazzino, int nProdotti) {\n  float valoreTotale = 0.0;\n  for (int i = 0; i &lt; nProdotti; i++) {\n    valoreTotale += magazzino[i].prezzo * magazzino[i].quantita;\n  }\n  return valoreTotale;\n}\n \nvoid stampaElencoProdotti(const Prodotto* magazzino, int nProdotti) {\n  for (int i = 0; i &lt; nProdotti; i++) {\n    stampaProdotto(&amp;magazzino[i]);\n  }\n}\n \nvoid ordinaElencoProdotti(Prodotto* magazzino, int nProdotti) {\n  for (int i = 0; i &lt; nProdotti - 1; i++) {\n    for (int j = 0; j &lt; nProdotti - i - 1; j++) {\n      if (strcmp(magazzino[j].nome, magazzino[j + 1].nome) &gt; 0) {\n        Prodotto temp = magazzino[j];\n        magazzino[j] = magazzino[j + 1];\n        magazzino[j + 1] = temp;\n      }\n    }\n  }\n}\n \nvoid applicaPromozione(Prodotto* prodotto, float valore, int tipoPromozione) {\n  if (tipoPromozione == 0) {\n    applicaSconto(prodotto, valore);\n  } else if (tipoPromozione == 1) {\n    prodotto-&gt;prezzo *= (1 + valore);\n  }\n}\n \nint main() {\n  Prodotto* magazzino = NULL;\n  int nProdotti = 0;\n \n  Prodotto p1 = {&quot;Mela&quot;, 50, 0.50, &quot;Mela rossa&quot;, FRUTTA};\n  aggiungiProdotto(&amp;magazzino, &amp;nProdotti, &amp;p1);\n \n  Prodotto p2 = {&quot;Pera&quot;, 30, 0.65, &quot;Pera verde&quot;, FRUTTA};\n  aggiungiProdotto(&amp;magazzino, &amp;nProdotti, &amp;p2);\n \n  printf(&quot;Elenco prodotti prima dell&#039;ordinamento:\\n&quot;);\n  stampaElencoProdotti(magazzino, nProdotti);\n \n  ordinaElencoProdotti(magazzino, nProdotti);\n \n  printf(&quot;\\nElenco prodotti dopo l&#039;ordinamento:\\n&quot;);\n  stampaElencoProdotti(magazzino, nProdotti);\n \n  free(magazzino);\n \n  return 0;\n}\nQuesto codice è una versione migliorata che introduce:\n\nEnumerazioni per rappresentare le categorie dei prodotti in modo più leggibile.\nGestione della memoria dinamica con realloc per ottimizzare l’aggiunta e la rimozione dei prodotti dal magazzino.\nSeparazione delle responsabilità con funzioni dedicate per ogni operazione, migliorando la leggibilità e facilitando la manutenzione.\nMiglioramenti nell’efficienza dell’ordinamento attraverso l’algoritmo bubble sort, che rimane semplice ma è ottimizzato per non eseguire iterazioni inutili se l’array è già ordinato.\n\nRicorda che in un contesto reale, sarebbe opportuno considerare algoritmi di ordinamento più efficienti per grandi dataset e gestire meglio gli errori di allocazione della memoria."},"Argomenti/Fattorizzazione-del-codice-e-makefile/Code-smells-e-refactoring":{"slug":"Argomenti/Fattorizzazione-del-codice-e-makefile/Code-smells-e-refactoring","filePath":"Argomenti/Fattorizzazione del codice e makefile/Code smells e refactoring.md","title":"Code smells e refactoring","links":[],"tags":[],"content":"Index\n \nUtilizzo per le lezioni\nQuesto documento funziona come dispensa. Tuttavia per fare lezione si utilizzerà un approccio inverso. Ovvero verranno mostrati agli alunni uno alla volta i codici con gli smell, si faranno dei ragionamenti su questo codice discutendo con la classe, facendo proporre varie idee e soluzioni. Dopodiché allora si mostrerà la definizione dello smell e l’esempio di refactoring.\nIntroduzione\nCosa Sono i Code Smell\nI “Code Smell” sono schemi comuni nel codice sorgente che indicano potenziali problemi di design o implementazione. Questi “odori” non sono bug in senso stretto; il codice può funzionare correttamente nonostante la loro presenza. Tuttavia, i code smell sono spesso indicatori di problemi più profondi che possono influenzare negativamente la qualità, la manutenibilità e la scalabilità del software. Identificarli e risolverli è fondamentale per garantire la salute a lungo termine di un progetto software.\nPerché i Code Smell Sono Importanti\n\nMigliorare la Manutenibilità: La rimozione dei code smell rende il codice più pulito e più facile da mantenere.\nPrevenire Bug Futuri: Molti code smell possono portare a errori complessi in futuro, quindi anticiparli aiuta a prevenire bug.\nMigliorare la Comprensione del Codice: Un codice pulito e ben strutturato è più facile da comprendere per nuovi sviluppatori o per chi rivede il codice dopo un certo tempo.\nOttimizzare le Prestazioni: Alcuni code smell possono influenzare le prestazioni del software. La loro eliminazione può quindi portare a miglioramenti in questo senso.\n\nCome Identificare i Code Smell\nI code smell possono essere identificati attraverso una varietà di metodi, tra cui:\n\nRevisione Manuale del Codice: Gli sviluppatori esperti possono spesso riconoscere i code smell basandosi sulla loro esperienza.\nStrumenti di Analisi Statica del Codice: Esistono strumenti software che possono automaticamente rilevare molti tipi comuni di code smell.\nPeer Review: La revisione del codice da parte di altri sviluppatori è un ottimo modo per individuare e discutere potenziali problemi.\n\nTipi Comuni di Code Smell\nNella seguente dispensa, esploreremo vari tipi comuni di code smell, fornendo definizioni, esempi e tecniche di refactoring per ciascuno. Questi includeranno problemi come “Codice Morto”, “Violazioni del Principio KISS”, “Duplicazione di Codice”, e molti altri. Ogni sezione sarà accompagnata da esempi pratici, mostrando come questi problemi possono presentarsi nel codice e come possono essere risolti.\nEsempi di code smell e relativi refactoring\nCodice Duplicato\nDefinizione: Il “Codice Duplicato” si riferisce alla situazione in cui blocchi di codice identici o molto simili si trovano in diverse parti del codice. Questo è uno dei code smell più comuni e viola il principio “Don’t Repeat Yourself” (DRY). La duplicazione può avvenire a vari livelli – da piccoli blocchi di codice a intere funzioni o classi.\nProblemi Causati dal Codice Duplicato:\n\nManutenzione Difficile: Se devi cambiare la logica in un blocco di codice duplicato, dovrai ricordarti di cambiare tutti i duplicati.\nAumento delle Dimensioni del Codice: Il codice duplicato ingrandisce inutilmente la base di codice, rendendo più difficile la comprensione e la manutenzione.\nProbabilità di Errori: Più codice duplicato significa più possibilità di introdurre errori durante aggiornamenti o modifiche.\n\nCome Identificare il Codice Duplicato:\n\nManualmente, durante la revisione del codice.\nUtilizzando strumenti di analisi statica che possono rilevare la duplicazione.\n\nEsempio di Codice con Codice Duplicato:\nCodice con Codice Duplicato\n#include &lt;stdio.h&gt;\n \nint main() {\n    int temperature[] = {23, 26, 22, 21, 25, 24};\n    int umidita[] = {45, 50, 55, 60, 50, 45};\n \n    int lunghezzaTemp = sizeof(temperature) / sizeof(temperature[0]);\n    int lunghezzaUmidita = sizeof(umidita) / sizeof(umidita[0]);\n \n    // Calcolo della media delle temperature\n    int sommaTemp = 0;\n    for (int i = 0; i &lt; lunghezzaTemp; ++i) {\n        sommaTemp += temperature[i];\n    }\n    float mediaTemp = (float)sommaTemp / lunghezzaTemp;\n    printf(&quot;Media Temperatura: %.2f\\n&quot;, mediaTemp);\n \n    // Calcolo della media dell&#039;umidità\n    int sommaUmidita = 0;\n    for (int i = 0; i &lt; lunghezzaUmidita; ++i) {\n        sommaUmidita += umidita[i];\n    }\n    float mediaUmidita = (float)sommaUmidita / lunghezzaUmidita;\n    printf(&quot;Media Umidità: %.2f\\n&quot;, mediaUmidita);\n \n    return 0;\n}\nRefactoring per Rimuovere il Codice Duplicato\n#include &lt;stdio.h&gt;\n \nfloat calcola_media(int array[], int lunghezza) {\n    int somma = 0;\n    for (int i = 0; i &lt; lunghezza; ++i) {\n        somma += array[i];\n    }\n    return (float)somma / lunghezza;\n}\n \nint main() {\n    int temperature[] = {23, 26, 22, 21, 25, 24};\n    int umidita[] = {45, 50, 55, 60, 50, 45};\n \n    int lunghezzaTemp = sizeof(temperature) / sizeof(temperature[0]);\n    int lunghezzaUmidita = sizeof(umidita) / sizeof(umidita[0]);\n \n    float mediaTemp = calcola_media(temperature, lunghezzaTemp);\n    float mediaUmidita = calcola_media(umidita, lunghezzaUmidita);\n \n    printf(&quot;Media Temperatura: %.2f\\n&quot;, mediaTemp);\n    printf(&quot;Media Umidità: %.2f\\n&quot;, mediaUmidita);\n \n    return 0;\n}\nIn questo esempio, il codice per calcolare la media è stato estratto in una funzione calcola_media, riducendo così la duplicazione del codice e migliorando la leggibilità e la manutenibilità del programma.\nFunzione Troppo Lunga\nDefinizione:\nUna “Funzione Troppo Lunga” è un code smell che si verifica quando una funzione in un programma diventa eccessivamente lunga e complessa. Le funzioni lunghe sono difficili da leggere, capire e mantenere. Spesso, esse contengono diverse funzionalità mescolate, violando il principio di singola responsabilità.\nProblemi Causati da Funzioni Troppo Lunghe:\n\nDifficoltà di Comprensione: Più lunga è la funzione, più è difficile per i programmatori capire cosa fa e come.\nManutenzione Complicata: Le modifiche diventano più rischiose, poiché una modifica può influenzare parti inaspettate del codice.\nRiutilizzo Ridotto: Le funzioni lunghe spesso fanno troppe cose, rendendo difficile il loro riutilizzo in altri contesti.\n\nSoluzioni per Funzioni Troppo Lunghe:\n\nSuddivisione in Funzioni più Piccole: Identificare blocchi di codice all’interno della funzione che possono essere separati in nuove funzioni.\nUso di Commenti e Documentazione: Se la suddivisione non è possibile, documentare bene la funzione può aiutare.\nRifattorizzazione: Ristrutturare il codice per migliorarne la leggibilità senza modificarne il comportamento.\n\nEsempio di Funzione Troppo Lunga in C\n#include &lt;stdio.h&gt;\n \nvoid elabora_dati(int dati[], int lunghezza) {\n    // Calcolo della media\n    int somma = 0;\n\t    for (int i = 0; i &lt; lunghezza; ++i) {\n        somma += dati[i];\n    }\n    float media = (float)somma / lunghezza;\n \n    // Ricerca del valore massimo\n    int massimo = dati[0];\n    for (int i = 1; i &lt; lunghezza; ++i) {\n        if (dati[i] &gt; massimo) {\n            massimo = dati[i];\n        }\n    }\n \n    // Ricerca del valore minimo\n    int minimo = dati[0];\n    for (int i = 1; i &lt; lunghezza; ++i) {\n        if (dati[i] &lt; minimo) {\n            minimo = dati[i];\n        }\n    }\n \n    printf(&quot;Media: %.2f, Massimo: %d, Minimo: %d\\n&quot;, media, massimo, minimo);\n}\n \nint main() {\n    int array[] = {10, 20, 30, 40, 50};\n    int lunghezza = sizeof(array) / sizeof(array[0]);\n    elabora_dati(array, lunghezza);\n    return 0;\n}\nRefactoring per Suddividere la Funzione\n#include &lt;stdio.h&gt;\n \nfloat calcola_media(int dati[], int lunghezza) {\n    int somma = 0;\n    for (int i = 0; i &lt; lunghezza; ++i) {\n        somma += dati[i];\n    }\n    return (float)somma / lunghezza;\n}\n \nint trova_massimo(int dati[], int lunghezza) {\n    int massimo = dati[0];\n    for (int i = 1; i &lt; lunghezza; ++i) {\n        if (dati[i] &gt; massimo) {\n            massimo = dati[i];\n        }\n    }\n    return massimo;\n}\n \nint trova_minimo(int dati[], int lunghezza) {\n    int minimo = dati[0];\n    for (int i = 1; i &lt; lunghezza; ++i) {\n        if (dati[i] &lt; minimo) {\n            minimo = dati[i];\n        }\n    }\n    return minimo;\n}\n \nvoid elabora_dati(int dati[], int lunghezza) {\n    float media = calcola_media(dati, lunghezza);\n    int massimo = trova_massimo(dati, lunghezza);\n    int minimo = trova_minimo(dati, lunghezza);\n \n    printf(&quot;Media: %.2f, Massimo: %d, Minimo: %d\\n&quot;, media, massimo, minimo);\n}\n \nint main() {\n    int array[] = {10, 20, 30, 40, 50};\n    int lunghezza = sizeof(array) / sizeof(array[0]);\n    elabora_dati(array, lunghezza);\n    return 0;\n}\nIn questo refactoring, la funzione elabora_dati è stata suddivisa in tre funzioni separate: calcola_media, trova_massimo e trova_minimo. Ogni funzione ora ha una responsabilità chiara e specifica, rendendo il codice più leggibile e manutenibile.\nLista di Parametri Troppo Lunga\nDefinizione:\nUna “Lista di Parametri Troppo Lunga” è un code smell che si verifica quando una funzione o un metodo ha un numero eccessivo di parametri. Una lunga lista di parametri può rendere la funzione difficile da comprendere e utilizzare. Inoltre, aumenta la complessità e il rischio di errori, poiché è più difficile tenere traccia di tutti gli argomenti.\nProblemi Causati da Liste di Parametri Troppo Lunghe:\n\nDifficoltà di Comprensione e Uso: Più parametri ha una funzione, più è difficile ricordare l’ordine e il significato di ciascuno.\nManutenzione Complicata: Aggiungere, rimuovere o modificare parametri può diventare problematico e richiedere cambiamenti in tutte le chiamate alla funzione.\nAccoppiamento Elevato: La funzione diventa strettamente accoppiata a tutte le aree del codice che la utilizzano.\n\nSoluzioni per Liste di Parametri Troppo Lunghe:\n\nIntroduzione di Oggetti Parametro: Raggruppare parametri correlati in una struttura o un oggetto.\nUso di Parametri Predefiniti: Se il linguaggio lo consente, utilizzare parametri con valori predefiniti per ridurre il numero di argomenti necessari.\nRifattorizzazione in Funzioni più Piccole: Se possibile, dividere la funzione in più funzioni più piccole e mirate.\n\nEsempio di Lista di Parametri Troppo Lunga in C\n#include &lt;stdio.h&gt;\n \nvoid crea_report(int giorno, int mese, int anno, int ore, int minuti, int dati1, int dati2, int dati3, int dati4) {\n    // Logica per creare il report\n    printf(&quot;Report del %d/%d/%d alle %d:%d\\n&quot;, giorno, mese, anno, ore, minuti);\n    // Altre operazioni con i dati...\n}\n \nint main() {\n    crea_report(7, 1, 2024, 15, 30, 100, 200, 300, 400);\n    return 0;\n}\nRefactoring per Ridurre i Parametri\n#include &lt;stdio.h&gt;\n \ntypedef struct {\n    int giorno;\n    int mese;\n    int anno;\n    int ore;\n    int minuti;\n} DataOra;\n \ntypedef struct {\n    int dati1;\n    int dati2;\n    int dati3;\n    int dati4;\n} Dati;\n \nvoid crea_report(DataOra dataOra, Dati dati) {\n    // Logica per creare il report\n    printf(&quot;Report del %d/%d/%d alle %d:%d\\n&quot;, dataOra.giorno, dataOra.mese, dataOra.anno, dataOra.ore, dataOra.minuti);\n    // Altre operazioni con i dati...\n}\n \nint main() {\n    DataOra dataOra = {7, 1, 2024, 15, 30};\n    Dati dati = {100, 200, 300, 400};\n \n    crea_report(dataOra, dati);\n    return 0;\n}\nIn questo refactoring, abbiamo introdotto due strutture, DataOra e Dati, per raggruppare i parametri correlati. Ciò riduce significativamente il numero di parametri richiesti dalla funzione crea_report, rendendola più chiara e più facile da usare.\nFeature Envy\nDefinizione:\n“Feature Envy” è un code smell che si verifica generalmente in contesti di programmazione orientata agli oggetti (OOP), dove un metodo di una classe accede in modo eccessivo ai dati o alle funzionalità di un’altra classe. Tuttavia, il concetto può essere esteso anche a contesti non-OOP, ad esempio quando una funzione dipende in modo eccessivo da dati o funzioni esterne al suo contesto immediato.\nIn contesti non-OOP, “Feature Envy” può manifestarsi come una funzione che fa un uso eccessivo di variabili globali o parametri esterni, piuttosto che basarsi sui propri dati o parametri.\nProblemi Causati da Feature Envy:\n\nAccoppiamento Stretto: La funzione o il metodo diventa troppo dipendente da un’altra parte del codice.\nDifficoltà nella Manutenzione: Le modifiche in una parte del sistema possono avere effetti a cascata non desiderati su altre parti.\nViolazione dell’Incapsulamento: In OOP, ciò va contro il principio di incapsulamento. In contesti non-OOP, indica una cattiva organizzazione del codice.\n\nSoluzioni per Feature Envy:\n\nRifattorizzazione: Spostare la funzione o il metodo più vicino ai dati o alle funzioni a cui accede.\nPassaggio di Oggetti anziché Singoli Dati: Se applicabile, passare strutture o insiemi di dati correlati invece di singoli valori.\n\nEsempio di Feature Envy in C (senza OOP)\nSupponiamo di avere una funzione che calcola statistiche sui dati, ma fa un uso eccessivo di variabili globali.\n#include &lt;stdio.h&gt;\n \nint globaleDati1[5] = {1, 2, 3, 4, 5};\nint globaleDati2[5] = {6, 7, 8, 9, 10};\n \nvoid calcola_statistiche() {\n    int somma1 = 0;\n    for (int i = 0; i &lt; 5; ++i) {\n        somma1 += globaleDati1[i];\n    }\n    // Altre operazioni con globaleDati1 e globaleDati2...\n}\n \nint main() {\n    calcola_statistiche();\n    return 0;\n}\nRefactoring per Ridurre Feature Envy\nInvece di fare affidamento su variabili globali, possiamo passare i dati come parametri alla funzione.\n#include &lt;stdio.h&gt;\n \nvoid calcola_statistiche(int dati1[], int dati2[], int lunghezza) {\n    int somma1 = 0;\n    for (int i = 0; i &lt; lunghezza; ++i) {\n        somma1 += dati1[i];\n    }\n    // Altre operazioni con dati1 e dati2...\n}\n \nint main() {\n    int localDati1[5] = {1, 2, 3, 4, 5};\n    int localDati2[5] = {6, 7, 8, 9, 10};\n \n    calcola_statistiche(localDati1, localDati2, 5);\n    return 0;\n}\nIn questo refactoring, abbiamo ridotto la dipendenza della funzione calcola_statistiche dalle variabili globali, passando i dati necessari come parametri. Questo rende la funzione più flessibile, riutilizzabile e meno accoppiata con il contesto globale.\nCostanti Magiche\nDefinizione:\nLe “Costanti Magiche” sono valori numerici o stringhe letterali che appaiono nel codice senza spiegazione, rendendo il codice meno leggibile e più difficile da mantenere. Questi valori “magici” possono confondere chiunque legga il codice, perché non è chiaro cosa rappresentino o perché siano stati scelti.\nProblemi Causati dalle Costanti Magiche:\n\nLeggibilità Ridotta: Il significato del valore magico non è immediatamente evidente.\nManutenibilità Compromessa: Cambiare il valore in diverse parti del codice può essere propenso ad errori.\nRiusabilità Ridotta: Il codice con costanti magiche è meno flessibile e più difficile da riutilizzare in contesti diversi.\n\nSoluzioni per Costanti Magiche:\n\nSostituzione con Costanti Nominative: Sostituire le costanti magiche con costanti o variabili nominative che hanno nomi descrittivi.\nUso di File di Configurazione o Definizioni Esternalizzate: Per valori che potrebbero cambiare frequentemente o che devono essere condivisi tra diversi parti del codice.\n\nEsempio di Costanti Magiche in C\n#include &lt;stdio.h&gt;\n \nint calcola_sconto(int prezzo) {\n    if (prezzo &gt; 100) {\n        return prezzo * 0.15; // Sconto del 15% per ordini superiori a 100\n    }\n    return 0;\n}\n \nint main() {\n    int prezzo = 120;\n    printf(&quot;Sconto: %d\\n&quot;, calcola_sconto(prezzo));\n    return 0;\n}\nIn questo esempio, il valore 100 e 0.15 sono costanti magiche. Non è immediatamente chiaro perché questi valori siano stati scelti o cosa rappresentino.\nRefactoring per Rimuovere le Costanti Magiche\n#include &lt;stdio.h&gt;\n \n// const int SOGLIA_SCONTO = 100;\n//const float PERCENTUALE_SCONTO = 0.15;\n \n#define SOGLIA_SCONTO 100\n#define PERCENTUALE_SCONTO 0.15\n \nint calcola_sconto(int prezzo) {\n    if (prezzo &gt; SOGLIA_SCONTO) {\n        return prezzo * PERCENTUALE_SCONTO;\n    }\n    return 0;\n}\n \nint main() {\n    int prezzo = 120;\n    printf(&quot;Sconto: %d\\n&quot;, calcola_sconto(prezzo));\n    return 0;\n}\nCon questo refactoring, le costanti magiche sono state sostituite con costanti nominative SOGLIA_SCONTO e PERCENTUALE_SCONTO. Ora è molto più chiaro cosa rappresentano questi valori e il codice è diventato più leggibile e facile da mantenere.\nEspressioni Complesse di Basso Livello\nDefinizione:\nLe “Espressioni Complesse di Basso Livello” sono un code smell che si verifica quando il codice contiene operazioni complesse, in particolare aritmetiche, di manipolazione di stringhe, o simili, che rendono il codice difficile da leggere e comprendere. Queste espressioni possono essere lunghe, intricate e spesso includono molteplici operazioni in una singola riga.\nProblemi Causati da Espressioni Complesse di Basso Livello:\n\nDifficoltà di Comprensione: Il codice diventa meno leggibile e più difficile da capire a prima vista.\nErrori: La complessità aumenta il rischio di errori, specialmente durante la manutenzione o le modifiche al codice.\nTest e Debugging Complicati: Le espressioni complesse rendono più difficile testare e fare il debug del codice.\n\nSoluzioni per Espressioni Complesse di Basso Livello:\n\nSuddivisione in Parti più Semplici: Spezzare le espressioni complesse in sottoespressioni più semplici, possibilmente in diverse righe o funzioni.\nUso di Variabili Intermedie: Assegnare parti dell’espressione a variabili intermedie con nomi significativi.\nCommenti Esplicativi: Quando la complessità è inevitabile, i commenti possono aiutare a spiegare l’intento dell’espressione.\n\nEsempio di Espressione Complessa in C\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n \nint main() {\n    char stringa[100] = &quot;Esempio di espressione complessa&quot;;\n    int lunghezza = strlen(stringa);\n \n    if (lunghezza &gt; 10 &amp;&amp; stringa[0] == &#039;E&#039; &amp;&amp; stringa[lunghezza - 1] == &#039;a&#039;) {\n        printf(&quot;La stringa soddisfa i criteri complessi\\n&quot;);\n    }\n \n    return 0;\n}\nRefactoring per Semplificare l’Espressione\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdbool.h&gt;\n \nbool verifica_criteri(const char *stringa, int lunghezza) {\n    bool iniziaConE = stringa[0] == &#039;E&#039;;\n    bool finisceConA = stringa[lunghezza - 1] == &#039;a&#039;;\n    bool lunghezzaMaggioreDi10 = lunghezza &gt; 10;\n \n    return iniziaConE &amp;&amp; finisceConA &amp;&amp; lunghezzaMaggioreDi10;\n}\n \nint main() {\n    char stringa[100] = &quot;Esempio di espressione complessa&quot;;\n    int lunghezza = strlen(stringa);\n \n    if (verifica_criteri(stringa, lunghezza)) {\n        printf(&quot;La stringa soddisfa i criteri semplificati\\n&quot;);\n    }\n \n    return 0;\n}\nIn questo refactoring, l’espressione complessa è stata suddivisa in una funzione verifica_criteri che utilizza variabili intermedie con nomi significativi. Ciò rende il codice più leggibile e facile da capire, mantenendo la stessa logica.\nCode Smell: Commenti “Cosa”\nDefinizione: I commenti “Cosa” sono un code smell che si verifica quando il codice è accompagnato da commenti che spiegano in dettaglio cosa fa una specifica porzione di codice. Sebbene i commenti siano importanti per la documentazione, la necessità di spiegare dettagliatamente “cosa” sta facendo il codice indica spesso che il codice stesso non è sufficientemente chiaro o autoesplicativo.\nProblemi Causati dai Commenti ‘Cosa’:\n\nCodice Non Intuitivo: Se è necessario spiegare cosa fa il codice, probabilmente non è abbastanza chiaro.\nManutenzione Complicata: I commenti possono diventare obsoleti o fuorvianti se non vengono aggiornati insieme al codice.\nLeggibilità Ridotta: Troppi commenti possono rendere il codice più difficile da leggere, soprattutto se sono lunghi o complicati.\n\nSoluzioni per Commenti ‘Cosa’:\n\nRifattorizzazione per Maggiore Chiarezza: Riscrivere il codice per renderlo più chiaro e autoesplicativo.\nUso di Nomi Descrittivi: Usare nomi di variabili, funzioni e classi che descrivono chiaramente cosa fanno.\nRiduzione della Complessità: Semplificare il codice spezzando le funzioni complesse in parti più piccole e gestibili.\n\nEsempio di Commenti “Cosa” in C\nImmaginiamo un programma che calcola il punteggio finale di un gioco basato su punti guadagnati, penalità, e un bonus per il raggiungimento di un certo livello.\n#include &lt;stdio.h&gt;\n \nint main() {\n    int puntiGuadagnati = 85; // Punti ottenuti giocando\n    int penalita = 5; // Penalità per errori\n    int livello = 4; // Livello raggiunto dal giocatore\n    int punteggioFinale;\n \n    // Calcolo del punteggio base sottraendo la penalità\n    int punteggioBase = puntiGuadagnati - penalita;\n \n    // Controllo se il giocatore ha raggiunto il livello 3\n    // Se sì, aggiungi un bonus di 10 punti\n    int bonus = 0;\n    if (livello &gt;= 3) {\n        bonus = 10; // Bonus per aver raggiunto il livello 3\n    }\n \n    // Calcolo del punteggio finale sommando punteggio base e bonus\n    punteggioFinale = punteggioBase + bonus;\n \n    printf(&quot;Punteggio Finale: %d\\n&quot;, punteggioFinale);\n    return 0;\n}\nQuesto codice è pieno di commenti “cosa” che spiegano ogni singola riga, rendendo il codice sovraccarico e meno leggibile.\nRefactoring per Ridurre i Commenti e Migliorare la Chiarezza\n#include &lt;stdio.h&gt;\n \nint calcolaPunteggioBase(int punti, int penalita) {\n    return punti - penalita;\n}\n \nint calcolaBonus(int livello) {\n    const int livelloBonus = 3;\n    const int valoreBonus = 10;\n \n    if (livello &gt;= livelloBonus) {\n        return valoreBonus;\n    }\n    return 0;\n}\n \nint main() {\n    int puntiGuadagnati = 85;\n    int penalita = 5;\n    int livello = 4;\n \n    int punteggioBase = calcolaPunteggioBase(puntiGuadagnati, penalita);\n    int bonus = calcolaBonus(livello);\n \n    int punteggioFinale = punteggioBase + bonus;\n \n    printf(&quot;Punteggio Finale: %d\\n&quot;, punteggioFinale);\n    return 0;\n}\nNel codice rifattorizzato, abbiamo rimosso la necessità di commenti ridondanti suddividendo il codice in funzioni più piccole e descrittive. Ogni funzione ha un nome che chiarisce il suo scopo, rendendo il codice complessivamente più leggibile e comprensibile senza l’eccesso di commenti. Questo esempio dimostra come un codice ben strutturato possa spesso “parlare da sé”, riducendo la necessità di commenti esplicativi.\nNomi Oscuri\nDefinizione:\nIl code smell “Nomi Oscuri” si verifica quando i nomi di variabili, funzioni, classi o altri identificatori in un programma non sono descrittivi o chiari riguardo al loro scopo o al ruolo che svolgono nel codice. Questi nomi possono essere troppo brevi, vaghi o non avere un legame diretto con la loro funzione nel programma.\nProblemi Causati da Nomi Oscuri:\n\nComprensione Ridotta: I nomi non descrittivi rendono il codice difficile da comprendere e seguire.\nManutenibilità Compromessa: Il codice con nomi oscuri è più difficile da modificare o correggere perché non è chiaro come le varie parti si relazionino tra loro.\nDifficoltà di Collaborazione: I nuovi sviluppatori o i membri del team faticano a lavorare sul codice a causa della mancanza di chiarezza.\n\nSoluzioni per Nomi Oscuri:\n\nRinominare con Nomi Descrittivi: Scegliere nomi che spieghino chiaramente lo scopo o il ruolo dell’entità nel codice.\nUtilizzo di Convenzioni di Denominazione: Adottare uno standard per la denominazione che sia consistente in tutto il codice.\n\nEsempio di Nomi Oscuri in C\n#include &lt;stdio.h&gt;\n \nint main() {\n    int a = 50; // Quantità di prodotto\n    int b = 3;  // Prezzo per unità\n    int c;      // Costo totale\n \n    c = a * b;\n    printf(&quot;Costo Totale: %d\\n&quot;, c);\n    return 0;\n}\nIn questo esempio, i nomi delle variabili a, b e c sono oscuri e non descrivono ciò che rappresentano.\nRefactoring per Migliorare la Chiarezza dei Nomi\n#include &lt;stdio.h&gt;\n \nint main() {\n    int quantitaProdotto = 50;\n    int prezzoPerUnita = 3;\n    int costoTotale;\n \n    costoTotale = quantitaProdotto * prezzoPerUnita;\n    printf(&quot;Costo Totale: %d\\n&quot;, costoTotale);\n    return 0;\n}\nNel codice rifattorizzato, abbiamo rinominato le variabili in quantitaProdotto, prezzoPerUnita e costoTotale, rendendo immediatamente chiaro il loro scopo nel programma. Questo miglioramento della chiarezza aiuta a rendere il codice più leggibile e comprensibile.\nNomi Incoerenti\nDefinizione:\nIl code smell “Nomi Incoerenti” si verifica quando ci sono discrepanze e mancanza di coerenza nell’uso di nomi e identificatori all’interno del codice. Questa incoerenza può manifestarsi nell’uso non uniforme di maiuscole e minuscole, nella variazione degli stili di denominazione (come camelCase, snake_case, etc.), o nella mancata adesione a convenzioni di denominazione stabiliti.\nProblemi Causati da Nomi Incoerenti:\n\nLeggibilità Ridotta: L’incoerenza nella denominazione rende il codice meno intuitivo e più difficile da seguire.\nErrori: Può portare a errori, specialmente in linguaggi sensibili alla distinzione tra maiuscole e minuscole.\nManutenzione Complicata: Rende più difficile la ricerca e il riconoscimento di specifici identificatori nel codice.\n\nSoluzioni per Nomi Incoerenti:\n\nStandardizzazione dei Nomi: Decidere e adottare una convenzione di denominazione coerente in tutto il codice.\nRevisione e Correzione: Passare in rassegna il codice esistente per correggere le discrepanze.\n\nEsempio di Nomi Incoerenti in C\n#include &lt;stdio.h&gt;\n \nint main() {\n    int NumeroArticoli = 30;\n    int costoPerArticolo = 45;\n    int totale_costo;\n \n    totale_costo = NumeroArticoli * costoPerArticolo;\n    printf(&quot;Costo totale: %d\\n&quot;, totale_costo);\n    return 0;\n}\nQui, NumeroArticoli usa PascalCase, costoPerArticolo usa camelCase, e TotaleCosto usa snake_case, creando una mancanza di coerenza.\nRefactoring per Coerenza nei Nomi\n#include &lt;stdio.h&gt;\n \nint main() {\n    int numeroArticoli = 30;       // Uso coerente di camelCase\n    int costoPerArticolo = 45;     // Uso coerente di camelCase\n    int totaleCosto;               // Uso coerente di camelCase\n \n    totaleCosto = numeroArticoli * costoPerArticolo;\n    printf(&quot;Costo totale: %d\\n&quot;, totaleCosto);\n    return 0;\n}\nIn questo esempio rifattorizzato, tutti i nomi delle variabili sono stati modificati per seguire lo stile camelCase, creando una coerenza nell’intero frammento di codice. Questo aumenta la leggibilità e riduce la possibilità di confusione o errori.\nDead Code (Codice Morto)\nDefinizione: Il “Dead Code” o “Codice Morto” è un code smell che si verifica quando ci sono parti di codice in un programma che non vengono mai eseguite o utilizzate. Questo può includere funzioni mai chiamate, codice dopo istruzioni return, variabili mai utilizzate, e così via. Il codice morto rende il programma più grande e più complicato senza alcun motivo.\nProblemi Causati dal Codice Morto:\n\nManutenzione Complicata: Aumenta inutilmente la complessità e la quantità di codice da mantenere.\nConfusione: Può generare confusione tra gli sviluppatori, che potrebbero chiedersi se quel codice sia importante o meno.\nSpreco di Risorse: Occupa spazio e risorse senza fornire alcun beneficio.\n\nSoluzioni per il Codice Morto:\n\nIdentificazione e Rimozione: Utilizzare strumenti di analisi statica per identificare il codice morto e rimuoverlo.\nRevisione Regolare del Codice: Fare revisioni periodiche del codice per cercare e eliminare parti inutilizzate.\n\nEsempio di Codice Morto in C\nImmaginiamo un programma che calcola statistiche su un array di dati, ma contiene variabili e porzioni di codice che non vengono mai utilizzate effettivamente.\n#include &lt;stdio.h&gt;\n \nint calcolaMassimo(int dati[], int lunghezza) {\n    int massimo = dati[0];\n    for (int i = 1; i &lt; lunghezza; i++) {\n        if (dati[i] &gt; massimo) {\n            massimo = dati[i];\n        }\n    }\n    return massimo;\n}\n \nint main() {\n    int dati[] = {10, 20, 30, 40, 50};\n    int lunghezzaDati = sizeof(dati) / sizeof(dati[0]);\n \n    int massimo = calcolaMassimo(dati, lunghezzaDati);\n \n    int minimo = 9999;\n    int somma = 0;\n    int media;\n \n    for (int i = 0; i &lt; lunghezzaDati; i++) {\n        somma += dati[i];\n    }\n    media = somma / lunghezzaDati;\n \n    printf(&quot;Massimo: %d\\n&quot;, massimo);\n    return 0;\n}\nIn questo esempio, le variabili minimo, somma e media, insieme al codice che le calcola, non vengono mai utilizzate nel programma.\nRefactoring per Rimuovere il Codice Morto\n#include &lt;stdio.h&gt;\n \nint calcolaMassimo(int dati[], int lunghezza) {\n    int massimo = dati[0];\n    for (int i = 1; i &lt; lunghezza; i++) {\n        if (dati[i] &gt; massimo) {\n            massimo = dati[i];\n        }\n    }\n    return massimo;\n}\n \nint main() {\n    int dati[] = {10, 20, 30, 40, 50};\n    int lunghezzaDati = sizeof(dati) / sizeof(dati[0]);\n \n    int massimo = calcolaMassimo(dati, lunghezzaDati);\n \n    printf(&quot;Massimo: %d\\n&quot;, massimo);\n    return 0;\n}\nCon questo refactoring, abbiamo eliminato le variabili e il codice inutilizzato, rendendo il programma più diretto e facile da comprendere. Questo aiuta a concentrarsi sulle parti del codice che hanno un effettivo impatto sulla funzionalità del programma.\nGeneralità Speculativa\nDefinizione:\nLa “Generalità Speculativa” è un code smell che si verifica quando il codice viene scritto in modo eccessivamente generale o complesso, con l’intento di coprire possibili esigenze o casi d’uso futuri che non sono ancora realtà. Questo approccio va contro il principio “You Ain’t Gonna Need It” (YAGNI) dell’Extreme Programming, che raccomanda di implementare funzionalità solo quando sono effettivamente necessarie.\nProblemi Causati dalla Generalità Speculativa:\n\nComplessità Non Necessaria: Aggiunge complessità senza un beneficio immediato, rendendo il codice più difficile da comprendere e mantenere.\nSpreco di Risorse: Investimento di tempo e risorse nello sviluppo di funzionalità che potrebbero non essere mai utilizzate.\nDifficoltà nella Manutenzione: La manutenzione di codice non utilizzato o eccessivamente complesso può diventare onerosa.\n\nSoluzioni per la Generalità Speculativa:\n\nAdottare il Principio YAGNI: Sviluppare solo funzionalità che sono immediatamente necessarie.\nSemplificazione del Codice: Rimuovere o semplificare parti del codice che non servono agli scopi attuali del software.\n\nEsempio di Generalità Speculativa in C\nNell’esempio, abbiamo una libreria per gestire un semplice database di utenti, che include funzioni aggiunte in modo speculativo per funzionalità future.\n#include &lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n \ntypedef struct {\n    char* name;\n    int age;\n    char* futureFeature;\n} User;\n \n// Initializes a user\nUser* createUser(const char* name, int age) {\n    User* newUser = (User*)malloc(sizeof(User));\n    if (!newUser) return NULL;\n    \n    newUser-&gt;name = (char*)malloc(strlen(name) + 1);\n    strcpy(newUser-&gt;name, name);\n    newUser-&gt;age = age;\n    newUser-&gt;futureFeature = NULL;\n    return newUser;\n}\n \n// Displays user information\nvoid displayUser(User* user) {\n    if (user == NULL) return;\n    printf(&quot;Name: %s, Age: %d\\n&quot;, user-&gt;name, user-&gt;age);\n}\n \nvoid updateUserFeature(User* user, const char* feature) {\n    if (user == NULL) return;\n    if (user-&gt;futureFeature != NULL) free(user-&gt;futureFeature);\n    user-&gt;futureFeature = (char*)malloc(strlen(feature) + 1);\n    strcpy(user-&gt;futureFeature, feature);\n}\n \nint main() {\n    User* user = createUser(&quot;John Doe&quot;, 30);\n    displayUser(user);\n    \n    // Cleanup\n    free(user-&gt;name);\n    free(user-&gt;futureFeature);\n    free(user);\n    return 0;\n}\n \nRefactoring per Eliminare la Generalità Speculativa\n#include &lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n \ntypedef struct {\n    char* name;\n    int age;\n} User;\n \n// Initializes a user\nUser* createUser(const char* name, int age) {\n    User* newUser = (User*)malloc(sizeof(User));\n    if (!newUser) return NULL;\n    \n    newUser-&gt;name = (char*)malloc(strlen(name) + 1);\n    strcpy(newUser-&gt;name, name);\n    newUser-&gt;age = age;\n    return newUser;\n}\n \n// Displays user information\nvoid displayUser(User* user) {\n    if (user == NULL) return;\n    printf(&quot;Name: %s, Age: %d\\n&quot;, user-&gt;name, user-&gt;age);\n}\n \nint main() {\n    User* user = createUser(&quot;John Doe&quot;, 30);\n    displayUser(user);\n    \n    // Cleanup\n    free(user-&gt;name);\n    free(user);\n    return 0;\n}\n \n\nRimosso futureFeature dalla struct User: Questo campo era stato aggiunto in previsione di requisiti futuri ma non viene utilizzato nella versione corrente del software, portando ad allocazioni di memoria inutili e complessità.\nRimossa la funzione updateUserFeature: Questa funzione era speculativa e progettata per gestire una funzionalità non utilizzata. Eliminandola, semplifichiamo il codice e ci concentriamo sulle funzionalità attualmente necessarie.\n\nQuesto processo di rifattorizzazione elimina la generalità speculativa rimuovendo codice e funzionalità inutilizzati, rendendo il codice più semplice e più facile da mantenere.\nCode Smell: Troppi If/Else e Switch\nDefinizione: Il code smell “Troppi If/Else e Switch” emerge quando un programma fa un uso eccessivo di istruzioni condizionali complesse come if, else if, else, e switch. Questa pratica può rendere il codice difficile da leggere, comprendere e mantenere. Spesso indica una violazione del principio di singola responsabilità e può suggerire la necessità di rifattorizzare il codice in un design più pulito e modulare.\nProblemi Causati da Troppi If/Else e Switch:\n\nLeggibilità Ridotta: Sequenze complesse di condizioni possono rendere il codice difficile da seguire.\nManutenibilità Complicata: Aggiungere nuove condizioni o modificare quelle esistenti diventa complicato e propenso ad errori.\nViolazione del Principio di Singola Responsabilità: Il codice potrebbe assumere troppe responsabilità, rendendolo meno riutilizzabile e più difficile da testare.\n\nSoluzioni per Troppi If/Else e Switch:\n\nRifattorizzazione in Funzioni o Classi: Suddividere il codice in funzioni o classi più piccole e specializzate.\nUso di Polimorfismo: In contesti OOP, utilizzare il polimorfismo per gestire comportamenti diversi basati su tipi diversi.\nPattern Strategy o State: Utilizzare pattern di design come Strategy o State per gestire complesse logiche condizionali.\n\nEsempio di Troppi If/Else e Switch in C\nImmaginiamo di avere un programma che gestisce diverse operazioni in base al giorno della settimana.\n#include &lt;stdio.h&gt;\n \nvoid gestisciGiorno(int giorno) {\n    if (giorno == 1) {\n        printf(&quot;Lunedì: Pianificazione settimanale\\n&quot;);\n    } else if (giorno == 2) {\n        printf(&quot;Martedì: Riunioni interne\\n&quot;);\n    } else if (giorno == 3) {\n        printf(&quot;Mercoledì: Lavoro su progetti\\n&quot;);\n    } else if (giorno == 4) {\n        printf(&quot;Giovedì: Formazione\\n&quot;);\n    } else if (giorno == 5) {\n        printf(&quot;Venerdì: Report settimanale\\n&quot;);\n    } else if (giorno == 6) {\n        printf(&quot;Sabato: Giorno libero\\n&quot;);\n    } else if (giorno == 7) {\n        printf(&quot;Domenica: Giorno libero\\n&quot;);\n    } else {\n        printf(&quot;Errore: giorno non valido\\n&quot;);\n    }\n}\n \nint main() {\n    gestisciGiorno(3);\n    return 0;\n}\n\nRimosso futureFeature dalla struct User: Questo campo era stato aggiunto in previsione di requisiti futuri ma non viene utilizzato nella versione corrente del software, portando ad allocazioni di memoria inutili e complessità.\nRimossa la funzione updateUserFeature: Questa funzione era speculativa e progettata per gestire una funzionalità non utilizzata. Eliminandola, semplifichiamo il codice e ci concentriamo sulle funzionalità attualmente necessarie.\n\nQuesto processo di rifattorizzazione elimina la generalità speculativa rimuovendo codice e funzionalità inutilizzati, rendendo il codice più semplice e più facile da mantenere.\nRefactoring per Ridurre Troppi If/Else e Switch\nUn approccio efficace può essere l’utilizzo di un array di stringhe per rappresentare le attività di ciascun giorno, riducendo così la necessità di molteplici if/else.\n#include &lt;stdio.h&gt;\n \nvoid gestisciGiorno(int giorno) {\n    char *attivita[] = {\n        &quot;Errore: giorno non valido&quot;,   // indice 0 non utilizzato\n        &quot;Lunedì: Pianificazione settimanale&quot;, // 1\n        &quot;Martedì: Riunioni interne&quot;,          // 2\n        &quot;Mercoledì: Lavoro su progetti&quot;,      // 3\n        &quot;Giovedì: Formazione&quot;,                // 4\n        &quot;Venerdì: Report settimanale&quot;,        // 5\n        &quot;Sabato: Giorno libero&quot;,              // 6\n        &quot;Domenica: Giorno libero&quot;             // 7\n    };\n \n    if (giorno &gt;= 1 &amp;&amp; giorno &lt;= 7) {\n        printf(&quot;%s\\n&quot;, attivita[giorno]);\n    } else {\n        printf(&quot;%s\\n&quot;, attivita[0]);\n    }\n}\n \nint main() {\n    gestisciGiorno(3);\n    return 0;\n}\nIn questo refactoring, il codice è stato semplificato utilizzando un array per mappare i giorni della settimana alle loro rispettive attività. Questo rende il programma più conciso e facilmente modificabile, eliminando la lunga serie di if/else.\nViolazione del Principio KISS\nDefinizione: La violazione del principio KISS (“Keep It Simple, Stupid”) si verifica quando il codice diventa innecessariamente complicato o sofisticato, perdendo in semplicità e chiarezza. Questo può succedere quando si introducono soluzioni o ottimizzazioni non necessarie, strutture complesse, o si cerca di anticipare bisogni futuri che potrebbero non materializzarsi mai.\nProblemi Causati dalla Violazione del Principio KISS:\n\nComprensione Difficoltosa: Il codice complesso è più difficile da leggere e capire.\nManutenzione Onerosa: La complessità superflua rende più difficile la manutenzione e l’aggiornamento del codice.\nIncremento del Rischio di Errori: La complessità aumenta la probabilità di errori e bug.\n\nSoluzioni per la Violazione del Principio KISS:\n\nSemplificare il Codice: Rivedere il codice per identificare e rimuovere la complessità non necessaria.\nConcentrarsi sulle Esigenze Immediate: Sviluppare funzionalità basandosi sulle necessità attuali piuttosto che su ipotetici bisogni futuri.\nEvitare l’Ottimizzazione Prematura: Non ottimizzare o complicare il codice prima che sia chiaro se e come queste modifiche saranno necessarie.\n\nEsempio di Violazione del Principio KISS in C\n#include &lt;stdio.h&gt;\n \nint main() {\n    int a = 10;\n    int b = 20;\n    int c = 30;\n    int risultato;\n \n    risultato = (a &gt; b ? (a &gt; c ? a : c) : (b &gt; c ? b : c));\n \n    printf(&quot;Il maggiore è: %d\\n&quot;, risultato);\n    return 0;\n}\nRefactoring che rispetta il principio KISS\n#include &lt;stdio.h&gt;\n \nint max(int x, int y) {\n    return x &gt; y ? x : y;\n}\n \nint main() {\n    int a = 10;\n    int b = 20;\n    int c = 30;\n    int risultato;\n \n    // Codice semplificato e più leggibile\n    risultato = max(a, max(b, c));\n \n    printf(&quot;Il maggiore è: %d\\n&quot;, risultato);\n    return 0;\n}\nIn questo esempio, il refactoring coinvolge l’introduzione di una funzione max per semplificare la logica di confronto, rendendo il codice principale più pulito e facile da seguire."},"Argomenti/Fattorizzazione-del-codice-e-makefile/Enum":{"slug":"Argomenti/Fattorizzazione-del-codice-e-makefile/Enum","filePath":"Argomenti/Fattorizzazione del codice e makefile/Enum.md","title":"Enum","links":[],"tags":[],"content":"Gli enum in C, abbreviazione di enumerations (enumerazioni), sono un tipo di dato utile per rappresentare un insieme di costanti intere sotto un unico nome. Questo può rendere il codice più leggibile e facile da mantenere, poiché consente di utilizzare nomi simbolici invece di valori numerici diretti, migliorando così la chiarezza del codice.\nDichiarazione di un Enum\nPer dichiarare un enum, si utilizza la parola chiave enum seguita da un nome opzionale per il tipo di enum e un elenco di identificatori racchiusi tra parentesi graffe. Ecco un esempio:\nenum giorno {LUNEDI, MARTEDI, MERCOLEDI, GIOVEDI, VENERDI, SABATO, DOMENICA};\nIn questo esempio, giorno è il nome del tipo di enum che rappresenta i giorni della settimana. LUNEDI, MARTEDI, MERCOLEDI, GIOVEDI, VENERDI, SABATO, e DOMENICA sono gli identificatori enumerati che rappresentano i valori possibili di giorno. Se non si specifica un valore per un identificatore, il valore di default per il primo identificatore è 0, e ogni identificatore successivo avrà un valore incrementato di 1 rispetto al precedente. Quindi, in questo caso, LUNEDI avrà il valore 0, MARTEDI avrà il valore 1, e così via.\nUtilizzo di un Enum\nDopo aver dichiarato un enum, è possibile dichiarare variabili di quel tipo e assegnarle uno dei valori enumerati. Ecco un esempio di come utilizzare l’enum dichiarato precedentemente:\nenum giorno oggi;\noggi = VENERDI;\nIn questo esempio, oggi è una variabile di tipo enum giorno, e le viene assegnato il valore VENERDI.\nVantaggi degli Enum\n\nLeggibilità: Utilizzare nomi simbolici rende il codice più leggibile e comprensibile.\nManutenibilità: È più facile aggiungere nuovi valori senza dover modificare il resto del codice.\nSicurezza di tipo: In alcuni contesti, l’utilizzo di enum può aiutare a prevenire errori, come l’assegnazione di valori non validi a variabili.\n\nAssegnazione di Valori Specifici\nÈ anche possibile assegnare valori specifici agli identificatori in un enum:\nenum mese {GENNAIO = 1, FEBBRAIO, MARZO, APRILE, MAGGIO, GIUGNO, LUGLIO, AGOSTO, SETTEMBRE, OTTOBRE, NOVEMBRE, DICEMBRE};\nIn questo caso, GENNAIO è esplicitamente impostato a 1. Gli identificatori successivi continueranno a incrementare da quel punto, rendendo FEBBRAIO = 2, MARZO = 3, e così via.\nGli enum in C forniscono un modo efficace per raggruppare costanti correlate, rendendo il codice più chiaro e facile da mantenere."},"Argomenti/Fattorizzazione-del-codice-e-makefile/Organizzazione-di-un-progetto-in-C,-headers-e-makefile":{"slug":"Argomenti/Fattorizzazione-del-codice-e-makefile/Organizzazione-di-un-progetto-in-C,-headers-e-makefile","filePath":"Argomenti/Fattorizzazione del codice e makefile/Organizzazione di un progetto in C, headers e makefile.md","title":"Organizzazione di un progetto in C, headers e makefile","links":[],"tags":[],"content":"Organizzazione del Progetto in C\nL’organizzazione efficace di un progetto in linguaggio C è fondamentale per garantire che il codice sia facilmente gestibile, comprensibile e manutenibile. Un progetto ben organizzato facilita anche la collaborazione tra sviluppatori e permette di scalare il progetto aggiungendo nuove funzionalità con minor sforzo. Di seguito sono presentate alcune linee guida su come organizzare i file e le directory in un progetto C.\nStruttura delle Directory\nUna chiara struttura delle directory aiuta a separare le diverse parti del progetto, come il codice sorgente, le librerie esterne, i file di header, e i file di test. Ecco un esempio di struttura di directory per un progetto C:\nprogetto_c/\n│\n├── src/               # Contiene i file sorgente (.c)\n│   ├── main.c\n│   └── calcoli.c\n│\n├── include/           # Contiene i file header (.h)\n│   └── calcoli.h\n│\n├── lib/               # Librerie esterne\n│   └── libreria_esterna/\n│\n├── tests/             # Test del codice\n│   └── test_calcoli.c\n│\n├── Makefile           # File Makefile per l&#039;automazione della compilazione\n│\n└── doc/               # Documentazione\n    └── manuale.md\n\nNomenclatura dei File\nLa scelta di nomi significativi per file e directory è essenziale per comprendere facilmente la funzione di ciascuna componente del progetto. I nomi dei file dovrebbero riflettere il loro contenuto o scopo. Per esempio, se un file contiene funzioni per gestire operazioni matematiche, potrebbe essere nominato calcoli.c o math_operations.c.\nModularità del Codice\nDividere il codice in moduli logici, ciascuno con una responsabilità ben definita, contribuisce non solo alla leggibilità ma anche alla riusabilità del codice. Ogni file sorgente .c dovrebbe avere un corrispondente file header .h che dichiara le funzioni, le variabili globali e le strutture dati che devono essere accessibili da altri file.\nUso dei File Header\nI file header (.h) dovrebbero essere usati per dichiarare interfacce a funzioni, strutture dati, e costanti globali. Questo permette di separare l’interfaccia (il “cosa” e il “come usarlo”) dall’implementazione (il “come funziona”), rendendo il codice più pulito e più facile da mantenere.\nDocumentazione\nIncludere commenti e documentazione nel codice e nei file header è vitale per aiutare altri sviluppatori (e te stesso in futuro) a comprendere rapidamente lo scopo e il funzionamento delle varie parti del progetto. Utilizzare commenti per descrivere lo scopo delle funzioni, i parametri, i valori di ritorno e qualsiasi effetto collaterale.\nVersioning\nL’uso di un sistema di versioning, come Git, permette di tenere traccia delle modifiche, collaborare con altri sviluppatori e gestire diverse versioni del progetto. Una buona pratica è includere un file .gitignore nella directory radice del progetto per escludere file temporanei e di compilazione dal versioning.\nL’adozione di queste linee guida per l’organizzazione di un progetto in C può notevolmente migliorare la qualità del codice, facilitare la collaborazione tra sviluppatori e rendere più semplice la gestione del progetto a lungo termine.\nUtilizzo dei file headers in un progetto C\nI file headers in un progetto C svolgono un ruolo cruciale nel definire le interfacce tra varie parti del codice. Questi file, tipicamente con estensione .h, contengono dichiarazioni di funzioni, definizioni di tipi di dati, macro e variabili globali utilizzate in diversi file sorgente .c. L’uso dei file headers migliora la modularità, la leggibilità e la manutenibilità del codice. Consentono agli sviluppatori di dividere il codice in componenti logiche separate, facilitando sia lo sviluppo in team sia la riusabilità del codice.\nDefinizione e scopo\nUn file header in C contiene dichiarazioni di funzioni e definizioni di tipi che devono essere condivise tra diversi file sorgente. Questo evita la duplicazione di codice e consente di modificare l’implementazione di una funzione senza dover cambiare il codice che la chiama, a patto che la firma della funzione rimanga invariata.\nEsempio pratico\nImmaginiamo di sviluppare un programma in C che gestisca operazioni matematiche di base. Si decide di dividere il progetto in due file: calcoli.h (il file header) e calcoli.c (il file sorgente).\ncalcoli.h\n// Verifica se il file header è già stato incluso\n#ifndef CALCOLI_H\n#define CALCOLI_H\n \n// Dichiarazione delle funzioni per l&#039;uso in altri file\nint somma(int a, int b);\nint differenza(int a, int b);\nint moltiplicazione(int a, int b);\nfloat divisione(int a, int b);\n \n#endif // Fine del controllo di inclusione CALCOLI_H\nQuesto file header definisce le interfacce per le operazioni matematiche di base. L’uso di #ifndef, #define e #endif (header guards) garantisce che il contenuto del file venga incluso solo una volta, prevenendo problemi di duplicazione durante la compilazione.\ncalcoli.c\n#include &quot;calcoli.h&quot; // Include il file header con le dichiarazioni\n \n// Implementazione delle funzioni dichiarate nel file header\nint somma(int a, int b) {\n    return a + b;\n}\n \nint differenza(int a, int b) {\n    return a - b;\n}\n \nint moltiplicazione(int a, int b) {\n    return a * b;\n}\n \nfloat divisione(int a, int b) {\n    if (b != 0) return (float)a / b;\n    else return -1.0; // Gestione semplice dell&#039;errore di divisione per zero\n}\nQuesto file sorgente implementa le funzioni dichiarate nel file header. Grazie all’inclusione di calcoli.h, il compilatore conosce le firme delle funzioni che saranno definite in calcoli.c.\nUtilizzo in un file main.c\n#include &lt;stdio.h&gt;\n#include &quot;calcoli.h&quot; // Inclusione del file header per usare le funzioni\n \nint main() {\n    int a = 10, b = 5;\n    printf(&quot;Somma: %d\\n&quot;, somma(a, b));\n    printf(&quot;Differenza: %d\\n&quot;, differenza(a, b));\n    printf(&quot;Moltiplicazione: %d\\n&quot;, moltiplicazione(a, b));\n    printf(&quot;Divisione: %.2f\\n&quot;, divisione(a, b));\n    return 0;\n}\nIn main.c, includendo il file header calcoli.h, possiamo utilizzare le funzioni matematiche definite in calcoli.c senza doverne conoscere l’implementazione dettagliata. Questo approccio non solo facilita la lettura e la manutenzione del codice ma promuove anche una programmazione più modulare e riutilizzabile.\nIncludere direttamente un file sorgente .c in un altro file .c è tecnicamente possibile in C, ma generalmente considerato una cattiva pratica di programmazione per diversi motivi:\n1. Compilazione separata e legami temporali\nL’organizzazione tradizionale del codice C in file header .h e file sorgente .c consente la compilazione separata dei moduli. Questo significa che se si modifica un file .c, solo quel modulo deve essere ricompilato, piuttosto che l’intero progetto. Includendo direttamente un file .c, si perde questo vantaggio, potenzialmente allungando i tempi di compilazione per grandi progetti.\n2. Visibilità e Incapsulamento\nI file header forniscono una chiara interfaccia tra differenti parti del codice, esponendo solo ciò che è necessario agli altri moduli e nascondendo i dettagli di implementazione (incapsulamento). Includendo direttamente i file .c, si espongono dettagli implementativi che dovrebbero rimanere privati, violando il principio dell’incapsulamento.\n3. Problematiche di Linking\nIncludendo un file .c direttamente in più file, si rischia di creare più definizioni dello stesso simbolo, portando a errori di linking. I compilatori C e i linker assumono che ogni simbolo abbia una singola definizione, secondo il principio “One Definition Rule” (ODR). Violare questa regola può causare errori difficili da diagnosticare.\n4. Gestione degli Header Guards\nI file header comunemente utilizzano “header guards” (o “include guards”) per prevenire inclusioni multiple e i relativi problemi di definizioni multiple. Se si includono file .c, i meccanismi tipici per prevenire l’inclusione multipla non saranno efficaci come con i file .h, potendo portare a definizioni duplicate e conflitti.\nConclusione\nSebbene sia tecnicamente possibile includere un file .c in un altro, è fortemente sconsigliato. L’uso di file header e file sorgente separati fornisce una struttura chiara, facilita la manutenzione del codice, e previene una serie di problemi comuni. È consigliabile seguire le convenzioni stabilite per garantire la modularità, l’incapsulamento e la manutenibilità del codice.\nMakefile e Automazione della Compilazione\nL’automazione della compilazione in un progetto C è fondamentale per migliorare l’efficienza dello sviluppo e garantire la correttezza delle build. I Makefile giocano un ruolo chiave in questo processo, permettendo agli sviluppatori di compilare facilmente l’intero progetto o parti di esso con semplici comandi. Questa sezione illustra il concetto di Makefile e come utilizzarli per automatizzare la compilazione di progetti C.\nCos’è un Makefile?\nUn Makefile è un file di testo che definisce un insieme di regole per compilare un programma. Contiene:\n\nTarget: il nome dell’output che il Makefile deve produrre.\nDipendenze: file che devono essere aggiornati prima di eseguire i comandi per il target specifico.\nComandi: istruzioni che make esegue per costruire un target dalle sue dipendenze.\n\nStruttura Base di un Makefile\ntarget: dependencies\n    command\nQuesta struttura consente di definire come compilare un programma specificando cosa bisogna costruire, da quali file dipende e quali comandi usare per farlo.\nEsempio di Makefile\nImmaginiamo di avere un progetto C con la seguente struttura:\nprogetto_c/\n├── src/\n│   ├── main.c\n│   └── calcoli.c\n├── include/\n│   └── calcoli.h\n\nUn semplice Makefile per questo progetto potrebbe apparire così:\n# Definisce il compilatore\nCC=gcc\n \n# Opzioni di compilazione\nCFLAGS=-Iinclude\n \n# Nome del file eseguibile\nTARGET=progetto_c\n \n# Regola per costruire l&#039;eseguibile\n$(TARGET): main.o calcoli.o\n\t$(CC) -o $(TARGET) main.o calcoli.o\n \n# Regola per compilare main.c\nmain.o: src/main.c\n\t$(CC) $(CFLAGS) -c src/main.c\n \n# Regola per compilare calcoli.c\ncalcoli.o: src/calcoli.c include/calcoli.h\n\t$(CC) $(CFLAGS) -c src/calcoli.c\n \n# Pulisce i file oggetto e l&#039;eseguibile\nclean:\n\trm -f *.o $(TARGET)\nNota bene: i comandi devono iniziare con una tabulazione, il makefile non funziona se uso gli spazi al posto del tab.\nSpiegazione\nEcco come funziona, passo dopo passo:\n\n\nDefinizione del compilatore: La prima linea specifica il compilatore da usare, in questo caso gcc, il GNU Compiler Collection per C e altri linguaggi. La sintassi CC=gcc assegna il compilatore alla variabile CC, che verrà utilizzata nelle regole successive per invocare il compilatore.\nCC=gcc\n\n\nOpzioni di compilazione: Qui vengono definite le opzioni da passare al compilatore. CFLAGS=-Iinclude dice al compilatore di cercare gli header files nella directory include. Questo è utile quando i tuoi file sorgente fanno riferimento a header files personalizzati non presenti nei percorsi standard di ricerca.\nCFLAGS=-Iinclude\n\n\nNome del file eseguibile: Questa linea definisce il nome dell’eseguibile che sarà generato, in questo caso progetto_c.\nTARGET=progetto_c\n\n\nRegola per costruire l’eseguibile: Questa regola dice a make come costruire l’eseguibile finale. Dipende da main.o e calcoli.o, indicando che questi file oggetto devono essere creati prima che possa essere generato l’eseguibile. $(CC) -o $(TARGET) main.o calcoli.o utilizza il compilatore ($(CC), cioè gcc) per collegare i file oggetto main.o e calcoli.o in un eseguibile chiamato come il valore di $(TARGET), ossia progetto_c.\n$(TARGET): main.o calcoli.o\n    $(CC) -o $(TARGET) main.o calcoli.o\n\n\nRegole per compilare i file oggetto:\n\nmain.o: Questa regola specifica come generare il file main.o a partire da src/main.c. Usa il compilatore con le opzioni specificate in CFLAGS (-Iinclude) per compilare src/main.c, generando il file oggetto main.o.\nmain.o: src/main.c\n    $(CC) $(CFLAGS) -c src/main.c\n\ncalcoli.o: Simile alla regola per main.o, questa regola dice come generare calcoli.o da src/calcoli.c, includendo anche la dipendenza da include/calcoli.h per assicurarsi che calcoli.o venga ricompilato se calcoli.h cambia.\ncalcoli.o: src/calcoli.c include/calcoli.h\n    $(CC) $(CFLAGS) -c src/calcoli.c\n\n\n\n\nPulizia: La regola clean è un’opzione convenzionale per rimuovere tutti i file generati durante la compilazione, mantenendo pulita la directory del progetto. Esegue il comando rm -f *.o $(TARGET), che rimuove tutti i file oggetto (*.o) e l’eseguibile ($(TARGET)).\nclean:\n    rm -f *.o $(TARGET)\n\n\nUtilizzo\nPer compilare il progetto, basta navigare nella directory che contiene il Makefile e digitare make. Per pulire il progetto, si usa make clean.\nL’utilizzo di Makefile per l’automazione della compilazione rende il processo di costruzione del software più rapido, ripetibile e meno soggetto a errori, specialmente in progetti grandi o complessi.\nPreprocessor Directives\nLe direttive del preprocessore in C sono istruzioni che vengono valutate prima della compilazione del codice. Queste direttive, che iniziano con il simbolo #, forniscono al preprocessore indicazioni su come trattare il codice sorgente prima che sia effettivamente compilato dal compilatore. Le direttive del preprocessore possono influenzare significativamente la struttura e il comportamento del codice compilato, consentendo, tra l’altro, l’inclusione condizionale del codice, la definizione di macro e la compilazione condizionale. Di seguito sono descritte alcune delle direttive del preprocessore più comunemente utilizzate in C.\n’#include’\nLa direttiva #include viene utilizzata per includere il contenuto di un file header o di un altro file sorgente nel file corrente. È principalmente usata per includere le dichiarazioni di funzioni, tipi di dati e macro definiti nei file header.\n#include &lt;stdio.h&gt; // Includi un file header standard\n#include &quot;mio_header.h&quot; // Includi un file header personalizzato\n’#define’\nLa direttiva #define crea una macro, che è un frammento di codice che il preprocessore sostituisce con un altro testo. Le macro possono essere utilizzate per definire costanti o funzioni macro.\n#define PI 3.14159\n#define SOMMA(x, y) ((x) + (y))\n’#ifdef’, ‘#ifndef’, ‘#endif’\nQueste direttive permettono di includere o escludere parti di codice a seconda che una macro sia stata definita (#ifdef) o non definita (#ifndef). Sono spesso usate per gestire la compilazione condizionale del codice.\n#define DEBUG\n \n#ifdef DEBUG\n    printf(&quot;Debug attivo\\n&quot;);\n#endif\n \n#ifndef VERSIONE2\n    printf(&quot;Versione 1\\n&quot;);\n#endif\n’#if’, ‘#else’, ‘#elif’, ‘#endif’\nSimili a #ifdef e #ifndef, ma più potenti, queste direttive consentono di eseguire controlli più complessi e includere o escludere codice basandosi su condizioni specifiche.\n#define VERSIONE 2\n \n#if VERSIONE == 1\n    printf(&quot;Versione 1 del software\\n&quot;);\n#elif VERSIONE == 2\n    printf(&quot;Versione 2 del software\\n&quot;);\n#else\n    printf(&quot;Versione del software non supportata\\n&quot;);\n#endif\n’#error’\nLa direttiva #error causa la generazione di un messaggio di errore dal preprocessore se viene incontrata durante la fase di preprocessing. È utile per segnalare errori di configurazione o condizioni non supportate.\n#if !defined(__GNUC__)\n#error &quot;Questo codice richiede il compilatore GCC&quot;\n#endif\n’#pragma’\nLa direttiva #pragma è utilizzata per fornire istruzioni specifiche al compilatore, come l’ottimizzazione del codice o la disabilitazione di determinati warning. Il comportamento di #pragma è specifico del compilatore utilizzato.\nBuone Pratiche per la Scrittura di File Headers\nI file headers (.h) svolgono un ruolo cruciale nei progetti C, fungendo da ponte tra i vari file sorgente (.c) e facilitando la modularità e la riutilizzabilità del codice. Per garantire che i file headers siano efficaci e mantengano alta la qualità del progetto, è essenziale seguire alcune buone pratiche durante la loro scrittura.\nUtilizzare Header Guards\nGli “header guards” prevengono l’inclusione multipla dello stesso file header, che potrebbe portare a definizioni duplicate e altri problemi di compilazione. Utilizzare #ifndef, #define, e #endif all’inizio e alla fine del file header.\n#ifndef MIO_HEADER_H\n#define MIO_HEADER_H\n \n// Contenuto del file header\n \n#endif // MIO_HEADER_H\nMantenere un’Interfaccia Pulita\nI file headers dovrebbero contenere solo dichiarazioni di funzioni, definizioni di tipi (ad esempio, struct e typedef), macro e costanti globali necessarie per utilizzare il codice nel file sorgente corrispondente. Evitare di includere definizioni di variabili globali o implementazioni di funzioni.\nDocumentare il Codice\nCommentare ampiamente i file headers per spiegare lo scopo e l’uso di ciascuna funzione, tipo di dati e macro. Questo aiuta altri sviluppatori a capire come utilizzare il codice senza dover esaminare l’implementazione.\nEcco come modificare calcoli.h per documentarlo correttamente (e poi guarda cosa succede quando passi sopra al nome delle funzioni nel main con il tuo IDE):\n// Verifica se il file header è già stato incluso\n#ifndef CALCOLI_H\n#define CALCOLI_H\n \n/**\n * Effettua la somma di due interi.\n * \n * @param a Il primo intero da sommare.\n * @param b Il secondo intero da sommare.\n * @return La somma di a e b.\n */\nint somma(int a, int b);\n \n/**\n * Calcola la differenza tra due interi.\n * \n * @param a Il minuendo.\n * @param b Il sottraendo.\n * @return La differenza tra a e b.\n */\nint differenza(int a, int b);\n \n/**\n * Moltiplica due interi.\n * \n * @param a Il primo fattore.\n * @param b Il secondo fattore.\n * @return Il prodotto di a e b.\n */\nint moltiplicazione(int a, int b);\n \n/**\n * Divide due interi e restituisce un float.\n * \n * Nota: se b è 0, il comportamento non è definito.\n * \n * @param a Il dividendo.\n * @param b Il divisore.\n * @return Il quoziente di a e b come float.\n */\nfloat divisione(int a, int b);\n \n#endif // Fine del controllo di inclusione CALCOLI_H\n \nUsare Nomi Significativi e Consistenti\nScegliere nomi chiari e descrittivi per funzioni, tipi di dati e macro e seguire una convenzione di denominazione coerente in tutto il progetto. Questo migliora la leggibilità e facilita la manutenzione del codice.\nSeparare le Definizioni in File Headers Appropriati\nOrganizzare logicamente le dichiarazioni e le definizioni raggruppandole in file headers in base alla loro funzionalità. Questo facilita la ricerca delle definizioni e aiuta a mantenere la modularità del progetto.\nMinimizzare le Dipendenze\nIncludere solo i file headers strettamente necessari in altri file headers per ridurre le dipendenze incrociate. Se possibile, utilizzare dichiarazioni in avanti (forward declarations) delle strutture e funzioni invece di includere interi file headers.\nstruct miaStruttura; // Dichiarazione in avanti\n \nvoid funzioneCheUsaMiaStruttura(struct miaStruttura* ms);\nEvitare l’Uso di “using namespace” in C++\nSebbene questa pratica sia specifica per C++, è importante ricordarla quando si lavora con progetti che possono includere codice sia C che C++. Evitare di usare using namespace std; nei file headers per prevenire conflitti di nomi e mantenere il codice pulito.\nGestione delle Dipendenze Cicliche\nLe dipendenze cicliche si verificano quando due o più file header si includono a vicenda, direttamente o indirettamente, creando un ciclo che può portare a errori di compilazione e problemi di design. Questo fenomeno può complicare significativamente la compilazione e la manutenibilità del codice. Ecco alcuni approcci e strategie per gestire e prevenire le dipendenze cicliche nei progetti C.\nIdentificazione delle Dipendenze Cicliche\nIl primo passo nella gestione delle dipendenze cicliche è identificarle. Questo può essere fatto esaminando gli #include presenti nei file header e verificando la presenza di cicli. Strumenti e IDE moderni possono aiutare nell’identificare queste dipendenze.\nUso di Dichiarazioni In Avanti (Forward Declarations)\nUna dichiarazione in avanti permette al compilatore di essere a conoscenza dell’esistenza di un tipo o di una funzione senza averne bisogno della definizione completa. Questo può essere utilizzato per rompere le dipendenze cicliche quando due o più moduli devono riferirsi l’uno all’altro.\n// Nel file A.h\nstruct B; // Dichiarazione in avanti di B\n \nstruct A {\n    struct B* b; // Usare il puntatore a B\n};\n \n// Nel file B.h\n#include &quot;A.h&quot;\n \nstruct B {\n    struct A a; // Utilizzo diretto di A\n};\nRidisegnare le Strutture dei Dati\nIn alcuni casi, le dipendenze cicliche possono indicare un problema di design. Riconsiderare come i moduli interagiscono tra loro e se possibile, ridisegnare le strutture dei dati per eliminare le dipendenze dirette.\nMinimizzare l’Inclusione di Header nei Header\nLimitare l’inclusione di file header nei file header. Invece di includere un file header, si può spesso procedere con una dichiarazione in avanti nel file header e includere il file header necessario solo nei file sorgente (.c). Questo riduce le dipendenze incrociate.\nSeparare le Dichiarazioni dalle Definizioni\nSeparare le dichiarazioni (in file header) dalle definizioni (in file sorgente) aiuta a ridurre le dipendenze. Le definizioni dipendono solo dalle dichiarazioni e non dall’inverso, contribuendo a eliminare le dipendenze cicliche.\nOrganizzazione Modulare del Codice\nOrganizzare il codice in moduli o pacchetti con una chiara separazione delle responsabilità può aiutare a prevenire le dipendenze cicliche. Ogni modulo dovrebbe avere un’interfaccia ben definita e dipendere il meno possibile da altri moduli.\nUso di Interfacce o Abstract Data Types (ADTs)\nIn C, è possibile simulare le interfacce o i tipi di dati astratti usando puntatori a funzioni e struct. Questo permette di definire interfacce modulari che possono essere implementate in modo indipendente, riducendo la necessità di dipendenze cicliche.\nRefactoring del Codice\nSe le dipendenze cicliche sono già presenti, può essere necessario un refactoring del codice. Questo potrebbe includere la ristrutturazione di moduli, l’introduzione di nuovi livelli di astrazione, o la modifica delle relazioni tra le parti del codice.\nGestire le dipendenze cicliche richiede attenzione e, in alcuni casi, cambiamenti significativi nel design del software. Tuttavia, affrontare questo problema migliora non solo la compilazione e l’esecuzione del programma ma anche la sua qualità generale, rendendo il codice più chiaro, manutenibile e flessibile.\nUtilizzo di doxygen per la creazione di documentazione\nCos’è Doxygen?\nDoxygen è uno strumento di generazione di documentazione per linguaggi di programmazione come C, C++, C#, Java, Objective-C, Python, PHP, e altri. È ampiamente utilizzato dagli sviluppatori per creare documentazione tecnica direttamente dai commenti nel codice sorgente, seguendo una sintassi specifica. Questo approccio permette di mantenere la documentazione coerente con il codice stesso, facilitando la comprensione e la manutenzione del software.\nCaratteristiche Principali\nDoxygen ha diverse caratteristiche distintive che lo rendono uno strumento prezioso per gli sviluppatori:\n\n\nGenerazione di Documentazione Automatica: Estrae automaticamente la documentazione dai commenti nel codice, generando output in vari formati come HTML, LaTeX, RTF, PDF, e XML.\n\n\nSupporto Multipiattaforma: Funziona su sistemi operativi diversi, inclusi Windows, macOS e Linux.\n\n\nDiagrammi: Integra la generazione di vari tipi di diagrammi, come i diagrammi delle classi o di gerarchia, utilizzando strumenti esterni come Graphviz.\n\n\nPersonalizzazione: Offre ampie opzioni di configurazione per personalizzare l’output della documentazione in base alle esigenze del progetto.\n\n\nSupporto Multilingua: Capace di documentare codice scritto in molti linguaggi di programmazione.\n\n\nCome Funziona\nDoxygen analizza i file sorgente leggendo i commenti speciali inseriti dagli sviluppatori. Questi commenti devono seguire una sintassi specifica che Doxygen può interpretare. Una volta analizzati i commenti e il codice, Doxygen genera la documentazione nel formato desiderato.\nGli sviluppatori possono controllare il processo di generazione della documentazione attraverso un file di configurazione, dove possono specificare quali file includere, il formato di output desiderato, e altre opzioni di personalizzazione.\nEsempio di Commento Doxygen\nPer illustrare come Doxygen estrae la documentazione dai commenti, ecco un semplice esempio di commento Doxygen in C++:\n/**\n * Una funzione che somma due numeri.\n * @param a Il primo numero da sommare.\n * @param b Il secondo numero da sommare.\n * @return La somma di a e b.\n */\nint somma(int a, int b) {\n    return a + b;\n}\nIn questo esempio, il commento inizia con /** e termina con */, con i tag @param che descrivono i parametri della funzione e @return che descrive il valore restituito dalla funzione. Doxygen utilizza questi commenti per generare la documentazione della funzione somma.\nConclusioni\nDoxygen rappresenta uno strumento essenziale per gli sviluppatori che cercano di creare documentazione accurata e aggiornata per i loro progetti software. Grazie alla sua capacità di integrarsi direttamente con il codice sorgente e di supportare una vasta gamma di linguaggi di programmazione e formati di output, Doxygen facilita la creazione di documentazione tecnica di alta qualità, migliorando la comprensibilità e la manutenibilità del software.\nDebugging e Gestione degli Errori\nIl debugging e la gestione degli errori sono componenti cruciali nello sviluppo di software affidabile. In C, diversi strumenti e tecniche possono essere utilizzati per identificare, tracciare e gestire gli errori, contribuendo a migliorare la qualità del codice. I file headers giocano un ruolo importante in questo contesto, fornendo meccanismi per incorporare funzionalità di debugging e gestione degli errori nel software.\nMacro per il Debugging\nLe macro possono essere utilizzate per inserire istruzioni di debug nel codice che possono essere abilitate o disabilitate facilmente. Questo approccio permette agli sviluppatori di includere ampie quantità di logging e controlli di debug senza impattare le prestazioni del software in produzione.\ndebug.h\n#ifndef DEBUG_H\n#define DEBUG_H\n \n#include &lt;stdio.h&gt;\n \n#ifdef DEBUG\n#define DEBUG_PRINT(fmt, args...) fprintf(stderr, &quot;DEBUG: %s:%d:%s(): &quot; fmt, \\\n    __FILE__, __LINE__, __func__, ##args)\n#else\n#define DEBUG_PRINT(fmt, args...) // Non fa nulla in produzione\n#endif\n \n#endif // DEBUG_H\nUtilizzando DEBUG_PRINT, gli sviluppatori possono aggiungere messaggi di debug nel codice che mostrano il file, la linea e la funzione da cui vengono chiamati, fornendo contesto utile durante il debugging.\nAssert per la Verifica delle Assunzioni\nLa macro assert è uno strumento di debug che può essere utilizzato per verificare le assunzioni fatte dal codice. Se l’espressione testata da assert risulta falsa, il programma termina e viene stampato un messaggio di errore, facilitando l’identificazione di condizioni anomale.\n#include &lt;assert.h&gt;\n \nvoid dividi(int numeratore, int denominatore) {\n    assert(denominatore != 0); // Assicura che il denominatore non sia zero\n    ...\n}\nGestione degli Errori\nPer una robusta gestione degli errori, i file headers possono definire codici di errore o tipi enumerati che rappresentano differenti condizioni di errore. Questi possono essere restituiti dalle funzioni per indicare successo o fallimento.\nerrori.h\n#ifndef ERRORI_H\n#define ERRORI_H\n \ntypedef enum {\n    SUCCESSO,\n    ERRORE_FILE_NON_TROVATO,\n    ERRORE_MEMORIA_ESAURITA,\n    ...\n} CodiceErrore;\n \n#endif // ERRORI_H\nLogging degli Errori\nFornire una funzione centralizzata per il logging degli errori può aiutare a mantenere un approccio consistente alla registrazione degli eventi di errore. Questo consente di controllare facilmente dove e come gli errori vengono registrati e riportati.\nlog_errori.h\n#ifndef LOG_ERRORI_H\n#define LOG_ERRORI_H\n \nvoid logErrore(const char* file, int linea, const char* funzione, CodiceErrore errore);\n \n#endif // LOG_ERRORI_H\nlog_errori.c\n#include &quot;log_errori.h&quot;\n#include &lt;stdio.h&gt;\n \nvoid logErrore(const char* file, int linea, const char* funzione, CodiceErrore errore) {\n    fprintf(stderr, &quot;ERRORE: [%s:%d] %s: Codice errore %d\\n&quot;, file, linea, funzione, errore);\n}\nImplementando queste tecniche di debugging e gestione degli errori, gli sviluppatori possono costruire software più affidabile, identificare rapidamente i problemi e gestirli in modo efficace.\nEsempi Avanzati\nGli esempi avanzati di utilizzo dei file headers in C possono illustrare concetti complessi e pratiche di programmazione avanzate, come la gestione di strutture dati complesse, l’implementazione di moduli e l’uso di funzionalità condizionali. Questi esempi mirano a mostrare come utilizzare i file headers per organizzare e modularizzare codice complesso in modo efficace.\nEsempio 1: Strutture Dati Complesse e Tipi Opachi\nUn tipo opaco in C è un tipo di dati la cui definizione è nascosta agli utenti del modulo, permettendo di modificare l’implementazione senza influenzare il codice che lo utilizza. Questo esempio dimostra come implementare una struttura dati opaca utilizzando i file headers.\nfilelist.h\n// Definizione del tipo opaco\ntypedef struct FileList FileList;\n \n// Funzioni per manipolare la struttura dati\nFileList* fileList_create();\nvoid fileList_destroy(FileList* list);\nvoid fileList_add(FileList* list, const char* filename);\nfilelist.c\n#include &quot;filelist.h&quot;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n \n// Definizione completa della struttura\nstruct FileList {\n    char** filenames;\n    size_t size;\n    size_t capacity;\n};\n \nFileList* fileList_create() {\n    FileList* list = malloc(sizeof(FileList));\n    list-&gt;filenames = malloc(sizeof(char*) * 10); // Dimensione iniziale\n    list-&gt;size = 0;\n    list-&gt;capacity = 10;\n    return list;\n}\n \nvoid fileList_destroy(FileList* list) {\n    for (size_t i = 0; i &lt; list-&gt;size; ++i) {\n        free(list-&gt;filenames[i]);\n    }\n    free(list-&gt;filenames);\n    free(list);\n}\n \nvoid fileList_add(FileList* list, const char* filename) {\n    if (list-&gt;size == list-&gt;capacity) {\n        // Raddoppia la capacità se necessario\n        list-&gt;capacity *= 2;\n        list-&gt;filenames = realloc(list-&gt;filenames, sizeof(char*) * list-&gt;capacity);\n    }\n    list-&gt;filenames[list-&gt;size++] = strdup(filename);\n}\nEsempio 2: Uso di Funzionalità Condizionali\nI file headers possono essere utilizzati per includere codice condizionalmente, ad esempio per abilitare o disabilitare funzionalità in base a macro definite.\nfeatures.h\n#ifndef FEATURES_H\n#define FEATURES_H\n \n// Abilita la funzionalità di debug se DEBUG è definita\n#ifdef DEBUG\nvoid debugPrint(const char* message);\n#else\n#define debugPrint(message) // Non fa nulla\n#endif\n \n#endif // FEATURES_H\nfeatures.c\n#include &quot;features.h&quot;\n#include &lt;stdio.h&gt;\n \n#ifdef DEBUG\nvoid debugPrint(const char* message) {\n    printf(&quot;DEBUG: %s\\n&quot;, message);\n}\n#endif\nQuesti esempi mostrano come utilizzare i file headers per creare interfacce chiare e modulari, gestire tipi di dati complessi in modo sicuro, organizzare il codice in moduli riutilizzabili e sfruttare la compilazione condizionale per abilitare o disabilitare funzionalità. Queste tecniche avanzate possono aiutare a costruire software più robusto, flessibile e manutenibile.\nConclusione della Dispensa\nQuesta dispensa ha esplorato vari aspetti dell’utilizzo dei file headers in un progetto C, coprendo l’organizzazione del progetto, l’automazione della compilazione con Makefile, l’uso delle direttive del preprocessore, le buone pratiche nella scrittura di file headers, la gestione delle dipendenze cicliche, esempi avanzati di implementazione e strategie per il debugging e la gestione degli errori. Seguendo queste linee guida, gli sviluppatori possono migliorare significativamente la struttura, la manutenibilità e l’affidabilità dei loro progetti in C, sfruttando al meglio le capacità del linguaggio per creare software robusto e efficiente."},"Argomenti/Fattorizzazione-del-codice-e-makefile/Progressione-di-esercizi-per-la-gestione-del-progetto":{"slug":"Argomenti/Fattorizzazione-del-codice-e-makefile/Progressione-di-esercizi-per-la-gestione-del-progetto","filePath":"Argomenti/Fattorizzazione del codice e makefile/Progressione di esercizi per la gestione del progetto.md","title":"Progressione di esercizi per la gestione del progetto","links":[],"tags":[],"content":"Struttura\nLa progressione di esercizi sarà strutturata nel seguente modo:\nParte 1: Struttura del Progetto e Nomenclatura dei File\n\nCreazione di una Struttura di Directory: Crea una struttura di directory come quella descritta nella dispensa per un progetto C di tua scelta.\nNomenclatura Consistente: Rinomina file esistenti secondo le convenzioni suggerite, riflettendo il loro scopo o contenuto.\n\nParte 2: Modularità del Codice\n\nDivisione in Moduli: Partendo da un programma C esistente, suddividi il codice in moduli logici separati, ciascuno con un file header (.h) e un file sorgente (.c).\nImplementazione delle Funzioni: Implementa un set di funzioni dichiarate in un file header, come l’esempio calcoli.h e calcoli.c.\n\nParte 3: Uso dei File Header\n\nCreazione e Uso dei File Header: Crea un file header che dichiara varie funzioni e utilizzalo in diversi file sorgente.\nHeader Guards: Aggiungi header guards a un file header esistente per prevenire inclusioni multiple.\n\nParte 4: Makefile e Automazione della Compilazione\n\nScrittura di un Makefile Semplice: Scrivi un Makefile che compili un progetto C composto da più file.\nAutomazione dei Test: Modifica il Makefile per includere un target che esegue automaticamente i test del codice.\n\nParte 5: Preprocessor Directives\n\nUso di #define per le Costanti: Utilizza #define per definire costanti utilizzate in più file.\nInclusione Condizionale: Scrivi codice che utilizza #ifdef, #ifndef e #endif per includere parti di codice solo se certe condizioni sono soddisfatte.\n\nParte 6: Debugging e Gestione degli Errori\n\nMacro di Debugging: Implementa una macro per il debugging che stampa messaggi solo se una certa macro (DEBUG, per esempio) è definita.\nAssert e Gestione degli Errori: Utilizza assert per verificare le assunzioni nel tuo codice e gestisci gli errori ritornando codici di errore specifici dalle funzioni.\n\nParte 7: Esempi Avanzati e Concetti Complessi\n\nTipi Opachi: Implementa una struttura dati usando un tipo opaco, seguendo l’esempio di FileList.\nFunzionalità Condizionali: Crea un modulo che compila in modo diverso a seconda delle macro definite, per esempio abilitando funzionalità di logging solo in modalità debug.\n\nCodice di partenza\nImmaginiamo di avere un singolo file sorgente C, biblioteca.c, che include tutto: la definizione delle strutture, la dichiarazione delle funzioni per la gestione dei libri e degli utenti, e un semplice main per testare queste funzionalità.\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n \n// Struttura per rappresentare un libro\ntypedef struct {\n    char titolo[50];\n    char autore[50];\n} Libro;\n \n// Struttura per rappresentare un utente\ntypedef struct {\n    char nome[50];\n    char cognome[50];\n} Utente;\n \n// Prototipi di funzioni per la gestione dei libri\nvoid aggiungiLibro(Libro *libri, int *numeroLibri, char *titolo, char *autore);\nvoid visualizzaLibri(Libro *libri, int numeroLibri);\n \n// Prototipi di funzioni per la gestione degli utenti\nvoid aggiungiUtente(Utente *utenti, int *numeroUtenti, char *nome, char *cognome);\nvoid visualizzaUtenti(Utente *utenti, int numeroUtenti);\n \nint main() {\n    Libro libri[10];\n    Utente utenti[10];\n    int numeroLibri = 0, numeroUtenti = 0;\n \n    aggiungiLibro(libri, &amp;numeroLibri, &quot;Il Signore degli Anelli&quot;, &quot;J.R.R. Tolkien&quot;);\n    aggiungiUtente(utenti, &amp;numeroUtenti, &quot;Mario&quot;, &quot;Rossi&quot;);\n \n    visualizzaLibri(libri, numeroLibri);\n    visualizzaUtenti(utenti, numeroUtenti);\n \n    return 0;\n}\n \nvoid aggiungiLibro(Libro *libri, int *numeroLibri, char *titolo, char *autore) {\n    strcpy(libri[*numeroLibri].titolo, titolo);\n    strcpy(libri[*numeroLibri].autore, autore);\n    (*numeroLibri)++;\n}\n \nvoid visualizzaLibri(Libro *libri, int numeroLibri) {\n    printf(&quot;Libri nella biblioteca:\\n&quot;);\n    for(int i = 0; i &lt; numeroLibri; i++) {\n        printf(&quot;%d: %s di %s\\n&quot;, i+1, libri[i].titolo, libri[i].autore);\n    }\n}\n \nvoid aggiungiUtente(Utente *utenti, int *numeroUtenti, char *nome, char *cognome) {\n    strcpy(utenti[*numeroUtenti].nome, nome);\n    strcpy(utenti[*numeroUtenti].cognome, cognome);\n    (*numeroUtenti)++;\n}\n \nvoid visualizzaUtenti(Utente *utenti, int numeroUtenti) {\n    printf(&quot;Utenti della biblioteca:\\n&quot;);\n    for(int i = 0; i &lt; numeroUtenti; i++) {\n        printf(&quot;%d: %s %s\\n&quot;, i+1, utenti[i].nome, utenti[i].cognome);\n    }\n}\nParte 1,2 e 3 struttura del progetto\nCon questo codice come punto di partenza, possiamo procedere agli esercizi delle Parti 1, 2 e 3. Ecco come suddividere il codice esistente seguendo gli esercizi proposti:\n\n\nStruttura del Progetto e Nomenclatura dei File: Suddividi il codice esistente in più file seguendo la struttura proposta negli esercizi della Parte 1. Dovrai creare i file main.c, gestione_libri.c, gestione_utenti.c e i corrispondenti file header gestione_libri.h e gestione_utenti.h.\n\n\nModularità del Codice: Assicurati che ogni modulo (libri e utenti) abbia il proprio file sorgente e header, come specificato nella Parte 2 degli esercizi.\n\n\nUso dei File Header: Sposta le dichiarazioni delle strutture e i prototipi delle funzioni nei rispettivi file header. Assicurati di includere gli header necessari nei file sorgente dove queste strutture o funzioni vengono utilizzate, seguendo le istruzioni della Parte 3.\nProcediamo con lo svolgimento degli esercizi, partendo dalla suddivisione del codice preesistente in una struttura di progetto organizzata e modulare. Seguendo la struttura proposta, creeremo file specifici per gestire libri e utenti, oltre al file main.c per il punto di ingresso del programma.\n\n\nLa struttura del progetto sarà suddivisa come segue:\n\nsrc/ - Contiene i file sorgente .c\n\nmain.c\ngestione_libri.c\ngestione_utenti.c\n\n\ninclude/ - Contiene i file header .h\n\ngestione_libri.h\ngestione_utenti.h\n\n\nlib/ - Per eventuali librerie esterne (vuota per questo esercizio)\ntests/ - Per i test del codice (sarà considerato in seguito)\ndoc/ - Per la documentazione (può essere riempita più avanti)\n\nFile: gestione_libri.h\n// Verifica se il file header è già stato incluso\n#ifndef GESTIONE_LIBRI_H\n#define GESTIONE_LIBRI_H\n \n// Struttura per rappresentare un libro\ntypedef struct {\n    char titolo[50];\n    char autore[50];\n} Libro;\n \n// Prototipi di funzioni per la gestione dei libri\nvoid aggiungiLibro(Libro *libri, int *numeroLibri, char *titolo, char *autore);\nvoid visualizzaLibri(Libro *libri, int numeroLibri);\n \n#endif // GESTIONE_LIBRI_H\nFile: gestione_libri.c\n#include &quot;gestione_libri.h&quot;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n \nvoid aggiungiLibro(Libro *libri, int *numeroLibri, char *titolo, char *autore) {\n    strcpy(libri[*numeroLibri].titolo, titolo);\n    strcpy(libri[*numeroLibri].autore, autore);\n    (*numeroLibri)++;\n}\n \nvoid visualizzaLibri(Libro *libri, int numeroLibri) {\n    printf(&quot;Libri nella biblioteca:\\n&quot;);\n    for(int i = 0; i &lt; numeroLibri; i++) {\n        printf(&quot;%d: %s di %s\\n&quot;, i+1, libri[i].titolo, libri[i].autore);\n    }\n}\nFile: gestione_utenti.h\n#ifndef GESTIONE_UTENTI_H\n#define GESTIONE_UTENTI_H\n \n// Struttura per rappresentare un utente\ntypedef struct {\n    char nome[50];\n    char cognome[50];\n} Utente;\n \n// Prototipi di funzioni per la gestione degli utenti\nvoid aggiungiUtente(Utente *utenti, int *numeroUtenti, char *nome, char *cognome);\nvoid visualizzaUtenti(Utente *utenti, int numeroUtenti);\n \n#endif // GESTIONE_UTENTI_H\nFile: gestione_utenti.c\n#include &quot;gestione_utenti.h&quot;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n \nvoid aggiungiUtente(Utente *utenti, int *numeroUtenti, char *nome, char *cognome) {\n    strcpy(utenti[*numeroUtenti].nome, nome);\n    strcpy(utenti[*numeroUtenti].cognome, cognome);\n    (*numeroUtenti)++;\n}\n \nvoid visualizzaUtenti(Utente *utenti, int numeroUtenti) {\n    printf(&quot;Utenti della biblioteca:\\n&quot;);\n    for(int i = 0; i &lt; numeroUtenti; i++) {\n        printf(&quot;%d: %s %s\\n&quot;, i+1, utenti[i].nome, utenti[i].cognome);\n    }\n}\nFile: main.c\n#include &lt;stdio.h&gt;\n#include &quot;gestione_libri.h&quot;\n#include &quot;gestione_utenti.h&quot;\n \nint main() {\n    Libro libri[10];\n    Utente utenti[10];\n    int numeroLibri = 0, numeroUtenti = 0;\n \n    aggiungiLibro(libri, &amp;numeroLibri, &quot;Il Signore degli Anelli&quot;, &quot;J.R.R. Tolkien&quot;);\n    aggiungiUtente(utenti, &amp;numeroUtenti, &quot;Mario&quot;, &quot;Rossi&quot;);\n \n    visualizzaLibri(libri, numeroLibri);\n   \n \n visualizzaUtenti(utenti, numeroUtenti);\n \n    return 0;\n}\nCon questi passaggi, abbiamo suddiviso il codice iniziale in moduli logici e creato una struttura di progetto organizzata. Ogni file ha un ruolo specifico, e i file header servono per dichiarare le strutture e le funzioni che possono essere utilizzate da altri moduli. Questo rende il progetto più facile da gestire, espandere e mantenere.\nPerfetto, ora che abbiamo una struttura di progetto ben organizzata e abbiamo suddiviso il codice in moduli logici con i relativi file header, possiamo passare alla Parte 4: Makefile e Automazione della Compilazione.\nL’obiettivo di questa parte è creare un Makefile che automatizzi il processo di compilazione del nostro progetto, rendendolo più efficiente e riducendo la possibilità di errori. Un Makefile specifica come costruire il programma, definendo i target (i file da generare), le dipendenze (i file sorgente necessari per generare un target) e le regole (i comandi per generare i target dalle dipendenze).\nParte 4: Scrittura di un Makefile Semplice\nCreeremo un Makefile per il nostro sistema di gestione della biblioteca. Il Makefile avrà target per compilare il programma, per pulire i file oggetto e l’eseguibile, e per eseguire eventuali test.\nContenuto del Makefile\n# Variabili\nCC=gcc\nCFLAGS=-Iinclude\n \n# Nome dell&#039;eseguibile\nTARGET=gestione_biblioteca\n \n# File sorgente e oggetto\nSRCS=$(wildcard src/*.c)\nOBJS=$(SRCS:src/%.c=%.o)\n \n# Regola principale: compila il programma\n$(TARGET): $(OBJS)\n\t$(CC) -o $@ $^\n \n# Compilazione dei file oggetto da sorgente\n%.o: src/%.c\n\t$(CC) $(CFLAGS) -c $&lt;\n \n# Pulizia dei file di build\nclean:\n\trm -f $(OBJS) $(TARGET)\n \n# PHONY specifica che i seguenti non sono nomi di file\n.PHONY: clean\nSpiegazione\n\nCC specifica il compilatore da usare, in questo caso gcc.\nCFLAGS contiene le opzioni del compilatore, -Iinclude indica di cercare i file header nella directory include.\nTARGET è il nome dell’eseguibile da generare.\nSRCS trova automaticamente tutti i file sorgente nella directory src.\nOBJS genera i nomi dei file oggetto corrispondenti ai file sorgente.\nLa regola $(TARGET) specifica come generare l’eseguibile dai file oggetto. $@ rappresenta il nome del target, mentre $^ rappresenta tutte le dipendenze (i file oggetto).\nLa regola %o: src/%.c specifica come generare un file oggetto da un file sorgente. $&lt; rappresenta la prima dipendenza della regola, in questo caso il file sorgente corrispondente.\nclean è una regola per rimuovere i file generati dalla compilazione, inclusi i file oggetto e l’eseguibile.\n.PHONY indica che clean non è un file, ma un nome di una regola.\n\nUso del Makefile\nPer compilare il progetto, naviga nella directory radice del progetto e digita make. Questo genera l’eseguibile gestione_biblioteca (o il nome che hai scelto).\nPer rimuovere i file oggetto e l’eseguibile, pulendo la directory del progetto, usa make clean.\nQuesto Makefile è un esempio semplice ma potente che puoi estendere per includere regole per i test automatici o per gestire più directory sorgente e include.\nSe hai bisogno di ulteriori dettagli su come funzionano le regole del Makefile o desideri procedere con un’altra parte dell’esercizio, fammi sapere!\nCapito, procederò utilizzando i termini originali in inglese dove appropriato. Concentriamoci sull’uso delle preprocessor directives nel nostro progetto di gestione della biblioteca.\nParte 5: Preprocessor Directives in C\nLe preprocessor directives sono potenti strumenti che permettono di influenzare la fase di pre-elaborazione del codice sorgente prima della sua compilazione effettiva. Di seguito esploreremo come utilizzarle efficacemente nel contesto del nostro progetto.\n1. Uso di #define per Definire Costanti\nIniziamo con l’utilizzo della direttiva #define per definire costanti che possono essere usate in tutto il nostro progetto.\nNel file gestione_libri.h, possiamo definire una costante per la dimensione massima degli array di libri:\n#ifndef GESTIONE_LIBRI_H\n#define GESTIONE_LIBRI_H\n \n#define MAX_LIBRI 50\n \ntypedef struct {\n    char titolo[50];\n    char autore[50];\n} Libro;\n \nvoid aggiungiLibro(Libro *libri, int *numeroLibri, char *titolo, char *autore);\nvoid visualizzaLibri(Libro *libri, int numeroLibri);\n \n#endif // GESTIONE_LIBRI_H\nE analogamente nel file gestione_utenti.h per gli utenti:\n#ifndef GESTIONE_UTENTI_H\n#define GESTIONE_UTENTI_H\n \n#define MAX_UTENTI 50\n \ntypedef struct {\n    char nome[50];\n    char cognome[50];\n} Utente;\n \nvoid aggiungiUtente(Utente *utenti, int *numeroUtenti, char *nome, char *cognome);\nvoid visualizzaUtenti(Utente *utenti, int numeroUtenti);\n \n#endif // GESTIONE_UTENTI_H\n2. Inclusione Condizionale\nLa capacità di includere o escludere parti di codice a compilazione può essere molto utile, ad esempio, per abilitare il logging o il debugging solo in determinate build.\nPossiamo definire una macro DEBUG e usare #ifdef per controllare se includere il codice di debug nel nostro file sorgente:\n// In uno dei file .c, ad esempio main.c\n#include &lt;stdio.h&gt;\n#include &quot;gestione_libri.h&quot;\n#include &quot;gestione_utenti.h&quot;\n \n#define DEBUG\n \nint main() {\n    #ifdef DEBUG\n    printf(&quot;Modalità debug attiva\\n&quot;);\n    #endif\n \n    // Il resto del codice del main\n}\n3. Uso di Macro\nLe macro possono essere utilizzate non solo per definire costanti semplici, ma anche per creare “funzioni” macro, che possono eseguire operazioni semplici direttamente nel codice pre-elaborato.\nPer esempio, potremmo definire una macro per controllare se abbiamo raggiunto il limite di libri o utenti:\n#define CHECK_MAX_ITEMS(current, max) if ((current) &gt;= (max)) { \\\n                                       printf(&quot;Raggiunto il numero massimo di elementi\\n&quot;); \\\n                                       return; \\\n                                      }\nQuesta macro potrebbe essere usata nelle funzioni aggiungiLibro e aggiungiUtente per controllare se c’è spazio per aggiungere nuovi libri o utenti.\nConclusione\nQuesti esempi mostrano come utilizzare le preprocessor directives per definire costanti, includere condizionalmente parti di codice e creare macro utili. Le preprocessor directives aggiungono un livello di flessibilità al tuo codice, permettendoti di controllare la compilazione in modi che non sono possibili con il solo codice C standard."},"Argomenti/Fattorizzazione-del-codice-e-makefile/Struct":{"slug":"Argomenti/Fattorizzazione-del-codice-e-makefile/Struct","filePath":"Argomenti/Fattorizzazione del codice e makefile/Struct.md","title":"Struct","links":[],"tags":[],"content":"Le struct in C sono utilizzate per creare tipi di dati composti, permettendo di raggruppare variabili di tipi diversi sotto un’unica struttura. Questo è utile per rappresentare oggetti o entità complesse che richiedono più di un tipo di dato per essere descritte in modo accurato.\nPer illustrare ciò, useremo come esempio un punto in uno spazio bidimensionale, includendo tipi di dati diversi all’interno della struct. Supponiamo di voler rappresentare un punto che, oltre alle coordinate x e y, ha anche un colore rappresentato da una stringa.\nEcco un codice di esempio:\n#include &lt;stdio.h&gt;\n \n// Definizione della struct\nstruct Punto {\n    int x;      // Coordinata x come numero\n    int y;      // Coordinata y come numero\n    char colore[20]; // Colore del punto come stringa\n};\n \nint main() {\n    // Creazione di un&#039;istanza della struct Punto\n    struct Punto p1;\n \n    // Assegnazione dei valori\n    p1.x = 10.5;\n    p1.y = 20.3;\n    snprintf(p1.colore, sizeof(p1.colore), &quot;Blu&quot;);\n \n    // Stampa delle informazioni del punto\n    printf(&quot;Il punto ha coordinate: x = %.2f, y = %.2f e colore %s\\n&quot;, p1.x, p1.y, p1.colore);\n \n    return 0;\n}\nIn questo esempio, la struct Punto ora contiene due variabili di tipo int (x e y) e una variabile di tipo char array (colore). Questo permette di rappresentare un punto con più informazioni rispetto al solo posizionamento nello spazio. Nella funzione main, creiamo un’istanza di Punto, assegnamo valori alle sue proprietà, e poi stampiamo queste informazioni.\nQuesto esempio mostra come le struct in C possono essere utilizzate per raggruppare variabili di diversi tipi, fornendo una maggiore flessibilità nella rappresentazione di dati complessi."},"Argomenti/IP/Subnetting":{"slug":"Argomenti/IP/Subnetting","filePath":"Argomenti/IP/Subnetting.md","title":"Subnetting","links":[],"tags":[],"content":"IPm AND SM:\n10010110.10101001.00000011.00001000\n11111111.11111111.11111111.00000000\n\n10010110.10101001.00000011.00000000\n\nIPd AND SM:\n10010110.10101001.00000101.00000010\n11111111.11111111.11111111.00000000\n\n10010110.10101001.00000101.00000000\n\n"},"Argomenti/OOP/Classi-astratte-e-interfacce-(Java)":{"slug":"Argomenti/OOP/Classi-astratte-e-interfacce-(Java)","filePath":"Argomenti/OOP/Classi astratte e interfacce (Java).md","title":"Classi astratte e interfacce (Java)","links":[],"tags":[],"content":"Abstract Classes and Methods in Java Explained in 7 Minutes\nClassi astratte\n\nSono classi che possono contenere sia metodi astratti sia metodi concreti.\nPossono avere campi (variabili di istanza) con stato e costruttori.\nSi estendono con extends e si può estendere una sola classe astratta.\nServono per definire un comportamento comune parziale e lasciare ai sottotipi la responsabilità di completarlo.\n\nEsempio\npublic abstract class Animal {\n    protected String name;\n    \n    public Animal(String name) {\n        this.name = name;\n    }\n    \n    public void sleep() {\n        System.out.println(name + &quot; is sleeping.&quot;);\n    }\n    \n    public abstract void makeSound();\n}\n \npublic class Dog extends Animal {\n    public Dog(String name) {\n        super(name);\n    }\n    \n    @Override\n    public void makeSound() {\n        System.out.println(&quot;Woof!&quot;);\n    }\n}\nIn questo esempio:\n\nAnimal definisce un comportamento comune (sleep()) e obbliga le sottoclassi a definire makeSound().\nDog e Cat sono animali specifici che implementano il proprio verso.\nTutti gli animali hanno un nome e fanno un verso, non può essere diversamente\n\nInterfacce\n\nContengono solo la firma dei metodi astratti (prima di Java 8) oppure anche metodi default e static (da Java 8).\nNon hanno costruttori né stato interno (salvo costanti public static final).\nSi implementano con implements e si possono implementare più interfacce.\nServono a definire un contratto di comportamento che più classi possono condividere anche se non hanno relazione gerarchica.\n\nEsempio di interfaccia\npublic interface Flyable {\n    void fly();\n}\n \npublic class Bird implements Flyable {\n    @Override\n    public void fly() {\n        System.out.println(&quot;The bird is flying.&quot;);\n    }\n}\n \npublic interface Swimmable {\n    void swim();\n}\n \npublic class Duck implements Flyable, Swimmable {\n    @Override\n    public void fly() {\n        System.out.println(&quot;Duck flies.&quot;);\n    }\n    @Override\n    public void swim() {\n        System.out.println(&quot;Duck swims.&quot;);\n    }\n}\nIn questo esempio:\n\nFlyable definisce il contratto per gli animali che possono volare.\nSwimmable definisce il contratto per gli animali che possono nuotare.\nDuck implementa entrambi i comportamenti, poiché sa sia nuotare che volare.\nPenguin implementa solo la capacità di nuotare.\n\nQuando usare l’uno piuttosto che l’altro\nUsa una classe astratta se:\n\nVuoi fornire un’implementazione parziale comune a più classi correlate.\nC’è una gerarchia naturale (es. Animale → Cane, Gatto).\nHai bisogno di stato condiviso o di costruttori comuni.\nUsa un’interfaccia se:\nVuoi definire solo un insieme di comportamenti senza imporre implementazioni comuni.\nTi serve che classi diverse possano condividere un contratto.\nDevi usare ereditarietà multipla dei comportamenti.\nPer riassumere:\nClasse astratta: ereditarietà singola + stato + metodi concreti e astratti.\nInterfaccia: ereditarietà multipla + solo contratto + da Java 8 anche default methods.\n"},"Argomenti/OOP/Generics":{"slug":"Argomenti/OOP/Generics","filePath":"Argomenti/OOP/Generics.md","title":"Generics","links":[],"tags":[],"content":"www.w3schools.com/java/java_generics.asp\nJava Generics\nGenerics permettono di scrivere classi, interfacce e metodi parametrizzati con tipi, rendendo il codice più riutilizzabile, sicuro e leggibile.\nPerché usare i generics\n\nRiutilizzo del codice: una sola definizione per tipi diversi\nSicurezza di tipo: gli errori vengono rilevati a compile-time\nCodice più pulito: non serve il cast in lettura\n\nClasse generica\nclass Box&lt;T&gt; {\n  private T value;\n  void set(T value) {\n    this.value = value;\n  }\n  T get() {\n    return value;\n  }\n}\npublic class Main {\n  public static void main(String[] args) {\n    Box&lt;String&gt; stringBox = new Box&lt;&gt;();\n    stringBox.set(&quot;Hello&quot;);\n    System.out.println(&quot;Value: &quot; + stringBox.get());\n    Box&lt;Integer&gt; intBox = new Box&lt;&gt;();\n    intBox.set(50);\n    System.out.println(&quot;Value: &quot; + intBox.get());\n  }\n}\nQuando scrivi Box&lt;String&gt; o Box&lt;Integer&gt;, il compilatore sostituisce T con il tipo specificato, garantendo che il contenuto della box sia coerente con il tipo scelto.\nMetodo generico\npublic class Main {\n  public static &lt;T&gt; void printArray(T[] array) {\n    for (T item : array) {\n      System.out.println(item);\n    }\n  }\n  public static void main(String[] args) {\n    String[] names = {&quot;Jenny&quot;, &quot;Liam&quot;};\n    Integer[] numbers = {1, 2, 3};\n    printArray(names);\n    printArray(numbers);\n  }\n}\nIl metodo printArray funziona con qualsiasi tipo di array, e Java deduce automaticamente il tipo di T in base all’argomento passato.\nTipi limitati (bounded types)\nPuoi usare extends per limitare il tipo generico:\nclass Stats&lt;T extends Number&gt; {\n  T[] nums;\n  Stats(T[] nums) {\n    this.nums = nums;\n  }\n  double average() {\n    double sum = 0;\n    for (T num : nums) {\n      sum += num.doubleValue();\n    }\n    return sum / nums.length;\n  }\n}\npublic class Main {\n  public static void main(String[] args) {\n    Stats&lt;Integer&gt; intStats = new Stats&lt;&gt;(new Integer[]{10, 20, 30});\n    System.out.println(&quot;Integer average: &quot; + intStats.average());\n    Stats&lt;Double&gt; doubleStats = new Stats&lt;&gt;(new Double[]{1.5, 2.5, 3.5});\n    System.out.println(&quot;Double average: &quot; + doubleStats.average());\n  }\n}\nQui, T può essere solo un sottotipo di Number, e il metodo doubleValue() consente di trattare ogni numero come un double.\nGenerics nelle collezioni\nArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(&quot;Apple&quot;);\nString fruit = list.get(0); // Nessun cast necessario\nRiepilogo\n\nI generics permettono codice flessibile e sicuro\nPossono essere usati con classi, metodi e interfacce\nPuoi limitare i tipi ammessi con extends\nSono ampiamente usati nelle Collections di Java\n"},"Argomenti/OOP/Maps":{"slug":"Argomenti/OOP/Maps","filePath":"Argomenti/OOP/Maps.md","title":"Maps","links":[],"tags":[],"content":"Map and HashMap in Java - Full Tutorial\nChe cos’è una Map in Java?\nIn Java, una Map è una struttura dati che associa una chiave (key) a un valore (value).\n\nOgni chiave è unica (non puoi avere due chiavi uguali).\nOgni chiave può avere associato un solo valore.\nÈ molto utile per cercare velocemente un valore conoscendo la sua chiave.\nL’interfaccia principale è java.util.Map, e le implementazioni più usate sono:\nHashMap – Non mantiene l’ordine degli elementi.\nLinkedHashMap – Mantiene l’ordine di inserimento.\nTreeMap – Ordina le chiavi in modo naturale (o con un comparatore).\n\nMetodi fondamentali di HashMap&lt;K, V&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMetodoDescrizioneV put(K key, V value)Inserisce o aggiorna l’associazione chiave → valore. Restituisce il valore precedente (o null se non c’era).V get(Object key)Restituisce il valore associato alla chiave, oppure null se la chiave non esiste.V remove(Object key)Rimuove l’entry associata alla chiave. Restituisce il valore rimosso o null se non c’era.boolean containsKey(Object key)Ritorna true se la mappa contiene la chiave indicata.boolean containsValue(Object value)Ritorna true se la mappa contiene almeno una chiave associata a quel valore.int size()Numero di coppie chiave-valore presenti.boolean isEmpty()Ritorna true se la mappa è vuota.void clear()Rimuove tutte le coppie.Set&lt;K&gt; keySet()Ritorna un Set con tutte le chiavi presenti nella mappa.Collection&lt;V&gt; values()Ritorna una collezione con tutti i valori.Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()Ritorna un set di entry (coppie chiave-valore) che puoi iterare.V putIfAbsent(K key, V value)Inserisce la coppia solo se la chiave non è già presente.V replace(K key, V value)Sostituisce il valore associato alla chiave solo se la chiave è presente.boolean replace(K key, V oldValue, V newValue)Sostituisce il valore solo se la chiave è presente e mappata al valore vecchio.\nEsempio: inventario prodotti\nImmagina di avere un piccolo sistema di gestione di un inventario dove ogni prodotto ha un codice univoco (ad esempio il codice a barre o un SKU) e un oggetto Product che contiene i dettagli del prodotto.\nIn questo caso, la Map associa codice prodotto → prodotto.\nEcco un esempio:\nimport java.util.HashMap;\nimport java.util.Map;\n \n// Classe che rappresenta un prodotto\nclass Product {\n    private String name;\n    private double price;\n    private int quantity;\n \n    public Product(String name, double price, int quantity) {\n        this.name = name;\n        this.price = price;\n        this.quantity = quantity;\n    }\n \n    public String getName() {\n        return name;\n    }\n \n    public double getPrice() {\n        return price;\n    }\n \n    public int getQuantity() {\n        return quantity;\n    }\n \n    @Override\n    public String toString() {\n        return name + &quot; - Prezzo: &quot; + price + &quot;€ - Quantità: &quot; + quantity;\n    }\n}\n \npublic class InventoryExample {\n    public static void main(String[] args) {\n        // Mappa: codice prodotto -&gt; oggetto Product\n        Map&lt;String, Product&gt; inventory = new HashMap&lt;&gt;();\n \n        // Inseriamo dei prodotti\n        inventory.put(&quot;A123&quot;, new Product(&quot;Mouse Wireless&quot;, 19.99, 50));\n        inventory.put(&quot;B456&quot;, new Product(&quot;Tastiera Meccanica&quot;, 79.90, 20));\n        inventory.put(&quot;C789&quot;, new Product(&quot;Monitor 24 pollici&quot;, 149.00, 15));\n \n        // Recuperiamo un prodotto conoscendo il codice\n        Product p = inventory.get(&quot;B456&quot;);\n        if (p != null) {\n            System.out.println(&quot;Prodotto trovato: &quot; + p);\n        }\n \n        // Controlliamo se un codice è presente\n        if (inventory.containsKey(&quot;C789&quot;)) {\n            System.out.println(&quot;Il prodotto C789 è disponibile.&quot;);\n        }\n \n        // Iteriamo su tutti i prodotti\n        System.out.println(&quot;\\nInventario completo:&quot;);\n        for (Map.Entry&lt;String, Product&gt; entry : inventory.entrySet()) {\n            String code = entry.getKey();\n            Product prod = entry.getValue();\n            System.out.println(code + &quot; =&gt; &quot; + prod);\n        }\n \n        // Rimuoviamo un prodotto esaurito\n        inventory.remove(&quot;A123&quot;);\n        System.out.println(&quot;\\nInventario dopo la rimozione:&quot;);\n        for (Map.Entry&lt;String, Product&gt; entry : inventory.entrySet()) {\n            System.out.println(entry.getKey() + &quot; =&gt; &quot; + entry.getValue());\n        }\n    }\n}\n\nLa chiave (String) è un identificativo univoco di prodotto.\nIl valore è un oggetto che contiene più informazioni.\nÈ un uso tipico delle Map: lookup rapido di un’entità a partire dal suo identificativo.\n\n📝 Esercizio – Gestione di un catalogo di libri con HashMap\n🎯 Obiettivo\nImparare a:\n\nDichiarare e usare una HashMap\nInserire, cercare e rimuovere elementi\nIterare su chiavi e valori\n\n\n📚 Descrizione consegna\nScrivi un programma Java che gestisca un catalogo di libri. Ogni libro è identificato da un codice ISBN (String) univoco. Ogni ISBN è associato al titolo del libro.\nIl programma deve:\n\nCreare una HashMap&lt;String, String&gt; dove:\n\nchiave: ISBN del libro\nvalore: titolo del libro\n\n\nInserire almeno 5 libri nella mappa.\nStampare il contenuto del catalogo (tutte le coppie ISBN → Titolo).\nChiedere all’utente di inserire un ISBN da tastiera e:\n\nSe l’ISBN esiste, stampare il titolo corrispondente.\nSe non esiste, stampare un messaggio di errore.\n\n\nRimuovere un libro dato il suo ISBN.\nStampare di nuovo l’elenco aggiornato dei libri.\n"},"Argomenti/OOP/Sets":{"slug":"Argomenti/OOP/Sets","filePath":"Argomenti/OOP/Sets.md","title":"Sets","links":[],"tags":[],"content":"Set and HashSet in Java - Full Tutorial\nSet\n\nÈ un’interfaccia che rappresenta una collezione di elementi unici (cioè nessun duplicato).\nNon garantisce un ordine specifico degli elementi (a meno che tu non usi implementazioni particolari, come TreeSet o LinkedHashSet).\nMetodi principali:\n\nadd(element): aggiunge un elemento (ritorna true se l’elemento non era presente).\nremove(element): rimuove un elemento.\ncontains(element): verifica se l’elemento è presente.\ncontainsAll(collection): verifica se sono presenti tutti gli elementi della collection.\nsize(): numero di elementi.\n\n\nEsempio di dichiarazione:\nSet&lt;String&gt; mySet = new HashSet&lt;&gt;();\n\n\n\nHashSet\n\nÈ un’implementazione concreta di Set.\nUtilizza una tabella hash per memorizzare gli elementi.\nCaratteristiche principali:\n\nNessun ordine garantito degli elementi.\nOperazioni di inserimento, rimozione e ricerca molto veloci (tempo medio O(1)).\nNon accetta duplicati.\n\n\nEsempio:\nHashSet&lt;Integer&gt; numbers = new HashSet&lt;&gt;();\nnumbers.add(10);\nnumbers.add(20);\nnumbers.add(10); // Ignorato, perché 10 è già presente\nDopo queste istruzioni, numbers conterrà solo 10 e 20.\n\n\nAltre implementazioni di Set\nOltre a HashSet, ci sono altre implementazioni che ti offrono comportamenti diversi:\n\nLinkedHashSet\n\nMantiene l’ordine di inserimento.\n\n\nTreeSet\n\nOrdina gli elementi in modo naturale (es. crescente) o con un Comparator personalizzato.\nBasato su una struttura ad albero rosso-nero.\n\n\n\n\nQuando usare HashSet?\nUsa HashSet quando:\n\nNon ti importa l’ordine.\nVuoi prestazioni ottimali su ricerca e inserimento.\nTi serve solo assicurarti che non ci siano duplicati.\n"},"Argomenti/Presentazioni/Linee-guida-presentazioni":{"slug":"Argomenti/Presentazioni/Linee-guida-presentazioni","filePath":"Argomenti/Presentazioni/Linee guida presentazioni.md","title":"Linee guida presentazioni","links":[],"tags":[],"content":"🎯 Obiettivi\n\nNon è una normale interrogazione: Imparare l’argomento a memoria copiando cose a caso da internet non ti servirà assolutamente a nulla e inciderà negativamente sul tuo voto. Devi rendere l’argomento tuo ed esporlo ad una platea, catturando la loro curiosità e attenzione. È questa la competenza che verrà valutata.\nPresentazioni e documenti sono due cose diverse: Fermo restando che nessuno ti vieta di scrivere un argomento a parte per approfondire la tua ricerca, la presentazione serve ad esporre un argomento a farlo leggere, o ancora peggio, a leggerlo davanti ad una platea. È e deve essere un supporto per la tua esposizione.\n\n🔍 Fase di Ricerca: Diventa un Esperto!\n\n\nScegli un Argomento Stimolante: Trova qualcosa che ti incuriosisca o che sia rilevante per i tuoi interessi. È sempre meglio scegliere un argomento che ti appassiona piuttosto che un argomento facile o banale, poiché automaticamente l’argomento sarà più interessante per te e per la platea.\n\n\nRicerca Approfondita:\n\nUtilizza fonti affidabili come libri, articoli accademici, e siti web autorevoli. Google Scholar è un ottimo punto di partenza.\nNon basta copiare e incollare cose a caso da internet o utilizzare esclusivamente e alla cieca l’intelligenza artificiale generativa. Se lo fai si vedrà in modo palese, e la tua presentazione risulterà scarsa, noiosa e inaccurata.\nVerifica l’affidabilità delle informazioni controllando l’autore e la data di pubblicazione.\nOrganizza i tuoi appunti per argomenti o idee chiave.\n\n\n\nAnalisi e Riflessione:\n\nCerca di capire come le informazioni si collegano tra loro e al tuo argomento.\nSviluppa una prospettiva o un’opinione personale basata sulle tue ricerche.\n\n\n\n📝 Fase di Preparazione della Presentazione\n\n\nStruttura la Tua Presentazione:\n\nIntroduzione: Presenta l’argomento e ciò che ti ha spinto a sceglierlo.\nCorpo Principale: Usa diverse slide per esplorare aspetti diversi del tuo argomento. Ogni slide dovrebbe presentare un’idea chiara. Puoi anche dividere la presentazione in più sezioni, se lo ritieni necessario.\nConclusione: Riepiloga i punti chiave e fornisci la tua visione personale o conclusioni.\n\n\n\nProgettazione:\n\nScegli un tema semplice ma elegante.\nOgni modifica del tema deve essere fatta nell’editor del tema, in modo che sia coerente in tutta la presentazione (eccetto rare slide uniche e particolari). Per cui tutte le modifiche che vanno a fatte a tutto il tema (nuovi layout, sfondi, loghi, formattazione di testo e titoli) vanno fatte sull’editor di tema e non sulle singole slide.\nUsa font chiari e di dimensioni e colori ben leggibili.\nIncludi immagini o grafici pertinenti per rendere la presentazione più vivace e interessante.\nNon abusare di transizioni e animazioni, vanno usate con parsimonia. Se usate al momento giusto possono risultare molto efficaci a livello di coinvolgimento. Se usate a caso possono ridurre di molto la qualità della presentazione.\n\n\n\nContenuto Visivo:\n\nUsa punti elenco per le idee principali.\nNon sovraccaricare le slide di testo. Metti frasi brevi che ti servano a supportare la tua esposizione, che deve essere la fonte principale di informazione. Tuttavia attenzione a non togliere troppo contenuto, altrimenti rischi di far perdere il segno alla platea.\nAssicurati che le immagini siano di buona qualità e rilevanti.\n\n\n\n🗣️ Fase di Presentazione\n\n\nFai pratica:\n\nEsercitati a parlare in modo chiaro e sicuro.\nAssicurati di stare nei tempi previsti cronometrandoti.\n\n\n\nDurante la Presentazione:\n\nMantieni il contatto visivo con il pubblico.\nUsa le slide come supporto, ma cerca di non leggere direttamente da esse.\nIl modo in cui comunichi è importantissimo, utilizza tono di voce, gesti, pause in modo coinvolgente.\n\n\n\nGestione delle Domande:\n\nPrepara alcune risposte per le possibili domande.\nSii aperto e disponibile a rispondere.\n\n\n\nFonti:\n\nIncludi le fonti della tua ricerca in fondo alla presentazione\n\n\n\n💭 Dopo la Presentazione\n\nRifletti su cosa ha funzionato e cosa potresti migliorare.\nConsidera il feedback per crescere nelle tue abilità di presentazione.\n\n⚖️ Criteri di Valutazione\n\nQualità della Ricerca: Profondità, livello di conoscenza, accuratezza e originalità.\nDesign della Presentazione: Creatività, utilizzo corretto delle animazioni, coerenza del tema e chiarezza visiva.\nCapacità di oratoria: Fluidità, chiarezza e capacità di coinvolgere il pubblico.\nInterazione e Risposte alle Domande: Efficienza nella gestione delle domande e nella comunicazione con il pubblico.\n"},"Argomenti/Programmazione-Concorrente/Esercizi":{"slug":"Argomenti/Programmazione-Concorrente/Esercizi","filePath":"Argomenti/Programmazione Concorrente/Esercizi.md","title":"Esercizi","links":[],"tags":[],"content":"Esercizio 1: Simulazione del Traffico\nObiettivo: Simulare un incrocio stradale con semafori.\n\nDescrizione: Crea una simulazione di un incrocio stradale dove le auto provengono da quattro direzioni (Nord, Sud, Est, Ovest). Ogni direzione ha un semaforo che può essere verde o rosso. Usa thread per rappresentare le auto e semafori per controllare l’accesso all’incrocio.\nSuggerimento: Implementa un semaforo verde per una direzione alla volta, consentendo il passaggio di un numero limitato di auto prima di cambiare il semaforo.\n\nEsercizio 2: Corsa tra Corridori\nObiettivo: Simulare una corsa tra più corridori con tappe intermedie.\n\nDescrizione: Scrivi un programma che simuli una corsa tra più thread, ciascuno rappresentante un corridore. Ogni corridore deve raggiungere tappe intermedie in un ordine specifico. Usa barriere per sincronizzare i thread a ogni tappa.\nSuggerimento: Usa pthread_barrier_t per assicurarti che tutti i corridori raggiungano una tappa prima di procedere alla successiva.\n\nEsercizio 3: Gestione di un Ristorante\nObiettivo: Simulare la gestione di un ristorante con cuochi e camerieri.\n\nDescrizione: Crea un programma che simuli un ristorante con thread rappresentanti i cuochi e i camerieri. I cuochi preparano i piatti e li mettono su un bancone (buffer circolare). I camerieri prendono i piatti dal bancone e li servono ai clienti.\nSuggerimento: Usa semafori per contare i piatti disponibili sul bancone e mutex per proteggere l’accesso al buffer circolare.\n\nEsercizio 4: Simulazione di un Sistema di File\nObiettivo: Simulare l’accesso concorrente a un sistema di file con lettori e scrittori.\n\nDescrizione: Implementa un sistema di file dove thread rappresentanti i processi possono leggere e scrivere file. Assicurati che più processi possano leggere contemporaneamente, ma solo uno possa scrivere alla volta.\nSuggerimento: Usa mutex e semafori per gestire l’accesso concorrente, implementando un meccanismo di priorità per gli scrittori se necessario.\n\nEsercizio 5: Simulazione di una Catena di Montaggio\nObiettivo: Simulare una catena di montaggio con più fasi di produzione.\n\nDescrizione: Crea un programma che simuli una catena di montaggio con più stazioni. Ogni stazione rappresenta una fase del processo di produzione e ogni thread rappresenta un prodotto che passa attraverso le stazioni in ordine.\nSuggerimento: Usa mutex e condition variables per sincronizzare i thread tra le diverse stazioni della catena di montaggio.\n\nEsercizio 6: Gestione di un Aeroporto\nObiettivo: Simulare la gestione delle piste di atterraggio e decollo di un aeroporto.\n\nDescrizione: Scrivi un programma che simuli un aeroporto con più piste di atterraggio e decollo. Ogni aereo (thread) deve richiedere il permesso per atterrare o decollare. Usa semafori e mutex per gestire l’accesso alle piste.\nSuggerimento: Implementa una logica per gestire le priorità tra atterraggi e decolli, evitando deadlock e garantendo un flusso regolare di traffico aereo.\n\nEsercizio 7: Simulazione di un Sistema Bancario\nObiettivo: Simulare le transazioni bancarie concorrenti tra conti correnti.\n\nDescrizione: Crea un programma che simuli un sistema bancario con più conti correnti. I thread rappresentano le transazioni (depositi e prelievi) che devono essere eseguite in modo sicuro per evitare condizioni di gara.\nSuggerimento: Usa mutex per proteggere l’accesso ai conti correnti e implementa un sistema di log per registrare tutte le transazioni.\n\nQuesti esercizi ti offriranno una varietà di scenari per applicare la programmazione concorrente in C e migliorare le tue abilità di gestione delle risorse condivise e sincronizzazione dei thread. Buona programmazione! Se hai domande o hai bisogno di ulteriori dettagli su uno specifico esercizio, sono qui per aiutarti."},"Argomenti/Programmazione-Concorrente/Teoria-con-esempi":{"slug":"Argomenti/Programmazione-Concorrente/Teoria-con-esempi","filePath":"Argomenti/Programmazione Concorrente/Teoria con esempi.md","title":"Teoria con esempi","links":[],"tags":[],"content":"La programmazione concorrente in C ti permette di eseguire più operazioni contemporaneamente, utilizzando thread, che sono come “mini-processi” (processi leggeri) all’interno di un programma. La libreria pthread è comunemente usata per gestire i thread in C. Ecco una spiegazione semplice e un esempio pratico.\nMultithreading classico\nPassaggi base:\n\n\nIncludere la libreria pthread:\n#include &lt;pthread.h&gt;\n\n\nDefinire la funzione che verrà eseguita dai thread:\nLa funzione deve avere un prototipo specifico:\nvoid *myThreadFunction(void *arg);\n\n\nCreare e avviare i thread:\nUtilizza pthread_create per creare e avviare un thread:\npthread_t thread_id;\npthread_create(&amp;thread_id, NULL, myThreadFunction, (void *)arg);\n\n\nAttendere che i thread terminino:\nUtilizza pthread_join per attendere che un thread finisca:\npthread_join(thread_id, NULL);\n\n\nEsempio pratico:\nQuesto esempio crea due thread che stampano un messaggio.\n#include &lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n \n// Funzione che verrà eseguita dai thread\nvoid *printMessage(void *arg) {\n    char *message = (char *)arg;\n    printf(&quot;%s\\n&quot;, message);\n    return NULL;\n}\n \nint main() {\n    pthread_t thread1, thread2;\n \n    // Messaggi da passare ai thread\n    char *message1 = &quot;Hello from Thread 1&quot;;\n    char *message2 = &quot;Hello from Thread 2&quot;;\n \n    // Creare i thread\n    pthread_create(&amp;thread1, NULL, printMessage, (void *)message1);\n    pthread_create(&amp;thread2, NULL, printMessage, (void *)message2);\n \n    // Attendere la terminazione dei thread\n    pthread_join(thread1, NULL);\n    pthread_join(thread2, NULL);\n \n    return 0;\n}\nSpiegazione:\n\n\nInclusione della libreria:\n#include &lt;pthread.h&gt;\n\n\nDefinizione della funzione:\nvoid *printMessage(void *arg) {\n    char *message = (char *)arg;\n    printf(&quot;%s\\n&quot;, message);\n    return NULL;\n}\nQuesta funzione prende un argomento, lo converte in una stringa e lo stampa.\n\n\nCreazione dei thread:\npthread_create(&amp;thread1, NULL, printMessage, (void *)message1);\npthread_create(&amp;thread2, NULL, printMessage, (void *)message2);\nQui vengono creati due thread, ciascuno con un messaggio diverso.\n\n\nAttendere la terminazione dei thread:\npthread_join(thread1, NULL);\npthread_join(thread2, NULL);\nQuesta parte del codice assicura che il programma principale attenda la fine dei thread prima di terminare.\n\n\nQuesto è un esempio molto semplice per iniziare con la programmazione concorrente in C. Man mano che avanzi, potresti voler esplorare argomenti più complessi come la sincronizzazione dei thread, i mutex, le variabili condizionali e altro ancora.\nOttimo, continuiamo ad esplorare la programmazione concorrente in C, approfondendo concetti come la sincronizzazione dei thread utilizzando mutex (mutual exclusion) e variabili condizionali.\nSincronizzazione dei Thread con Mutex\nUn mutex è un meccanismo che assicura che solo un thread alla volta possa accedere a una risorsa condivisa. Vediamo un esempio in cui due thread incrementano una variabile condivisa.\nPassaggi:\n\n\nDichiarare e inizializzare un mutex:\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n\n\nBloccare e sbloccare il mutex all’interno della funzione del thread:\npthread_mutex_lock(&amp;mutex);\n// sezione critica\npthread_mutex_unlock(&amp;mutex);\n\n\nEsempio Pratico con Mutex\nQuesto esempio mostra come due thread incrementano una variabile condivisa proteggendo l’accesso con un mutex.\n#include &lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n \nint counter = 0; // Variabile condivisa\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; // Dichiarazione e inizializzazione del mutex\n \nvoid *incrementCounter(void *arg) {\n    for(int i = 0; i &lt; 100000; i++) {\n        pthread_mutex_lock(&amp;mutex); // Blocca il mutex\n        counter++; // Sezione critica\n        pthread_mutex_unlock(&amp;mutex); // Sblocca il mutex\n    }\n    return NULL;\n}\n \nint main() {\n    pthread_t thread1, thread2;\n \n    // Creare i thread\n    pthread_create(&amp;thread1, NULL, incrementCounter, NULL);\n    pthread_create(&amp;thread2, NULL, incrementCounter, NULL);\n \n    // Attendere la terminazione dei thread\n    pthread_join(thread1, NULL);\n    pthread_join(thread2, NULL);\n \n    printf(&quot;Final counter value: %d\\n&quot;, counter);\n    return 0;\n}\nSpieghiamo in dettaglio perché è necessario proteggere la sezione critica con un mutex.\nSezione Critica\nUna sezione critica è una parte del codice che accede a una risorsa condivisa che non deve essere modificata simultaneamente da più thread. Nel nostro caso, la risorsa condivisa è la variabile counter.\nProblema di Concorrenza\nQuando più thread accedono e modificano una variabile condivisa senza una corretta sincronizzazione, si possono verificare problemi di concorrenza. Vediamo cosa può succedere senza l’uso di un mutex.\nEsempio senza Mutex\nConsideriamo due thread che incrementano la variabile counter:\n\nThread 1 legge il valore corrente di counter (supponiamo che sia 0).\nThread 2 legge il valore corrente di counter (ancora 0).\nThread 1 incrementa counter a 1 e scrive il valore.\nThread 2 incrementa counter a 1 (ma il valore corretto dovrebbe essere 2).\n\nIn questo scenario, anche se due incrementi sono stati eseguiti, il valore finale di counter è solo 1, non 2. Questo comportamento è noto come race condition.\nUso del Mutex per Proteggere la Sezione Critica\nPer evitare le race condition, si utilizza un mutex. Un mutex (mutual exclusion) garantisce che solo un thread alla volta possa eseguire la sezione critica.\nFunzionamento del Mutex\n\n\nBloccare il Mutex:\npthread_mutex_lock(&amp;mutex);\n\nPrima di accedere alla variabile condivisa counter, un thread deve bloccare il mutex. Se un altro thread ha già bloccato il mutex, il thread corrente attende fino a quando il mutex non viene sbloccato.\n\n\n\nSezione Critica:\ncounter++;\n\nLa sezione critica è il codice che accede alla variabile condivisa. In questo caso, incrementa counter.\n\n\n\nSbloccare il Mutex:\npthread_mutex_unlock(&amp;mutex);\n\nDopo aver completato l’operazione sulla variabile condivisa, il thread sblocca il mutex, permettendo ad altri thread di accedere alla sezione critica.\n\n\n\nVantaggi dell’Uso del Mutex\n\nSicurezza dei Dati: Assicura che la variabile counter venga aggiornata correttamente da ogni thread.\nEvita Race Condition: Previene l’accesso simultaneo alla variabile condivisa, eliminando le race condition.\nIntegrità dei Dati: Mantiene l’integrità della variabile counter, garantendo che il valore finale sia corretto.\n\nVariabili Condizionali\nLe variabili condizionali sono usate per sincronizzare i thread basandosi su alcune condizioni. Un thread può aspettare che una condizione sia vera, e un altro thread può segnalare il cambiamento di quella condizione.\nPassaggi:\n\n\nDichiarare e inizializzare una variabile condizionale e un mutex:\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n\n\nUtilizzare pthread_cond_wait e pthread_cond_signal:\npthread_cond_wait(&amp;cond, &amp;mutex);\npthread_cond_signal(&amp;cond);\n\n\nEsempio Pratico con Variabili Condizionali\nQuesto esempio mostra come un produttore e un consumatore possono sincronizzarsi utilizzando una variabile condizionale.\n#include &lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n \nint buffer = 0;\nbool bufferFull = false;\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n \nvoid *producer(void *arg) {\n    for (int i = 1; i &lt;= 10; i++) {\n        pthread_mutex_lock(&amp;mutex);\n        while (bufferFull) {\n            pthread_cond_wait(&amp;cond, &amp;mutex);\n        }\n        buffer = i; // Produci un elemento\n        bufferFull = true;\n        printf(&quot;Produced: %d\\n&quot;, buffer);\n        pthread_cond_signal(&amp;cond);\n        pthread_mutex_unlock(&amp;mutex);\n    }\n    return NULL;\n}\n \nvoid *consumer(void *arg) {\n    for (int i = 1; i &lt;= 10; i++) {\n        pthread_mutex_lock(&amp;mutex);\n        while (!bufferFull) {\n            pthread_cond_wait(&amp;cond, &amp;mutex);\n        }\n        printf(&quot;Consumed: %d\\n&quot;, buffer); // Consuma un elemento\n        bufferFull = false;\n        pthread_cond_signal(&amp;cond);\n        pthread_mutex_unlock(&amp;mutex);\n    }\n    return NULL;\n}\n \nint main() {\n    pthread_t producerThread, consumerThread;\n \n    // Creare i thread\n    pthread_create(&amp;producerThread, NULL, producer, NULL);\n    pthread_create(&amp;consumerThread, NULL, consumer, NULL);\n \n    // Attendere la terminazione dei thread\n    pthread_join(producerThread, NULL);\n    pthread_join(consumerThread, NULL);\n \n    return 0;\n}\nSpiegazione\n\n\nInizializzazione:\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nDichiarazione e inizializzazione di mutex e variabile condizionale.\n\n\nFunzioni del produttore e del consumatore:\n\n\nProduttore:\nwhile (bufferFull) {\n    pthread_cond_wait(&amp;cond, &amp;mutex);\n}\nbuffer = i;\nbufferFull = true;\npthread_cond_signal(&amp;cond);\nIl produttore attende finché il buffer non è vuoto, poi produce un elemento e segnala al consumatore.\n\n\nConsumatore:\nwhile (!bufferFull) {\n    pthread_cond_wait(&amp;cond, &amp;mutex);\n}\nprintf(&quot;Consumed: %d\\n&quot;, buffer);\nbufferFull = false;\npthread_cond_signal(&amp;cond);\nIl consumatore attende finché il buffer non è pieno, poi consuma l’elemento e segnala al produttore.\n\n\n\n\nQuesti esempi illustrano i concetti fondamentali della programmazione concorrente in C usando pthread. Con la pratica, potrai gestire problemi più complessi e scenari di concorrenza avanzati.\nSemafori binari\nI semafori sono strumenti di sincronizzazione che possono essere utilizzati per controllare l’accesso a una risorsa condivisa. I semafori possono essere utilizzati per risolvere problemi di sincronizzazione come il problema dei produttori-consumatori, controllo del numero di risorse disponibili e altro ancora.\nPassaggi:\n\n\nIncludere la libreria semaphore.h:\n#include &lt;semaphore.h&gt;\n\n\nDichiarare e inizializzare un semaforo:\nsem_t sem;\nsem_init(&amp;sem, 0, 1); // 1 per semaforo binario, &gt;1 per semaforo contatore\n\n\nUsare il semaforo per sincronizzare l’accesso alle risorse:\nsem_wait(&amp;sem); // Blocca o decrementa il semaforo\n// sezione critica\nsem_post(&amp;sem); // Sblocca o incrementa il semaforo\n\n\nEsempio Pratico con Semaforo\nQuesto esempio mostra come due thread possono sincronizzarsi utilizzando un semaforo per evitare condizioni di gara (race condition).\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;stdio.h&gt;\n \nint counter = 0; // Variabile condivisa\nsem_t sem; // Dichiarazione del semaforo\n \nvoid *incrementCounter(void *arg) {\n    for(int i = 0; i &lt; 100000; i++) {\n        sem_wait(&amp;sem); // Blocca il semaforo\n        counter++; // Sezione critica\n        sem_post(&amp;sem); // Sblocca il semaforo\n    }\n    return NULL;\n}\n \nint main() {\n    pthread_t thread1, thread2;\n \n    // Inizializzare il semaforo\n    sem_init(&amp;sem, 0, 1); // 1 indica un semaforo binario\n \n    // Creare i thread\n    pthread_create(&amp;thread1, NULL, incrementCounter, NULL);\n    pthread_create(&amp;thread2, NULL, incrementCounter, NULL);\n \n    // Attendere la terminazione dei thread\n    pthread_join(thread1, NULL);\n    pthread_join(thread2, NULL);\n \n    printf(&quot;Final counter value: %d\\n&quot;, counter);\n \n    // Distruggere il semaforo\n    sem_destroy(&amp;sem);\n \n    return 0;\n}\nSemaforo di Dijkstra con Contatore Interno\nUn semaforo di conteggio può essere utilizzato per controllare l’accesso a una risorsa limitata, come un pool di connessioni o una serie di thread di lavoro. A differenza del semaforo binario, qui non ho una risorsa “occupata” o “libera”, ma ho un numero di risorse limitato maggiore di uno. Ogni richiesta di wait del semaforo decrementerà il numero di risorse disponibili e viceversa quando viene rilasciato.\nEsempio: Gestione di un Pool di Risorse\nIn questo esempio, gestiremo un pool di risorse limitate utilizzando un semaforo di conteggio. Avremo un certo numero di risorse disponibili e più thread che cercheranno di acquisire una risorsa, utilizzarla, e poi rilasciarla.\nCodice di Implementazione\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n \n#define NUM_RESOURCES 3\n#define NUM_THREADS 10\n \nsem_t semaphore;  // Semaforo di conteggio\n \nvoid *threadFunction(void *arg) {\n    int thread_id = *((int *)arg);\n \n    // Acquisire una risorsa\n    sem_wait(&amp;semaphore);\n    printf(&quot;Thread %d: Acquired a resource\\n&quot;, thread_id);\n \n    // Simulare l&#039;utilizzo della risorsa\n    sleep(rand() % 3 + 1);\n \n    // Rilasciare la risorsa\n    printf(&quot;Thread %d: Releasing the resource\\n&quot;, thread_id);\n    sem_post(&amp;semaphore);\n \n    return NULL;\n}\n \nint main() {\n    pthread_t threads[NUM_THREADS];\n    int thread_ids[NUM_THREADS];\n \n    // Inizializzare il semaforo con il numero di risorse disponibili\n    sem_init(&amp;semaphore, 0, NUM_RESOURCES);\n \n    // Creare i thread\n    for (int i = 0; i &lt; NUM_THREADS; i++) {\n        thread_ids[i] = i;\n        pthread_create(&amp;threads[i], NULL, threadFunction, &amp;thread_ids[i]);\n    }\n \n    // Attendere la terminazione dei thread\n    for (int i = 0; i &lt; NUM_THREADS; i++) {\n        pthread_join(threads[i], NULL);\n    }\n \n    // Distruggere il semaforo\n    sem_destroy(&amp;semaphore);\n \n    return 0;\n}\nSpiegazione\n\n\nInizializzazione del Semaforo:\nsem_init(&amp;semaphore, 0, NUM_RESOURCES);\nInizializza il semaforo con il numero di risorse disponibili. Il secondo parametro è 0, indicando che il semaforo è condiviso tra i thread del processo.\n\n\nAcquisizione della Risorsa:\nsem_wait(&amp;semaphore);\nQuando un thread chiama sem_wait, il semaforo viene decrementato. Se il valore del semaforo è maggiore di 0, il thread procede. Altrimenti, il thread viene bloccato finché il valore del semaforo non è maggiore di 0.\n\n\nUtilizzo della Risorsa:\nprintf(&quot;Thread %d: Acquired a resource\\n&quot;, thread_id);\nsleep(rand() % 3 + 1);\nIl thread simula l’utilizzo della risorsa dormendo per un intervallo di tempo casuale.\n\n\nRilascio della Risorsa:\nsem_post(&amp;semaphore);\nQuando un thread ha terminato di utilizzare la risorsa, chiama sem_post, che incrementa il valore del semaforo. Se ci sono thread in attesa, uno di essi viene sbloccato.\n\n\nCreazione e Unione dei Thread:\nfor (int i = 0; i &lt; NUM_THREADS; i++) {\n    thread_ids[i] = i;\n    pthread_create(&amp;threads[i], NULL, threadFunction, &amp;thread_ids[i]);\n}\nfor (int i = 0; i &lt; NUM_THREADS; i++) {\n    pthread_join(threads[i], NULL);\n}\nIl programma crea e unisce 10 thread, ciascuno dei quali cercherà di acquisire una risorsa dal semaforo.\n\n\nQuesto esempio mostra come utilizzare un semaforo di conteggio per gestire l’accesso concorrente a un pool limitato di risorse, garantendo che non più di un certo numero di thread possano utilizzare le risorse simultaneamente.\nBarriere\nLe barriere sono un meccanismo di sincronizzazione che forza un gruppo di thread a fermarsi a un certo punto (barriera) e aspettare fino a quando tutti i thread del gruppo hanno raggiunto quella barriera. Solo allora, tutti i thread possono continuare.\nPassaggi:\n\n\nIncludere la libreria pthread:\n#include &lt;pthread.h&gt;\n\n\nDichiarare e inizializzare una barriera:\npthread_barrier_t barrier;\npthread_barrier_init(&amp;barrier, NULL, NUM_THREADS); // NUM_THREADS è il numero di thread che devono sincronizzarsi\n\n\nUsare la barriera per sincronizzare i thread:\npthread_barrier_wait(&amp;barrier);\n\n\nEsempio Pratico con Barriera\nQuesto esempio mostra come i thread possono usare una barriera per sincronizzarsi in determinati punti del codice.\n#include &lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n \n#define NUM_THREADS 3\n \npthread_barrier_t barrier; // Dichiarazione della barriera\n \nvoid *threadFunction(void *arg) {\n    int thread_id = *((int *)arg);\n    printf(&quot;Thread %d raggiunge la barriera\\n&quot;, thread_id);\n    pthread_barrier_wait(&amp;barrier); // Punto di sincronizzazione\n    printf(&quot;Thread %d oltrepassa la barriera\\n&quot;, thread_id);\n    return NULL;\n}\n \nint main() {\n    pthread_t threads[NUM_THREADS];\n    int thread_ids[NUM_THREADS];\n \n    // Inizializzare la barriera\n    pthread_barrier_init(&amp;barrier, NULL, NUM_THREADS);\n \n    // Creare i thread\n    for (int i = 0; i &lt; NUM_THREADS; i++) {\n        thread_ids[i] = i;\n        pthread_create(&amp;threads[i], NULL, threadFunction, &amp;thread_ids[i]);\n    }\n \n    // Attendere la terminazione dei thread\n    for (int i = 0; i &lt; NUM_THREADS; i++) {\n        pthread_join(threads[i], NULL);\n    }\n \n    // Distruggere la barriera\n    pthread_barrier_destroy(&amp;barrier);\n \n    return 0;\n}\nSpiegazione\n\n\nInizializzazione:\npthread_barrier_init(&amp;barrier, NULL, NUM_THREADS);\nLa barriera è inizializzata con il numero di thread che devono sincronizzarsi.\n\n\nFunzione del thread:\npthread_barrier_wait(&amp;barrier);\nOgni thread esegue pthread_barrier_wait per aspettare che tutti i thread raggiungano questo punto.\n\n\nCreazione dei thread:\nfor (int i = 0; i &lt; NUM_THREADS; i++) {\n    pthread_create(&amp;threads[i], NULL, threadFunction, &amp;thread_ids[i]);\n}\n\n\nAttesa della terminazione dei thread:\nfor (int i = 0; i &lt; NUM_THREADS; i++) {\n    pthread_join(threads[i], NULL);\n}\n\n\nDistruzione della barriera:\npthread_barrier_destroy(&amp;barrier);\n\n\nOra conosci strumenti avanzati per la programmazione concorrente in C, come semafori e barriere, che ti permetteranno di gestire scenari di concorrenza ancora più complessi. Se hai altre domande o desideri ulteriori esempi, fammi sapere!\nHai ragione, l’esempio del semaforo che ho fornito è molto simile a quello del mutex, e può sembrare che i due meccanismi siano intercambiabili in questo caso. Tuttavia, i semafori e i mutex servono a scopi leggermente diversi. Per chiarire meglio, vediamo un esempio in cui l’uso di un semaforo è più appropriato rispetto a un mutex: il problema dei produttori e consumatori.\nProblema dei Produttori e Consumatori\nIn questo problema, i produttori producono elementi e li inseriscono in un buffer condiviso, mentre i consumatori prelevano elementi da questo buffer. Il buffer ha una capacità limitata, quindi è necessario sincronizzare l’accesso per evitare che i produttori inseriscano elementi in un buffer pieno e che i consumatori prelevino elementi da un buffer vuoto.\nUtilizzeremo due semafori:\n\nempty: per contare il numero di spazi vuoti nel buffer.\nfull: per contare il numero di elementi presenti nel buffer.\n\nE un mutex per garantire l’accesso esclusivo al buffer.\nEsempio Pratico\n#include &lt;pthread.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n \n#define BUFFER_SIZE 5\n#define NUM_ITEMS 10\n \nint buffer[BUFFER_SIZE];\nint in = 0, out = 0;\n \nsem_t empty;\nsem_t full;\npthread_mutex_t mutex;\n \nvoid *producer(void *arg) {\n    for (int i = 0; i &lt; NUM_ITEMS; i++) {\n        int item = rand() % 100; // Produce un elemento\n        sem_wait(&amp;empty); // Attende uno spazio vuoto\n        pthread_mutex_lock(&amp;mutex); // Blocca l&#039;accesso al buffer\n \n        buffer[in] = item;\n        printf(&quot;Produced: %d\\n&quot;, item);\n        in = (in + 1) % BUFFER_SIZE;\n \n        pthread_mutex_unlock(&amp;mutex); // Sblocca l&#039;accesso al buffer\n        sem_post(&amp;full); // Incrementa il numero di elementi pieni\n \n        sleep(1); // Simula il tempo di produzione\n    }\n    return NULL;\n}\n \nvoid *consumer(void *arg) {\n    for (int i = 0; i &lt; NUM_ITEMS; i++) {\n        sem_wait(&amp;full); // Attende un elemento pieno\n        pthread_mutex_lock(&amp;mutex); // Blocca l&#039;accesso al buffer\n \n        int item = buffer[out];\n        printf(&quot;Consumed: %d\\n&quot;, item);\n        out = (out + 1) % BUFFER_SIZE;\n \n        pthread_mutex_unlock(&amp;mutex); // Sblocca l&#039;accesso al buffer\n        sem_post(&amp;empty); // Incrementa il numero di spazi vuoti\n \n        sleep(1); // Simula il tempo di consumo\n    }\n    return NULL;\n}\n \nint main() {\n    pthread_t producerThread, consumerThread;\n \n    // Inizializzare i semafori e il mutex\n    sem_init(&amp;empty, 0, BUFFER_SIZE);\n    sem_init(&amp;full, 0, 0);\n    pthread_mutex_init(&amp;mutex, NULL);\n \n    // Creare i thread\n    pthread_create(&amp;producerThread, NULL, producer, NULL);\n    pthread_create(&amp;consumerThread, NULL, consumer, NULL);\n \n    // Attendere la terminazione dei thread\n    pthread_join(producerThread, NULL);\n    pthread_join(consumerThread, NULL);\n \n    // Distruggere i semafori e il mutex\n    sem_destroy(&amp;empty);\n    sem_destroy(&amp;full);\n    pthread_mutex_destroy(&amp;mutex);\n \n    return 0;\n}\nSpiegazione\n\n\nInizializzazione:\nsem_init(&amp;empty, 0, BUFFER_SIZE);\nsem_init(&amp;full, 0, 0);\npthread_mutex_init(&amp;mutex, NULL);\n\nempty: Inizializzato con il valore BUFFER_SIZE, indicando che inizialmente tutti gli spazi nel buffer sono vuoti.\nfull: Inizializzato con il valore 0, indicando che inizialmente non ci sono elementi nel buffer.\n\n\n\nProduttore:\nsem_wait(&amp;empty); // Attende uno spazio vuoto\npthread_mutex_lock(&amp;mutex); // Blocca l&#039;accesso al buffer\nbuffer[in] = item; // Inserisce l&#039;elemento nel buffer\nin = (in + 1) % BUFFER_SIZE;\npthread_mutex_unlock(&amp;mutex); // Sblocca l&#039;accesso al buffer\nsem_post(&amp;full); // Incrementa il numero di elementi pieni\nIl produttore attende che ci sia spazio nel buffer (sem_wait(&amp;empty)), poi inserisce un elemento nel buffer in modo sicuro (usando pthread_mutex_lock e pthread_mutex_unlock) e infine segnala che c’è un nuovo elemento nel buffer (sem_post(&amp;full)).\n\n\nConsumatore:\nsem_wait(&amp;full); // Attende un elemento pieno\npthread_mutex_lock(&amp;mutex); // Blocca l&#039;accesso al buffer\nint item = buffer[out]; // Preleva l&#039;elemento dal buffer\nout = (out + 1) % BUFFER_SIZE;\npthread_mutex_unlock(&amp;mutex); // Sblocca l&#039;accesso al buffer\nsem_post(&amp;empty); // Incrementa il numero di spazi vuoti\nIl consumatore attende che ci sia un elemento nel buffer (sem_wait(&amp;full)), poi preleva un elemento dal buffer in modo sicuro (usando pthread_mutex_lock e pthread_mutex_unlock) e infine segnala che c’è uno spazio vuoto nel buffer (sem_post(&amp;empty)).\n\n\nIn questo esempio, l’uso dei semafori è fondamentale per coordinare la produzione e il consumo degli elementi, evitando condizioni di gara e garantendo che il buffer non sia mai sovraccarico o vuoto.\nRiepilogo\n\n\nThread con pthread:\n\nCreare thread: pthread_create\nSincronizzare thread: pthread_join\nMutex per accesso esclusivo: pthread_mutex_lock e pthread_mutex_unlock\nBarriere per sincronizzazione: pthread_barrier_wait\n\n\n\nSemafori con semaphore.h:\n\nInizializzare semaforo: sem_init\nBloccare/decrementare semaforo: sem_wait\nSbloccare/incrementare semaforo: sem_post\nDistruggere semaforo: sem_destroy\n\n\n\nProduttori e consumatori:\n\nUsare semafori per gestire il buffer condiviso\nMutex per accesso esclusivo al buffer\n\n\n\nDeadlock\nIl deadlock si verifica quando due o più thread sono bloccati in attesa di risorse che non verranno mai liberate. È importante progettare il codice in modo da evitare deadlock.\nEsempio di deadlock:\n#include &lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n \npthread_mutex_t lock1 = PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t lock2 = PTHREAD_MUTEX_INITIALIZER;\n \nvoid *thread1_func(void *arg) {\n    pthread_mutex_lock(&amp;lock1);\n    sleep(1); // Simula un lavoro che impiega tempo\n    pthread_mutex_lock(&amp;lock2);\n \n    printf(&quot;Thread 1 ha acquisito lock1 e lock2\\n&quot;);\n \n    pthread_mutex_unlock(&amp;lock2);\n    pthread_mutex_unlock(&amp;lock1);\n    return NULL;\n}\n \nvoid *thread2_func(void *arg) {\n    pthread_mutex_lock(&amp;lock2);\n    sleep(1); // Simula un lavoro che impiega tempo\n    pthread_mutex_lock(&amp;lock1);\n \n    printf(&quot;Thread 2 ha acquisito lock2 e lock1\\n&quot;);\n \n    pthread_mutex_unlock(&amp;lock1);\n    pthread_mutex_unlock(&amp;lock2);\n    return NULL;\n}\n \nint main() {\n    pthread_t thread1, thread2;\n \n    pthread_create(&amp;thread1, NULL, thread1_func, NULL);\n    pthread_create(&amp;thread2, NULL, thread2_func, NULL);\n \n    pthread_join(thread1, NULL);\n    pthread_join(thread2, NULL);\n \n    return 0;\n}\nQuesto codice può causare un deadlock perché thread1 acquisisce lock1 e poi attende lock2, mentre thread2 acquisisce lock2 e poi attende lock1. Entrambi i thread rimangono bloccati.\nPrevenzione del deadlock:\n\nOrdine consistente di acquisizione dei lock: Assicurati che tutti i thread acquisiscano i lock nello stesso ordine.\nTimeout e retry: Usa meccanismi di timeout per evitare attese infinite.\n\nModelli di Programmazione Concorrenziale\n\n\nMap-Reduce:\n\nSuddividi il problema in parti più piccole (Map) e poi combina i risultati (Reduce).\nUtilizzato ampiamente nel processing di grandi dataset.\n\n\n\nPipeline:\n\nDiverse fasi di processamento organizzate in una catena.\nOgni fase è eseguita da un thread o gruppo di thread separato.\n\n\n\nEsempio di Pipeline\n#include &lt;pthread.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n \n#define NUM_STAGES 3\n#define NUM_ITEMS 10\n \nint buffer[NUM_STAGES][NUM_ITEMS];\nint count[NUM_STAGES] = {0};\n \npthread_mutex_t mutex[NUM_STAGES];\npthread_cond_t cond[NUM_STAGES];\n \nvoid *stage(void *arg) {\n    int stage_id = *(int *)arg;\n \n    for (int i = 0; i &lt; NUM_ITEMS; i++) {\n        if (stage_id &gt; 0) {\n            pthread_mutex_lock(&amp;mutex[stage_id - 1]);\n            while (count[stage_id - 1] == 0) {\n                pthread_cond_wait(&amp;cond[stage_id - 1], &amp;mutex[stage_id - 1]);\n            }\n            int item = buffer[stage_id - 1][--count[stage_id - 1]];\n            pthread_mutex_unlock(&amp;mutex[stage_id - 1]);\n            pthread_cond_signal(&amp;cond[stage_id - 1]);\n \n            buffer[stage_id][count[stage_id]++] = item * 2; // Processamento\n        } else {\n            buffer[stage_id][count[stage_id]++] = i + 1; // Produzione\n        }\n \n        pthread_mutex_lock(&amp;mutex[stage_id]);\n        pthread_cond_signal(&amp;cond[stage_id]);\n        pthread_mutex_unlock(&amp;mutex[stage_id]);\n    }\n \n    return NULL;\n}\n \nint main() {\n    pthread_t threads[NUM_STAGES];\n    int stage_ids[NUM_STAGES];\n \n    for (int i = 0; i &lt; NUM_STAGES; i++) {\n        pthread_mutex_init(&amp;mutex[i], NULL);\n        pthread_cond_init(&amp;cond[i], NULL);\n        stage_ids[i] = i;\n    }\n \n    for (int i = 0; i &lt; NUM_STAGES; i++) {\n        pthread_create(&amp;threads[i], NULL, stage, &amp;stage_ids[i]);\n    }\n \n    for (int i = 0; i &lt; NUM_STAGES; i++) {\n        pthread_join(threads[i], NULL);\n    }\n \n    for (int i = 0; i &lt; NUM_STAGES; i++) {\n        pthread_mutex_destroy(&amp;mutex[i]);\n        pthread_cond_destroy(&amp;cond[i]);\n    }\n \n    for (int i = 0; i &lt; NUM_ITEMS; i++) {\n        printf(&quot;Final item %d: %d\\n&quot;, i, buffer[NUM_STAGES - 1][i]);\n    }\n \n    return 0;\n}\nSpiegazione\n\n\nInizializzazione:\n\nMutex e condition variable per ogni stage della pipeline.\nBuffer per ogni stage.\n\n\n\nFunzione del thread:\n\nOgni stage processa gli elementi dal buffer precedente e li inserisce nel proprio buffer.\n\n\n\nSincronizzazione:\n\nUsare mutex e condition variable per sincronizzare l’accesso al buffer.\n\n\n\nRiepilogo\nRiepilogo: Programmazione Concorrente in C\nLa programmazione concorrente in C è essenziale per creare applicazioni efficienti che possono eseguire più operazioni contemporaneamente. Abbiamo esplorato vari concetti e meccanismi per gestire la concorrenza utilizzando thread, mutex, semafori, barriere e buffer circolari. Ecco un riepilogo di quanto appreso:\n1. Thread di Base\nCreazione e Gestione dei Thread:\n\nCreare un thread: pthread_create(&amp;thread, NULL, funzione, argomento);\nAttendere che un thread termini: pthread_join(thread, NULL);\n\n2. Mutex\nProtezione delle Risorse Condivise:\n\nDichiarare e inizializzare un mutex: pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nBloccare e sbloccare un mutex:\npthread_mutex_lock(&amp;mutex);\n// sezione critica\npthread_mutex_unlock(&amp;mutex);\n\n\n3. Semafori\nControllo dell’Accesso alle Risorse:\n\nIncludere la libreria: #include &lt;semaphore.h&gt;\nDichiarare e inizializzare un semaforo:\nsem_t semaphore;\nsem_init(&amp;semaphore, 0, valore_iniziale);\n\nDecrementare e incrementare un semaforo:\nsem_wait(&amp;semaphore); // Decrementa il semaforo, attende se il valore è 0\nsem_post(&amp;semaphore); // Incrementa il semaforo\n\nEsempio di utilizzo del semaforo di Dijkstra per gestire un pool di risorse:\n\nsem_wait(&amp;semaphore) per acquisire una risorsa.\nsem_post(&amp;semaphore) per rilasciare una risorsa.\n\n\n\n4. Barriere\nSincronizzazione di Gruppi di Thread:\n\nDichiarare e inizializzare una barriera:\npthread_barrier_t barrier;\npthread_barrier_init(&amp;barrier, NULL, NUM_THREADS);\n\nSincronizzare i thread:\npthread_barrier_wait(&amp;barrier);\n\n\n5. Buffer Circolare\nGestione di Produttori e Consumatori:\n\nDichiarare un buffer circolare:\nint buffer[BUFFER_SIZE];\nint in = 0, out = 0;\n\nProduttore:\n\nAttende uno spazio vuoto: sem_wait(&amp;empty);\nBlocca il mutex: pthread_mutex_lock(&amp;mutex);\nInserisce l’elemento: buffer[in] = item; in = (in + 1) % BUFFER_SIZE;\nSblocca il mutex: pthread_mutex_unlock(&amp;mutex);\nIncrementa il semaforo degli elementi pieni: sem_post(&amp;full);\n\n\nConsumatore:\n\nAttende un elemento pieno: sem_wait(&amp;full);\nBlocca il mutex: pthread_mutex_lock(&amp;mutex);\nPreleva l’elemento: item = buffer[out]; out = (out + 1) % BUFFER_SIZE;\nSblocca il mutex: pthread_mutex_unlock(&amp;mutex);\nIncrementa il semaforo degli spazi vuoti: sem_post(&amp;empty);\n\n\n\n6. Prevenzione del Deadlock\nEvitare Situazioni di Deadlock:\n\nOrdine consistente di acquisizione dei lock: Assicurati che tutti i thread acquisiscano i lock nello stesso ordine.\nTimeout e retry: Usa meccanismi di timeout per evitare attese infinite.\n\n7. Esercizi Pratici\nEsercizi di Difficoltà Crescente:\n\nThread di base: Creare e gestire thread semplici.\nSomma parallela: Calcolare la somma di un array usando thread.\nBuffer Circolare con Produttori e Consumatori: Sincronizzare l’accesso al buffer.\nSincronizzazione con Barriere: Utilizzare barriere per sincronizzare più thread.\nDeadlock e Prevenzione: Comprendere e prevenire il deadlock.\nLettori e Scrittori: Implementare l’accesso concorrente a un sistema di file.\nPipeline di Thread: Simulare una catena di montaggio con thread.\n"},"Argomenti/Shell/Altra-es-processi":{"slug":"Argomenti/Shell/Altra-es-processi","filePath":"Argomenti/Shell/Altra es processi.md","title":"Altra es processi","links":[],"tags":[],"content":"Ecco una possibile esercitazione di laboratorio integrata:\nEsercitazione di laboratorio: Processi in Linux\nObiettivo:\nL’obiettivo di questa esercitazione è quello di comprendere come funzionano le chiamate di funzione da shell di Linux per creare, monitorare, distruggere processi.\nPrerequisiti:\n\nConoscenza di base del sistema operativo Linux\nConoscenza di base del linguaggio di programmazione C\n\nMateriali:\n\nUn computer con sistema operativo Linux\nUn editor di testo\nUn compilatore C\n\nIstruzioni:\nPassaggio 1: Creare un processo con la shell\nNel primo passaggio, gli alunni dovranno creare un processo con la shell. Per fare questo, è possibile utilizzare il comando fork(). Questo comando crea un nuovo processo figlio che è un clone esatto del processo padre.\nRelazione sul laboratorio:\n\nCosa succede quando si esegue il comando fork()?\nQual è la sintassi del comando fork()?\nCome utilizzare il comando ps() per trovare il PID del processo figlio?\n\nPassaggio 2: Monitorare un processo con la shell\nNel secondo passaggio, gli alunni dovranno monitorare un processo con la shell. Per fare questo, è possibile utilizzare il comando ps(). Questo comando visualizza informazioni sui processi in esecuzione.\nRelazione sul laboratorio:\n\nQuali informazioni vengono visualizzate dal comando ps()?\nCome utilizzare il comando ps() per trovare un processo specifico?\nCome utilizzare il comando ps() per visualizzare le informazioni sulla memoria di un processo?\n\nPassaggio 3: Distruggere un processo con la shell\nNel terzo passaggio, gli alunni dovranno distruggere un processo con la shell. Per fare questo, è possibile utilizzare il comando kill(). Questo comando invia un segnale a un processo, che può causare l’interruzione o l’uscita del processo.\nRelazione sul laboratorio:\n\nQuali segnali è possibile inviare a un processo con il comando kill()?\nCome utilizzare il comando kill() per distruggere un processo?\n\nPassaggio 4: Creare un programma C che utilizza una risorsa\nNel quarto passaggio, gli alunni dovranno creare un programma C che utilizza una risorsa. Per questo esempio, il programma utilizzerà un semaforo per accedere a un file.\nRelazione sul laboratorio:\n\nCome utilizzare i semafori per accedere a una risorsa condivisa?\nCome utilizzare la shell per verificare quali processi stanno usando una risorsa?\n\nPassaggio 5: Verificare la memoria virtuale\nNel quinto passaggio, gli alunni dovranno verificare la memoria virtuale utilizzata dai processi in esecuzione. Per fare questo, è possibile utilizzare il comando top().\nRelazione sul laboratorio:\n\nCome utilizzare il comando top() per visualizzare le informazioni sulla memoria dei processi in esecuzione?\n\nConclusione\nAl termine di questa esercitazione, gli alunni dovrebbero avere una buona comprensione di come funzionano le chiamate di funzione da shell di Linux per creare, monitorare, distruggere processi. Inoltre, gli alunni dovrebbero essere in grado di creare i propri semplici programmi in C che utilizzano una determinata risorsa e verificare quali processi stanno usando quella risorsa.\nQuesta esercitazione integrata copre tutti i concetti chiave relativi ai processi in Linux, senza includere la concorrenza o i thread. Gli alunni impareranno a:\n\nCreare un processo con la shell\nMonitorare un processo con la shell\nDistruggere un processo con la shell\nUtilizzare i semafori per accedere a una risorsa condivisa\nVerificare la memoria virtuale utilizzata dai processi in esecuzione\n\nNaturalmente, è possibile modificare l’esercitazione in base agli interessi e ai livelli di abilità degli alunni. Ad esempio, è possibile richiedere agli alunni di creare programmi C più complessi che utilizzano più risorse o che interagiscono tra loro.\nEcco alcuni suggerimenti per l’esecuzione dell’esercitazione:\n\nFornite agli alunni un’introduzione ai concetti di base dei processi in Linux.\nDividete l’esercitazione in parti più piccole e gestibili.\nFornite agli alunni il codice sorgente dei programmi C necessari.\nFornite agli alunni feedback sui loro risultati.\n"},"Argomenti/Shell/Comandi-di-base-linux":{"slug":"Argomenti/Shell/Comandi-di-base-linux","filePath":"Argomenti/Shell/Comandi di base linux.md","title":"Comandi di base linux","links":[],"tags":[],"content":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComandoDescrizioneEsempiolsElenca i file e le directory presenti nella directory corrente.ls -lcdCambia directory.cd /home/utentepwdMostra il percorso della directory corrente.pwdmkdirCrea una nuova directory.mkdir nuova_cartellarmdirRimuove una directory vuota.rmdir cartella_vuotarmRimuove file o directory.rm file.txt, rm -r cartellacpCopia file o directory.cp file1 file2, cp -r dir1 dir2mvSposta o rinomina file o directory.mv vecchio_nome nuovo_nometouchCrea un file vuoto o aggiorna il timestamp di un file esistente.touch nuovo_file.txtcatMostra il contenuto di un file.cat file.txtnano / vimModifica un file di testo.nano file.txtechoMostra un messaggio o scrive un testo in un file.echo &quot;Testo&quot; &gt; file.txtfindCerca file o directory nel file system.find /home -name file.txtgrepCerca testo all’interno di file.grep &quot;testo&quot; file.txtmanMostra il manuale di un comando.man lsexitChiude il terminale o termina una sessione.exit"},"Argomenti/Shell/Comandi-di-base":{"slug":"Argomenti/Shell/Comandi-di-base","filePath":"Argomenti/Shell/Comandi di base.md","title":"Comandi di base","links":[],"tags":[],"content":"Certo, ecco una versione più lunga dell’esercitazione:\nEsercitazione guidata di Linux per studenti di terza superiore\nObiettivo:\n\nFar conoscere agli studenti la console di Linux e i comandi di base\nInsegnare agli studenti come utilizzare i comandi di base per navigare nel sistema, creare e gestire file e directory\nIncoraggiare gli studenti a sperimentare e a imparare da soli\n\nMateriali:\n\nComputer con Linux installato\nLavagna o foglio bianco\n\nTempo:\n\n75 minuti\n\nProcedimento:\n\nIntroduzione (10 minuti)\n\n\nInizia presentando la console di Linux e spiegando che è un’interfaccia a riga di comando che consente di interagire con il sistema operativo.\nMostra agli studenti come aprire la console.\nIllustra brevemente i vantaggi dell’utilizzo della console di Linux, come la maggiore flessibilità e il controllo.\n\n\nComandi di base (30 minuti)\n\n\n\nInsegna agli studenti i seguenti comandi di base:\n\nls: elenca il contenuto di una directory\ncd: cambia directory\npwd: visualizza il percorso corrente\nmkdir: crea una directory\nrmdir: elimina una directory\ncat: visualizza il contenuto di un file\necho: stampa un messaggio\nman: visualizza la documentazione di un comando\n\n\n\nEsegui ogni comando alla lavagna o su un foglio bianco e spiegane l’uso.\n\n\nDai agli studenti l’opportunità di esercitarsi con i comandi.\n\n\n\nEsercizi (25 minuti)\n\n\n\nDivide gli studenti in gruppi di due o tre e fornisci loro una serie di esercizi da svolgere.\n\n\nGli esercizi dovrebbero consentire agli studenti di mettere in pratica i comandi di base appresi.\n\n\nEcco alcuni esempi di esercizi:\n\nCrea una directory chiamata “my_files” e spostati in essa.\nCrea un file di testo chiamato “my_file.txt” e scrivici il tuo nome.\nStampa il contenuto del file “my_file.txt”.\nElimina la directory “my_files”.\nCrea una directory chiamata “programming” e spostati in essa.\nCrea un file di testo chiamato “hello.c” e scrivici un semplice programma C che stampa il messaggio “Hello, world!“.\nCompila il programma “hello.c”.\nEsegui il programma “hello.c”.\n\n\n\n\nFeedback (10 minuti)\n\n\nAl termine degli esercizi, chiedi agli studenti di condividere le loro impressioni.\nRispondi alle domande degli studenti.\n\nVarianti:\n\nPer rendere l’esercitazione più coinvolgente, puoi chiedere agli studenti di creare un progetto personale da realizzare utilizzando la console di Linux. Ad esempio, potrebbero creare un programma per calcolare la somma di due numeri o un semplice gioco.\nSe gli studenti hanno già familiarità con la console di Linux, puoi approfondire alcuni argomenti più avanzati, come la creazione di script o l’utilizzo dei comandi pipe.\n\nConclusione:\nQuesta esercitazione è un ottimo modo per iniziare a insegnare agli studenti l’utilizzo della console di Linux. I comandi di base presentati in questa esercitazione sono quelli che gli studenti utilizzeranno più frequentemente.\nAggiuntivi:\n\n\nIntroduzione alla shell (5 minuti)\n\n\nIllustra brevemente la shell, che è il programma che interpreta i comandi inseriti dall’utente.\n\n\nEsegui alcuni comandi alla lavagna o su un foglio bianco e spiegane l’uso.\n\n\nEsercizio: creare un menu (20 minuti)\n\n\nChiedi agli studenti di creare un menu che permetta all’utente di scegliere tra diverse opzioni.\n\n\nLe opzioni potrebbero includere la creazione di una directory, la creazione di un file di testo, la stampa del contenuto di un file e l’eliminazione di una directory.\n\n\nEsercizio: creare un programma (30 minuti)\n\n\nChiedi agli studenti di creare un semplice programma C che stampi il messaggio “Hello, world!“.\n\n\nIl programma dovrebbe essere composto da una sola funzione, che stampa il messaggio.\n\n\nQuesti sono solo alcuni suggerimenti per rendere l’esercitazione più lunga e coinvolgente. Puoi adattare l’esercitazione in base alle esigenze dei tuoi studenti e al tuo livello di esperienza."},"Argomenti/Shell/Esercitazione-1":{"slug":"Argomenti/Shell/Esercitazione-1","filePath":"Argomenti/Shell/Esercitazione 1.md","title":"Esercitazione 1","links":[],"tags":[],"content":"Certo, ecco una versione più lunga dell’esercitazione:\nEsercitazione guidata di Linux per studenti di terza superiore\nObiettivo:\n\nFar conoscere agli studenti la console di Linux e i comandi di base\nInsegnare agli studenti come utilizzare i comandi di base per navigare nel sistema, creare e gestire file e directory\nIncoraggiare gli studenti a sperimentare e a imparare da soli\n\nMateriali:\n\nComputer con Linux installato\nLavagna o foglio bianco\n\nTempo:\n\n75 minuti\n\nProcedimento:\n\nIntroduzione (10 minuti)\n\n\nInizia presentando la console di Linux e spiegando che è un’interfaccia a riga di comando che consente di interagire con il sistema operativo.\nMostra agli studenti come aprire la console.\nIllustra brevemente i vantaggi dell’utilizzo della console di Linux, come la maggiore flessibilità e il controllo.\n\n\nComandi di base (30 minuti)\n\n\n\nInsegna agli studenti i seguenti comandi di base:\n\nls: elenca il contenuto di una directory\ncd: cambia directory\npwd: visualizza il percorso corrente\nmkdir: crea una directory\nrmdir: elimina una directory\ncat: visualizza il contenuto di un file\necho: stampa un messaggio\nman: visualizza la documentazione di un comando\n\n\n\nEsegui ogni comando alla lavagna o su un foglio bianco e spiegane l’uso.\n\n\nDai agli studenti l’opportunità di esercitarsi con i comandi.\n\n\n\nEsercizi (25 minuti)\n\n\n\nDivide gli studenti in gruppi di due o tre e fornisci loro una serie di esercizi da svolgere.\n\n\nGli esercizi dovrebbero consentire agli studenti di mettere in pratica i comandi di base appresi.\n\n\nEcco alcuni esempi di esercizi:\n\nCrea una directory chiamata “my_files” e spostati in essa.\nCrea un file di testo chiamato “my_file.txt” e scrivici il tuo nome.\nStampa il contenuto del file “my_file.txt”.\nElimina la directory “my_files”.\nCrea una directory chiamata “programming” e spostati in essa.\nCrea un file di testo chiamato “hello.c” e scrivici un semplice programma C che stampa il messaggio “Hello, world!“.\nCompila il programma “hello.c”.\nEsegui il programma “hello.c”.\n\n\n\n\nFeedback (10 minuti)\n\n\nAl termine degli esercizi, chiedi agli studenti di condividere le loro impressioni.\nRispondi alle domande degli studenti.\n\nVarianti:\n\nPer rendere l’esercitazione più coinvolgente, puoi chiedere agli studenti di creare un progetto personale da realizzare utilizzando la console di Linux. Ad esempio, potrebbero creare un programma per calcolare la somma di due numeri o un semplice gioco.\nSe gli studenti hanno già familiarità con la console di Linux, puoi approfondire alcuni argomenti più avanzati, come la creazione di script o l’utilizzo dei comandi pipe.\n\nConclusione:\nQuesta esercitazione è un ottimo modo per iniziare a insegnare agli studenti l’utilizzo della console di Linux. I comandi di base presentati in questa esercitazione sono quelli che gli studenti utilizzeranno più frequentemente.\nAggiuntivi:\n\n\nIntroduzione alla shell (5 minuti)\n\n\nIllustra brevemente la shell, che è il programma che interpreta i comandi inseriti dall’utente.\n\n\nEsegui alcuni comandi alla lavagna o su un foglio bianco e spiegane l’uso.\n\n\nEsercizio: creare un menu (20 minuti)\n\n\nChiedi agli studenti di creare un menu che permetta all’utente di scegliere tra diverse opzioni.\n\n\nLe opzioni potrebbero includere la creazione di una directory, la creazione di un file di testo, la stampa del contenuto di un file e l’eliminazione di una directory.\n\n\nEsercizio: creare un programma (30 minuti)\n\n\nChiedi agli studenti di creare un semplice programma C che stampi il messaggio “Hello, world!“.\n\n\nIl programma dovrebbe essere composto da una sola funzione, che stampa il messaggio.\n\n\nQuesti sono solo alcuni suggerimenti per rendere l’esercitazione più lunga e coinvolgente. Puoi adattare l’esercitazione in base alle esigenze dei tuoi studenti e al tuo livello di esperienza."},"Argomenti/Shell/Esercitazione-sui-processi-rielaborata":{"slug":"Argomenti/Shell/Esercitazione-sui-processi-rielaborata","filePath":"Argomenti/Shell/Esercitazione sui processi rielaborata.md","title":"Esercitazione sui processi rielaborata","links":[],"tags":[],"content":"Esercitazione prima parte\nEsercitazione sulla gestione dei processi in Linux tramite shell\nObiettivo:\n\nCreare, identificare, terminare e monitorare i processi in Linux tramite la shell.\nRelazionare ogni singolo passaggio con screenshot su un documento di testo\nUtilizzare il man per capire a fondo cosa faccia ogni funzione (e specificarlo nella relazione)\n\nIstruzioni:\nParte 1: Introduzione\n\nIl sistema operativo Linux è un sistema operativo multiprocesso, il che significa che può eseguire più processi contemporaneamente.\nUn processo è un programma in esecuzione.\nOgni processo ha un proprio spazio di memoria e un proprio set di risorse.\nIl sistema operativo Linux utilizza uno scheduler per gestire i processi.\n\nParte 2: Creazione di processi\n\nIl comando fork() crea un nuovo processo che è un clone del processo corrente.\nIl PID del nuovo processo è un numero univoco che identifica il processo.\n\nEsercizio 1:\n\nCrea un nuovo processo utilizzando il comando fork().\nUtilizza il comando ps per verificare che il nuovo processo sia stato creato.\n\nParte 3: Identificazione dei processi\n\nIl comando ps visualizza un elenco dei processi in esecuzione.\nIl comando pgrep cerca un processo in base al suo nome.\nIl comando pidof cerca un processo in base al suo PID.\n\nEsercizio 2:\n\nUtilizza il comando ps per visualizzare l’elenco dei processi in esecuzione.\nUtilizza il comando pgrep per cercare un processo con un nome specifico. Per questo compito, creare un nuovo file sorgente in c esclusivamente tramite shell e compilarlo.\nUtilizza il comando pidof per cercare un processo con un percorso specifico.\n\nParte 4: Terminazione dei processi\n\nIl comando kill() termina un processo in base al suo PID.\nIl comando killall termina tutti i processi con un nome specifico.\n\nEsercizio 3:\n\nUtilizza il comando kill() per terminare un processo con un PID specifico.\nUtilizza il comando killall per terminare tutti i processi con un nome specifico.\n\nParte 5: Monitoraggio dei processi\n\nIl comando top visualizza un elenco dei processi in esecuzione in tempo reale.\nIl comando htop è un’interfaccia grafica per il comando top.\n\nEsercizio 4:\n\nUtilizza il comando top per monitorare i processi in esecuzione.\nUtilizza il comando htop per monitorare i processi in esecuzione.\n\nConclusione\n\nIn questa esercitazione, gli studenti hanno imparato a creare, identificare, terminare e monitorare i processi in Linux tramite la shell.\nGli studenti dovrebbero essere in grado di utilizzare questi concetti per gestire i processi in Linux.\n\nSuggerimenti per gli studenti:\n\nAssicurati di comprendere la sintassi dei comandi fork(), ps, pgrep, pidof, kill() e killall.\nEsegui gli esercizi più volte per consolidare la tua comprensione dei concetti.\nSe hai domande, chiedi al tuo insegnante o a un altro studente.\n\nUtilizzo concorrente di risorse\nPer verificare in Linux se un processo sta utilizzando un determinato file tramite shell, puoi utilizzare il comando lsof. Il comando lsof visualizza un elenco di tutti i file aperti dai processi in esecuzione.\nPer verificare se un processo sta utilizzando un determinato file, puoi utilizzare la seguente sintassi:\nlsof | grep &lt;nome_file&gt;\n\nAd esempio, per verificare se il processo con PID 1234 sta utilizzando il file /etc/passwd, puoi utilizzare il seguente comando:\nlsof | grep /etc/passwd | grep 1234\n\nSe il processo sta utilizzando il file, vedrai il seguente output:\nCOMMAND     PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\n&lt;nome_processo&gt; 1234 root    3u  IPv4 32768      0t0  TCP *:ssh (LISTEN)\n\nL’output mostra che il processo &lt;nome_processo&gt; con PID 1234 sta utilizzando il file /etc/passwd.\nIn alternativa, puoi utilizzare il comando fuser. Il comando fuser visualizza un elenco di tutti i processi che utilizzano un determinato file o socket.\nPer verificare se un processo sta utilizzando un determinato file, puoi utilizzare la seguente sintassi:\nfuser &lt;nome_file&gt;\n\nAd esempio, per verificare se il processo con PID 1234 sta utilizzando il file /etc/passwd, puoi utilizzare il seguente comando:\nfuser /etc/passwd\n\nSe il processo sta utilizzando il file, vedrai il seguente output:\n&lt;nome_processo&gt; 1234\n\nL’output mostra che il processo &lt;nome_processo&gt; con PID 1234 sta utilizzando il file /etc/passwd.\nEsercitazione seconda parte\nCreare e compilare due programmi in C che utilizzino la stessa risorsa, verificare cosa succede con i comandi citati nella parte sopra ed effettuare delle prove. Relazionare nel dettaglio tutto quello che succede."},"Argomenti/Shell/Esercitazione-sui-processi":{"slug":"Argomenti/Shell/Esercitazione-sui-processi","filePath":"Argomenti/Shell/Esercitazione sui processi.md","title":"Esercitazione sui processi","links":[],"tags":[],"content":"Un’esercitazione di laboratorio utile per la prima volta potrebbe essere quella di creare e gestire diversi processi su Linux. Questo permetterebbe agli studenti di comprendere i seguenti concetti:\n\nCome creare un processo in Linux\nCome identificare un processo in esecuzione\nCome terminare un processo\nCome monitorare lo stato di un processo\n\nPer questa esercitazione, gli studenti potrebbero utilizzare il comando ps per visualizzare l’elenco dei processi in esecuzione. Quindi, potrebbero utilizzare il comando fork() per creare un nuovo processo. Dopo aver creato il nuovo processo, gli studenti potrebbero utilizzare il comando ps per visualizzare l’elenco dei processi in esecuzione e verificare che il nuovo processo sia stato creato correttamente.\nPer terminare il nuovo processo, gli studenti potrebbero utilizzare il comando kill(). Dopo aver terminato il processo, gli studenti potrebbero utilizzare il comando ps per verificare che il processo sia stato effettivamente terminato.\nInfine, gli studenti potrebbero utilizzare il comando top per monitorare lo stato dei processi in esecuzione. Questo comando permetterebbe agli studenti di vedere quali processi sono attivi, quali processi stanno utilizzando più risorse e quali processi sono in attesa di risorse.\nEcco un esempio di come potrebbe essere strutturata l’esercitazione:\nObiettivo:\n\nCreare e gestire diversi processi su Linux\n\nMateriali:\n\nComputer con sistema operativo Linux\nTerminale\n\nIstruzioni:\n\nAccedi al terminale.\nEsegui il comando ps per visualizzare l’elenco dei processi in esecuzione.\nUtilizza il comando fork() per creare un nuovo processo.\nEsegui nuovamente il comando ps per visualizzare l’elenco dei processi in esecuzione.\nUtilizza il comando kill() per terminare il nuovo processo.\nEsegui nuovamente il comando ps per verificare che il nuovo processo sia stato terminato.\nEsegui il comando top per monitorare lo stato dei processi in esecuzione.\n\nQuesta esercitazione è abbastanza semplice da comprendere e da eseguire, ma è comunque utile per comprendere i concetti fondamentali dei processi e dello scheduling dei processi su Linux.\nEcco alcune altre esercitazioni che potrebbero essere utili:\n\nCreare un processo che esegue un semplice programma, come un programma che stampa “Hello, world!”\nCreare un processo che si connette a un server web\nCreare un processo che utilizza un particolare dispositivo hardware\n\nQueste esercitazioni sono più avanzate, ma sono utili per comprendere come i processi possono essere utilizzati per eseguire attività reali.\nPassaggi\nCerto, ecco i passaggi per creare e gestire diversi processi su Linux tramite la console:\nPassaggio 1: Accedi al terminale\nApri un terminale premendo Ctrl+Alt+T.\nPassaggio 2: Esegui il comando ps per visualizzare l’elenco dei processi in esecuzione\nEsegui il comando ps per visualizzare l’elenco dei processi in esecuzione. Il comando ps mostra le informazioni sui processi in esecuzione, come il PID, il nome del processo, lo stato del processo e il tempo di esecuzione.\nps\n\nPassaggio 3: Utilizza il comando fork() per creare un nuovo processo\nIl comando fork() crea un nuovo processo che è un clone del processo corrente. Il PID del nuovo processo è un numero univoco che identifica il processo.\nfork()\n\nPassaggio 4: Esegui nuovamente il comando ps per visualizzare l’elenco dei processi in esecuzione\nEsegui nuovamente il comando ps per visualizzare l’elenco dei processi in esecuzione. Il nuovo processo dovrebbe essere elencato.\nps\n\nPassaggio 5: Utilizza il comando kill() per terminare il nuovo processo\nIl comando kill() termina un processo in base al suo PID.\nkill &lt;PID&gt;\n\nPassaggio 6: Esegui nuovamente il comando ps per verificare che il nuovo processo sia stato terminato\nEsegui nuovamente il comando ps per verificare che il nuovo processo sia stato terminato. Il nuovo processo non dovrebbe essere elencato.\nps\n\nPassaggio 7: Esegui il comando top per monitorare lo stato dei processi in esecuzione\nIl comando top visualizza un elenco dei processi in esecuzione in tempo reale. Il comando top mostra le informazioni sui processi in esecuzione, come il PID, il nome del processo, lo stato del processo, il tempo di esecuzione e l’utilizzo delle risorse.\ntop\n\nEcco un esempio dei risultati che potresti vedere:\nPID USER      PR  NI  VIRT  RES  SHR S  %CPU %MEM     TIME+ COMMAND\n1      root      20  0  12160  504  288 S  0.0  0.0   0:00.00 bash\n2      root      20  0  12160  504  288 S  0.0  0.0   0:00.00 ps\n3      root      20  0  12160  504  288 S  0.0  0.0   0:00.00 top\n\nIn questo esempio, il processo con PID 3 è il processo top.\nQuesta esercitazione è abbastanza semplice da comprendere e da eseguire, ma è comunque utile per comprendere i concetti fondamentali dei processi e dello scheduling dei processi su Linux.\nEcco alcuni suggerimenti per gli studenti:\n\nAssicurati di comprendere la sintassi dei comandi ps, fork(), kill() e top.\nEsegui gli esercizi più volte per consolidare la tua comprensione dei concetti.\nSe hai domande, chiedi al tuo insegnante o a un altro studente.\n\nEsercitazione\nEsercitazione sulla gestione dei processi in Linux tramite shell\nObiettivo:\n\nGli studenti saranno in grado di creare, identificare, terminare e monitorare i processi in Linux tramite la shell.\n\nMateriali:\n\nComputer con sistema operativo Linux\nTerminale\n\nIstruzioni:\nParte 1: Introduzione\n\nIl sistema operativo Linux è un sistema operativo multiprocesso, il che significa che può eseguire più processi contemporaneamente.\nUn processo è un programma in esecuzione.\nOgni processo ha un proprio spazio di memoria e un proprio set di risorse.\nIl sistema operativo Linux utilizza uno scheduler per gestire i processi.\n\nParte 2: Creazione di processi\n\nIl comando fork() crea un nuovo processo che è un clone del processo corrente.\nIl PID del nuovo processo è un numero univoco che identifica il processo.\n\nEsercizio 1:\n\nCrea un nuovo processo utilizzando il comando fork().\nUtilizza il comando ps per verificare che il nuovo processo sia stato creato.\n\nParte 3: Identificazione dei processi\n\nIl comando ps visualizza un elenco dei processi in esecuzione.\nIl comando pgrep cerca un processo in base al suo nome.\nIl comando pidof cerca un processo in base al suo percorso.\n\nEsercizio 2:\n\nUtilizza il comando ps per visualizzare l’elenco dei processi in esecuzione.\nUtilizza il comando pgrep per cercare un processo con un nome specifico.\nUtilizza il comando pidof per cercare un processo con un percorso specifico.\n\nParte 4: Terminazione dei processi\n\nIl comando kill() termina un processo in base al suo PID.\nIl comando killall termina tutti i processi con un nome specifico.\n\nEsercizio 3:\n\nUtilizza il comando kill() per terminare un processo con un PID specifico.\nUtilizza il comando killall per terminare tutti i processi con un nome specifico.\n\nParte 5: Monitoraggio dei processi\n\nIl comando top visualizza un elenco dei processi in esecuzione in tempo reale.\nIl comando htop è un’interfaccia grafica per il comando top.\n\nEsercizio 4:\n\nUtilizza il comando top per monitorare i processi in esecuzione.\nUtilizza il comando htop per monitorare i processi in esecuzione.\n\nConclusione\n\nIn questa esercitazione, gli studenti hanno imparato a creare, identificare, terminare e monitorare i processi in Linux tramite la shell.\nGli studenti dovrebbero essere in grado di utilizzare questi concetti per gestire i processi in Linux.\n\nSuggerimenti per gli studenti:\n\nAssicurati di comprendere la sintassi dei comandi fork(), ps, pgrep, pidof, kill() e killall.\nEsegui gli esercizi più volte per consolidare la tua comprensione dei concetti.\nSe hai domande, chiedi al tuo insegnante o a un altro studente.\n\nEstensioni:\n\nCrea un processo che esegue un semplice programma, come un programma che stampa “Hello, world!”\nCrea un processo che si connette a un server web\nCrea un processo che utilizza un particolare dispositivo hardware\n\nQueste esercitazioni sono più avanzate, ma sono utili per comprendere come i processi possono essere utilizzati per eseguire attività reali.\nUtilizzo concorrente di risorse\nPer verificare in Linux se un processo sta utilizzando un determinato file tramite shell, puoi utilizzare il comando lsof. Il comando lsof visualizza un elenco di tutti i file aperti dai processi in esecuzione.\nPer verificare se un processo sta utilizzando un determinato file, puoi utilizzare la seguente sintassi:\nlsof | grep &lt;nome_file&gt;\n\nAd esempio, per verificare se il processo con PID 1234 sta utilizzando il file /etc/passwd, puoi utilizzare il seguente comando:\nlsof | grep /etc/passwd | grep 1234\n\nSe il processo sta utilizzando il file, vedrai il seguente output:\nCOMMAND     PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\n&lt;nome_processo&gt; 1234 root    3u  IPv4 32768      0t0  TCP *:ssh (LISTEN)\n\nL’output mostra che il processo &lt;nome_processo&gt; con PID 1234 sta utilizzando il file /etc/passwd.\nIn alternativa, puoi utilizzare il comando fuser. Il comando fuser visualizza un elenco di tutti i processi che utilizzano un determinato file o socket.\nPer verificare se un processo sta utilizzando un determinato file, puoi utilizzare la seguente sintassi:\nfuser &lt;nome_file&gt;\n\nAd esempio, per verificare se il processo con PID 1234 sta utilizzando il file /etc/passwd, puoi utilizzare il seguente comando:\nfuser /etc/passwd\n\nSe il processo sta utilizzando il file, vedrai il seguente output:\n&lt;nome_processo&gt; 1234\n\nL’output mostra che il processo &lt;nome_processo&gt; con PID 1234 sta utilizzando il file /etc/passwd."},"Argomenti/Shell/Gestione-dei-processi":{"slug":"Argomenti/Shell/Gestione-dei-processi","filePath":"Argomenti/Shell/Gestione dei processi.md","title":"Gestione dei processi","links":[],"tags":[],"content":"Un’esercitazione di laboratorio utile per la prima volta potrebbe essere quella di creare e gestire diversi processi su Linux. Questo permetterebbe agli studenti di comprendere i seguenti concetti:\n\nCome creare un processo in Linux\nCome identificare un processo in esecuzione\nCome terminare un processo\nCome monitorare lo stato di un processo\n\nPer questa esercitazione, gli studenti potrebbero utilizzare il comando ps per visualizzare l’elenco dei processi in esecuzione. Quindi, potrebbero utilizzare il comando fork() per creare un nuovo processo. Dopo aver creato il nuovo processo, gli studenti potrebbero utilizzare il comando ps per visualizzare l’elenco dei processi in esecuzione e verificare che il nuovo processo sia stato creato correttamente.\nPer terminare il nuovo processo, gli studenti potrebbero utilizzare il comando kill(). Dopo aver terminato il processo, gli studenti potrebbero utilizzare il comando ps per verificare che il processo sia stato effettivamente terminato.\nInfine, gli studenti potrebbero utilizzare il comando top per monitorare lo stato dei processi in esecuzione. Questo comando permetterebbe agli studenti di vedere quali processi sono attivi, quali processi stanno utilizzando più risorse e quali processi sono in attesa di risorse.\nEcco un esempio di come potrebbe essere strutturata l’esercitazione:\nObiettivo:\n\nCreare e gestire diversi processi su Linux\n\nMateriali:\n\nComputer con sistema operativo Linux\nTerminale\n\nIstruzioni:\n\nAccedi al terminale.\nEsegui il comando ps per visualizzare l’elenco dei processi in esecuzione.\nUtilizza il comando fork() per creare un nuovo processo.\nEsegui nuovamente il comando ps per visualizzare l’elenco dei processi in esecuzione.\nUtilizza il comando kill() per terminare il nuovo processo.\nEsegui nuovamente il comando ps per verificare che il nuovo processo sia stato terminato.\nEsegui il comando top per monitorare lo stato dei processi in esecuzione.\n\nQuesta esercitazione è abbastanza semplice da comprendere e da eseguire, ma è comunque utile per comprendere i concetti fondamentali dei processi e dello scheduling dei processi su Linux.\nEcco alcune altre esercitazioni che potrebbero essere utili:\n\nCreare un processo che esegue un semplice programma, come un programma che stampa “Hello, world!”\nCreare un processo che si connette a un server web\nCreare un processo che utilizza un particolare dispositivo hardware\n\nQueste esercitazioni sono più avanzate, ma sono utili per comprendere come i processi possono essere utilizzati per eseguire attività reali.\nPassaggi\nCerto, ecco i passaggi per creare e gestire diversi processi su Linux tramite la console:\nPassaggio 1: Accedi al terminale\nApri un terminale premendo Ctrl+Alt+T.\nPassaggio 2: Esegui il comando ps per visualizzare l’elenco dei processi in esecuzione\nEsegui il comando ps per visualizzare l’elenco dei processi in esecuzione. Il comando ps mostra le informazioni sui processi in esecuzione, come il PID, il nome del processo, lo stato del processo e il tempo di esecuzione.\nps\n\nPassaggio 3: Utilizza il comando fork() per creare un nuovo processo\nIl comando fork() crea un nuovo processo che è un clone del processo corrente. Il PID del nuovo processo è un numero univoco che identifica il processo.\nfork()\n\nPassaggio 4: Esegui nuovamente il comando ps per visualizzare l’elenco dei processi in esecuzione\nEsegui nuovamente il comando ps per visualizzare l’elenco dei processi in esecuzione. Il nuovo processo dovrebbe essere elencato.\nps\n\nPassaggio 5: Utilizza il comando kill() per terminare il nuovo processo\nIl comando kill() termina un processo in base al suo PID.\nkill &lt;PID&gt;\n\nPassaggio 6: Esegui nuovamente il comando ps per verificare che il nuovo processo sia stato terminato\nEsegui nuovamente il comando ps per verificare che il nuovo processo sia stato terminato. Il nuovo processo non dovrebbe essere elencato.\nps\n\nPassaggio 7: Esegui il comando top per monitorare lo stato dei processi in esecuzione\nIl comando top visualizza un elenco dei processi in esecuzione in tempo reale. Il comando top mostra le informazioni sui processi in esecuzione, come il PID, il nome del processo, lo stato del processo, il tempo di esecuzione e l’utilizzo delle risorse.\ntop\n\nEcco un esempio dei risultati che potresti vedere:\nPID USER      PR  NI  VIRT  RES  SHR S  %CPU %MEM     TIME+ COMMAND\n1      root      20  0  12160  504  288 S  0.0  0.0   0:00.00 bash\n2      root      20  0  12160  504  288 S  0.0  0.0   0:00.00 ps\n3      root      20  0  12160  504  288 S  0.0  0.0   0:00.00 top\n\nIn questo esempio, il processo con PID 3 è il processo top.\nQuesta esercitazione è abbastanza semplice da comprendere e da eseguire, ma è comunque utile per comprendere i concetti fondamentali dei processi e dello scheduling dei processi su Linux.\nEcco alcuni suggerimenti per gli studenti:\n\nAssicurati di comprendere la sintassi dei comandi ps, fork(), kill() e top.\nEsegui gli esercizi più volte per consolidare la tua comprensione dei concetti.\nSe hai domande, chiedi al tuo insegnante o a un altro studente.\n\nEsercitazione\nEsercitazione sulla gestione dei processi in Linux tramite shell\nObiettivo:\n\nGli studenti saranno in grado di creare, identificare, terminare e monitorare i processi in Linux tramite la shell.\n\nMateriali:\n\nComputer con sistema operativo Linux\nTerminale\n\nIstruzioni:\nParte 1: Introduzione\n\nIl sistema operativo Linux è un sistema operativo multiprocesso, il che significa che può eseguire più processi contemporaneamente.\nUn processo è un programma in esecuzione.\nOgni processo ha un proprio spazio di memoria e un proprio set di risorse.\nIl sistema operativo Linux utilizza uno scheduler per gestire i processi.\n\nParte 2: Creazione di processi\n\nIl comando fork() crea un nuovo processo che è un clone del processo corrente.\nIl PID del nuovo processo è un numero univoco che identifica il processo.\n\nEsercizio 1:\n\nCrea un nuovo processo utilizzando il comando fork().\nUtilizza il comando ps per verificare che il nuovo processo sia stato creato.\n\nParte 3: Identificazione dei processi\n\nIl comando ps visualizza un elenco dei processi in esecuzione.\nIl comando pgrep cerca un processo in base al suo nome.\nIl comando pidof cerca un processo in base al suo percorso.\n\nEsercizio 2:\n\nUtilizza il comando ps per visualizzare l’elenco dei processi in esecuzione.\nUtilizza il comando pgrep per cercare un processo con un nome specifico.\nUtilizza il comando pidof per cercare un processo con un percorso specifico.\n\nParte 4: Terminazione dei processi\n\nIl comando kill() termina un processo in base al suo PID.\nIl comando killall termina tutti i processi con un nome specifico.\n\nEsercizio 3:\n\nUtilizza il comando kill() per terminare un processo con un PID specifico.\nUtilizza il comando killall per terminare tutti i processi con un nome specifico.\n\nParte 5: Monitoraggio dei processi\n\nIl comando top visualizza un elenco dei processi in esecuzione in tempo reale.\nIl comando htop è un’interfaccia grafica per il comando top.\n\nEsercizio 4:\n\nUtilizza il comando top per monitorare i processi in esecuzione.\nUtilizza il comando htop per monitorare i processi in esecuzione.\n\nConclusione\n\nIn questa esercitazione, gli studenti hanno imparato a creare, identificare, terminare e monitorare i processi in Linux tramite la shell.\nGli studenti dovrebbero essere in grado di utilizzare questi concetti per gestire i processi in Linux.\n\nSuggerimenti per gli studenti:\n\nAssicurati di comprendere la sintassi dei comandi fork(), ps, pgrep, pidof, kill() e killall.\nEsegui gli esercizi più volte per consolidare la tua comprensione dei concetti.\nSe hai domande, chiedi al tuo insegnante o a un altro studente.\n\nEstensioni:\n\nCrea un processo che esegue un semplice programma, come un programma che stampa “Hello, world!”\nCrea un processo che si connette a un server web\nCrea un processo che utilizza un particolare dispositivo hardware\n\nQueste esercitazioni sono più avanzate, ma sono utili per comprendere come i processi possono essere utilizzati per eseguire attività reali.\nUtilizzo concorrente di risorse\nPer verificare in Linux se un processo sta utilizzando un determinato file tramite shell, puoi utilizzare il comando lsof. Il comando lsof visualizza un elenco di tutti i file aperti dai processi in esecuzione.\nPer verificare se un processo sta utilizzando un determinato file, puoi utilizzare la seguente sintassi:\nlsof | grep &lt;nome_file&gt;\n\nAd esempio, per verificare se il processo con PID 1234 sta utilizzando il file /etc/passwd, puoi utilizzare il seguente comando:\nlsof | grep /etc/passwd | grep 1234\n\nSe il processo sta utilizzando il file, vedrai il seguente output:\nCOMMAND     PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\n&lt;nome_processo&gt; 1234 root    3u  IPv4 32768      0t0  TCP *:ssh (LISTEN)\n\nL’output mostra che il processo &lt;nome_processo&gt; con PID 1234 sta utilizzando il file /etc/passwd.\nIn alternativa, puoi utilizzare il comando fuser. Il comando fuser visualizza un elenco di tutti i processi che utilizzano un determinato file o socket.\nPer verificare se un processo sta utilizzando un determinato file, puoi utilizzare la seguente sintassi:\nfuser &lt;nome_file&gt;\n\nAd esempio, per verificare se il processo con PID 1234 sta utilizzando il file /etc/passwd, puoi utilizzare il seguente comando:\nfuser /etc/passwd\n\nSe il processo sta utilizzando il file, vedrai il seguente output:\n&lt;nome_processo&gt; 1234\n\nL’output mostra che il processo &lt;nome_processo&gt; con PID 1234 sta utilizzando il file /etc/passwd."},"Argomenti/Shell/Installare-macchina-virtuale-linux-per-principianti":{"slug":"Argomenti/Shell/Installare-macchina-virtuale-linux-per-principianti","filePath":"Argomenti/Shell/Installare macchina virtuale linux per principianti.md","title":"Installare macchina virtuale linux per principianti","links":[],"tags":[],"content":"Passo 1: Scarica e Installa VirtualBox\n\nVai al sito web di VirtualBox: www.virtualbox.org/\nFai clic su “Downloads” nella barra di navigazione.\nScarica la versione più recente di VirtualBox per Windows.\nEsegui il file di installazione scaricato e segui le istruzioni per completare l’installazione.\n\nPasso 2: Scarica un’immagine ISO di Linux\n\nDecide quale distribuzione Linux vuoi utilizzare. Suggerisco di utilizzare Linux Mint ai principianti.\nVai al sito web della distribuzione Linux scelta e scarica l’immagine ISO del sistema operativo.\n\nPasso 3: Crea una Nuova Macchina Virtuale in VirtualBox\n\nApri VirtualBox.\nClicca su “Nuova” nella barra degli strumenti.\nInserisci un nome per la tua macchina virtuale e seleziona il tipo “Linux”.\nScegli la versione che corrisponde al sistema operativo Linux che hai scaricato (ad esempio, “Mint” se hai scaricato Linux Mint).\nClicca su “Avanti”.\n\nPasso 4: Assegna la Quantità di Memoria\n\nAssegna la quantità di memoria RAM per la tua macchina virtuale. Scegli un valore che non comprometta le prestazioni del tuo sistema host. Una media di 2 GB è spesso sufficiente.\nClicca su “Avanti”.\n\nPasso 5: Crea un Disco Rigido Virtuale\n\nSeleziona “Crea un nuovo disco rigido virtuale” e clicca su “Avanti”.\nScegli il tipo di file del disco rigido virtuale (di solito, “VDI” è una buona scelta).\nSeleziona se vuoi un disco fisso o dinamico (dinamico è di solito una buona opzione per risparmiare spazio sul disco).\nAssegna la dimensione del disco rigido virtuale e clicca su “Crea”.\n\nPasso 6: Monta l’Immagine ISO di Linux\n\nTorna alla schermata principale di VirtualBox.\nSeleziona la tua nuova macchina virtuale e clicca su “Impostazioni”.\nNella finestra delle impostazioni, vai su “Archiviazione” nella barra laterale.\nSotto “Controller: IDE”, trova il simbolo del disco e clicca su “Vuoto”.\nNella sezione “Disco Ottico”, clicca sull’icona del disco accanto a “Controller: IDE” e seleziona “Scegli un file disco ottico”.\nSeleziona l’immagine ISO di Linux che hai scaricato e clicca su “Apri”.\n\nPasso 7: Avvia la Macchina Virtuale\n\nTorna alla schermata principale di VirtualBox.\nSeleziona la tua macchina virtuale e clicca su “Avvia”.\nLa macchina virtuale dovrebbe avviarsi con l’immagine ISO di Linux che hai montato. Segui le istruzioni di installazione di Linux.\n\nPasso 8: Completa l’Installazione di Linux\n\nSegui le istruzioni guidate per installare Linux sulla tua macchina virtuale.\nQuando richiesto, seleziona il disco rigido virtuale creato in precedenza come posizione di installazione.\nCompleta il processo di installazione, inclusa la configurazione dell’utente e della password.\n\nUna volta completati questi passaggi, dovresti avere una macchina virtuale Linux funzionante su Windows tramite VirtualBox. Puoi avviare e spegnere la macchina virtuale quando ne hai bisogno, consentendoti di esplorare Linux senza dover installarlo direttamente sul tuo computer."},"Argomenti/Sistemi-di-numerazione/Correzione-recupero-debito":{"slug":"Argomenti/Sistemi-di-numerazione/Correzione-recupero-debito","filePath":"Argomenti/Sistemi di numerazione/Correzione recupero debito.md","title":"Correzione recupero debito","links":[],"tags":[],"content":"Fila unica\nConversione da base 10\n 10111011_2 = 2^0+2^1+2^3+2^4+2^5+2^7 = 1+2+8+16+32+128 = 187\nConversione da base 16\n7EB_{16} = (7 \\times 16^2) + (14 \\times 16^1) + (11 \\times 16^0) = (7 \\times 256) + (14 \\times 16) + (11 \\times 1) = 1792 + 224 + 11 = 2027_{10}\nConversione a base 2\n\\begin{align*}\n147 \\div 2 &amp; = 73, \\text{ resto } 1 \\\\\n73 \\div 2 &amp; = 36, \\text{ resto } 1 \\\\\n36 \\div 2 &amp; = 18, \\text{ resto } 0 \\\\\n18 \\div 2 &amp; = 9, \\text{ resto } 0 \\\\\n9 \\div 2 &amp; = 4, \\text{ resto } 1 \\\\\n4 \\div 2 &amp; = 2, \\text{ resto } 0 \\\\\n2 \\div 2 &amp; = 1, \\text{ resto } 0 \\\\\n1 \\div 2 &amp; = 0, \\text{ resto } 1 \\\\\n147_{10} = 10010011_{2}\n\\end{align*}\nConversione a base 16\n\\begin{align*}\n759 \\div 16 &amp; = 47, \\text{ resto } 7 \\\\\n47 \\div 16 &amp; = 2, \\text{ resto } 15 \\\\\n2 \\div 16 &amp; = 0, \\text{ resto } 2 \\\\\n759_{10} = 2F7_{16}\n\\end{align*}\nAritmetica in binario\n11011101 +\n    1111 =\n11101100\n\n11001001 -\n    1111 =\n10111010\n\nNumeri negativi e reali\nComplemento a 2\n\\begin{align*}\n17 \\div 2 &amp; = 8, \\text{ resto } 1 \\\\\n8 \\div 2 &amp; = 4, \\text{ resto } 0 \\\\\n4 \\div 2 &amp; = 2, \\text{ resto } 0 \\\\\n2 \\div 2 &amp; = 1, \\text{ resto } 0 \\\\\n1 \\div 2 &amp; = 0, \\text{ resto } 1 \\\\\n17_{10} = 10001_{2}\\\n\\end{align*}\n010001\n101110 CA1\n101111 CA2\n\n 010001 +\n 101111 =\n1000000\n\nVirgola fissa\n\\begin{align*}\n101110.011_{2} &amp;= (1 \\times 2^5) + (0 \\times 2^4) + (1 \\times 2^3) + (1 \\times 2^2) + (1 \\times 2^1) + (0 \\times 2^0) \\\\\n&amp;\\quad + (0 \\times 2^{-1}) + (1 \\times 2^{-2}) + (1 \\times 2^{-3}) \\\\\n&amp;= (32) + (0) + (8) + (4) + (2) + (0) + (0) + (0.25) + (0.125) \\\\\n&amp;= 47.375_{10}\n\\end{align*}\nVirgola mobile\n0 10001011 00000000000000000101010\n1011 = 2^0+2^1+2^3 = 1+2+8 = 11\n101010=2^1+2^3+2^5=2+8+32=42\n+42\\times2^{-11}"},"Argomenti/Socket/Codice-C-client-TCP":{"slug":"Argomenti/Socket/Codice-C-client-TCP","filePath":"Argomenti/Socket/Codice C client TCP.md","title":"Codice C client TCP","links":[],"tags":[],"content":"#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n  // Crea un socket TCP\n  int sfd = socket(AF_INET, SOCK_STREAM, 0);\n  if (sfd &lt; 0) {\n    perror(&quot;Errore nella creazione del socket&quot;);\n    return 1;\n  }\n\n  // Associa il socket a una porta\n  struct sockaddr_in serv_addr;\n  serv_addr.sin_family = AF_INET;\n  serv_addr.sin_port = htons(1234);\n  serv_addr.sin_addr.s_addr = INADDR_ANY;\n  if (bind(sfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) {\n    perror(&quot;Errore nell&#039;associazione del socket&quot;);\n    return 1;\n  }\n\n  // Ascolta connessioni\n  if (listen(sfd, 5) &lt; 0) {\n    perror(&quot;Errore nell&#039;ascolto delle connessioni&quot;);\n    return 1;\n  }\n\n  // Accetta una connessione\n  int cfd = accept(sfd, NULL, NULL);\n  if (cfd &lt; 0) {\n    perror(&quot;Errore nell&#039;accettazione della connessione&quot;);\n    return 1;\n  }\n\n  // Ricevi una stringa dal client\n  char str[100];\n  int len = recv(cfd, str, sizeof(str), 0);\n  if (len &lt; 0) {\n    perror(&quot;Errore nella ricezione della stringa&quot;);\n    return 1;\n  }\n\n  // Invia l&#039;iniziale della stringa al client\n  char iniziale = str[0];\n  send(cfd, &amp;iniziale, sizeof(iniziale), 0);\n\n  // Chiude la connessione\n  close(cfd);\n  close(sfd);\n\n  return 0;\n}\n"},"Argomenti/Socket/Codice-C-server-TCP":{"slug":"Argomenti/Socket/Codice-C-server-TCP","filePath":"Argomenti/Socket/Codice C server TCP.md","title":"Codice C server TCP","links":[],"tags":[],"content":"#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;arpa/inet.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n  // Crea un socket TCP\n  int sfd = socket(AF_INET, SOCK_STREAM, 0);\n  if (sfd &lt; 0) {\n    perror(&quot;Errore nella creazione del socket&quot;);\n    return 1;\n  }\n\n  // Associa il socket a una porta\n  struct sockaddr_in serv_addr;\n  serv_addr.sin_family = AF_INET;\n  serv_addr.sin_port = htons(1234);\n  serv_addr.sin_addr.s_addr = INADDR_ANY;\n  if (bind(sfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) {\n    perror(&quot;Errore nell&#039;associazione del socket&quot;);\n    return 1;\n  }\n\n  // Ascolta connessioni\n  if (listen(sfd, 5) &lt; 0) {\n    perror(&quot;Errore nell&#039;ascolto delle connessioni&quot;);\n    return 1;\n  }\n\n  // Accetta una connessione\n  int cfd = accept(sfd, NULL, NULL);\n  if (cfd &lt; 0) {\n    perror(&quot;Errore nell&#039;accettazione della connessione&quot;);\n    return 1;\n  }\n\n  // Ricevi una stringa dal client\n  char str[100];\n  int len = recv(cfd, str, sizeof(str), 0);\n  if (len &lt; 0) {\n    perror(&quot;Errore nella ricezione della stringa&quot;);\n    return 1;\n  }\n\n\n  // Invia l&#039;iniziale della stringa al client\n  char iniziale = str[0];\n  send(cfd, &amp;iniziale, sizeof(iniziale), 0);\n\n  // Chiude la connessione\n  close(cfd);\n  close(sfd);\n\n  return 0;\n}\n"},"Argomenti/Socket/Mini-progetti-individuali":{"slug":"Argomenti/Socket/Mini-progetti-individuali","filePath":"Argomenti/Socket/Mini progetti individuali.md","title":"Mini progetti individuali","links":[],"tags":[],"content":"1. Battaglia Navale\n\nObiettivo: Implementare il classico gioco della Battaglia Navale, dove i giocatori dispongono le loro navi su una griglia e cercano di colpire quelle dell’avversario.\nConcetti Chiave: Gestione della griglia, turno per turno, verificare le condizioni di vittoria.\nSfide Tecniche: Sincronizzazione dei turni tra i giocatori, mantenimento dello stato della griglia, implementazione di un sistema di coordinate per le mosse.\n\n2. Tris (Tic-Tac-Toe)\n\nObiettivo: Sviluppare il Tris per due giocatori che si alternano nel posizionare il proprio simbolo su una griglia 3x3, cercando di allineare tre simboli per vincere.\nConcetti Chiave: Controllo della vittoria, gestione semplice della griglia, interfaccia utente basata su testo.\nSfide Tecniche: Implementazione della logica per determinare il vincitore, gestione dei turni e delle mosse dei giocatori.\n\n3. Forza 4\n\nObiettivo: Creare una versione del gioco Forza 4, dove i giocatori inseriscono a turno i propri dischi in una griglia verticale, cercando di allineare quattro dischi.\nConcetti Chiave: Gestione della griglia, verifica delle condizioni di vittoria per linee orizzontali, verticali e diagonali.\nSfide Tecniche: Mantenimento dello stato della griglia, calcolo delle condizioni di vittoria, gestione dei turni.\n\n4. Labirinto Multiplayer\n\nObiettivo: Creare un gioco dove i giocatori navigano attraverso un labirinto per raggiungere un obiettivo, evitando ostacoli o trappole.\nConcetti Chiave: Generazione di labirinti, rilevamento delle collisioni, sincronizzazione delle posizioni dei giocatori.\n\n5. Gara di Digitazione\n\nObiettivo: Creare un gioco di digitazione competitiva dove due giocatori vedono la stessa sequenza di parole sullo schermo e devono digitarle il più velocemente possibile. Il primo a completare la sequenza vince.\nConcetti Chiave: Input di testo in tempo reale, confronto di stringhe, calcolo del tempo di reazione e della velocità di digitazione.\nSfide Tecniche: Misurazione accurata del tempo, sincronizzazione dell’inizio della gara tra i due client, feedback in tempo reale sul progresso dei giocatori.\n\n6. Conquista del Territorio\n\nObiettivo: Creare un gioco di strategia dove i giocatori si alternano per “conquistare” celle in una griglia, cercando di creare una linea continua tra due lati opposti.\nConcetti Chiave: Gestione della griglia, strategia di conquista, controllo delle condizioni di vittoria.\nSfide Tecniche: Implementazione di algoritmi per verificare la formazione di una linea continua, gestione delle sessioni di gioco, sincronizzazione delle mosse.\n"},"Argomenti/Socket/Socket":{"slug":"Argomenti/Socket/Socket","filePath":"Argomenti/Socket/Socket.md","title":"Socket","links":[],"tags":[],"content":"Le funzioni in C usate per i socket sono definite nella libreria standard &lt;sys/socket.h&gt;. Queste funzioni consentono di creare, configurare, utilizzare e chiudere i socket.\nsocket()\nLa funzione socket() viene utilizzata per creare un nuovo socket. I suoi argomenti sono:\n\ndomain: la famiglia di indirizzi del socket. I valori possibili sono:\n\nAF_INET: indirizzi IPv4\nAF_INET6: indirizzi IPv6\nAF_UNIX: indirizzi Unix\n\n\ntype: il tipo di socket. I valori possibili sono:\n\nSOCK_STREAM: socket TCP\nSOCK_DGRAM: socket UDP\nSOCK_RAW: socket RAW\n\n\nprotocol: il protocollo di trasporto da utilizzare. Se impostato a 0, il sistema operativo sceglierà il protocollo appropriato in base al valore di type.\n\nbind()\nLa funzione bind() viene utilizzata per associare un indirizzo e una porta a un socket. I suoi argomenti sono:\n\nsocket: il socket da associare.\naddress: la struttura che contiene l’indirizzo e la porta da associare.\naddress_len: la lunghezza della struttura address.\n\nlisten()\nLa funzione listen() viene utilizzata da un server per indicare che è pronto a ricevere connessioni. Il suo argomento è:\n\nsocket: il socket del server.\nbacklog: il numero massimo di connessioni in attesa.\n\naccept()\nLa funzione accept() viene utilizzata da un server per accettare una connessione da un client. Il suo argomento è:\n\nsocket: il socket del server.\naddress: la struttura che verrà riempita con l’indirizzo e la porta del client.\naddress_len: la lunghezza della struttura address.\n\nconnect()\nLa funzione connect() viene utilizzata da un client per stabilire una connessione con un server. I suoi argomenti sono:\n\nsocket: il socket del client.\naddress: la struttura che contiene l’indirizzo e la porta del server.\naddress_len: la lunghezza della struttura address.\n\nsend()\nLa funzione send() viene utilizzata per inviare dati su un socket. I suoi argomenti sono:\n\nsocket: il socket su cui inviare i dati.\nbuffer: il buffer contenente i dati da inviare.\nlen: la lunghezza dei dati da inviare.\nflags: un flag che indica il tipo di invio.\n\nrecv()\nLa funzione recv() viene utilizzata per ricevere dati da un socket. I suoi argomenti sono:\n\nsocket: il socket da cui ricevere i dati.\nbuffer: il buffer in cui memorizzare i dati ricevuti.\nlen: la lunghezza massima dei dati da ricevere.\nflags: un flag che indica il tipo di ricezione.\n\nclose()\nLa funzione close() viene utilizzata per chiudere un socket. L’argomento è:\n\nsocket: il socket da chiudere.\n\nArgomenti delle funzioni\nGli argomenti delle funzioni per i socket possono essere suddivisi in due categorie:\n\nArgomenti obbligatori: questi argomenti sono necessari per il corretto funzionamento della funzione.\nArgomenti facoltativi: questi argomenti possono essere utilizzati per specificare opzioni aggiuntive.\n\nArgomenti obbligatori\nGli argomenti obbligatori per le funzioni per i socket sono:\n\nsocket: questo argomento è necessario per identificare il socket su cui operare.\n\nArgomenti facoltativi\nGli argomenti facoltativi per le funzioni per i socket sono:\n\ndomain: questo argomento è facoltativo solo per la funzione socket(). Il suo valore predefinito è AF_INET.\ntype: questo argomento è facoltativo solo per la funzione socket(). Il suo valore predefinito è SOCK_STREAM.\nprotocol: questo argomento è facoltativo solo per la funzione socket(). Il suo valore predefinito è 0.\naddress: questo argomento è facoltativo per la funzione bind(). Il suo valore predefinito è NULL, il che significa che il socket non sarà associato a un indirizzo o porta specifici.\naddress_len: questo argomento è facoltativo per la funzione bind(). Il suo valore predefinito è sizeof(struct sockaddr).\nbacklog: questo argomento è facoltativo per la funzione `\n"},"Argomenti/Teoria-di-base/Teoria-di-base,-hardware-e-software":{"slug":"Argomenti/Teoria-di-base/Teoria-di-base,-hardware-e-software","filePath":"Argomenti/Teoria di base/Teoria di base, hardware e software.md","title":"Teoria di base, hardware e software","links":[],"tags":[],"content":"\n\n                  \n                  Crediti \n                  \n                \n\n\nAutore: Davide Daffonchio\nQuesto documento è stato creato con il supporto di un’intelligenza artificiale per facilitare la raccolta e l’organizzazione delle informazioni. L’autore ha verificato e integrato le informazioni per garantire accuratezza e coerenza, ma si raccomanda di consultare fonti aggiuntive e di considerare eventuali aggiornamenti successivi alla stesura. L’uso del contenuto è a scopo informativo e didattico.\nUltimo Aggiornamento: 07-10-2024\n\n\n\nIndice\n \n1. Cos’è un Computer e a Cosa Serve\n1.1 Definizione di Computer\nUn computer, o calcolatore, è un dispositivo elettronico programmabile capace di eseguire operazioni logiche e matematiche complesse in modo automatico. È costituito da una serie di componenti hardware e software che lavorano insieme per elaborare dati e informazioni. La sua funzione principale è quella di ricevere dati in ingresso, elaborarli attraverso una serie di istruzioni predefinite e fornire un risultato o output.\n1.2 Scopi e Funzioni di un Computer\nI computer sono progettati per svolgere una vasta gamma di compiti, che possono variare da operazioni semplici, come la scrittura di documenti, fino a calcoli scientifici complessi. Alcune delle principali funzioni e scopi includono:\n\n\nElaborazione dei Dati: I computer possono processare grandi quantità di dati in modo rapido ed efficiente, rendendoli strumenti indispensabili in settori come la ricerca scientifica, l’economia e l’ingegneria.\n\n\nAutomazione dei Processi: Sono utilizzati per automatizzare processi ripetitivi, come la gestione di magazzini, la produzione industriale e l’elaborazione di transazioni finanziarie.\n\n\nComunicazione: Consentono la trasmissione e la ricezione di informazioni su reti locali e globali, facilitando la comunicazione attraverso e-mail, chat, videoconferenze e altri strumenti digitali.\n\n\nIntrattenimento: I computer sono ampiamente utilizzati per giochi, film, musica e altre forme di intrattenimento digitale.\n\n\nSupporto alla Creatività: Forniscono strumenti per la creazione di contenuti digitali, come grafica, musica, video e scrittura.\n\n\n1.3 Componenti di Base di un Computer\nUn computer è composto principalmente da due categorie di componenti:\n\n\nHardware: Include tutti i componenti fisici del computer, come il processore (CPU), la memoria (RAM), il disco rigido (Hard Disk o SSD), la scheda madre e i dispositivi di input/output (tastiera, mouse, monitor).\n\n\nSoftware: Rappresenta l’insieme dei programmi e delle applicazioni che istruiscono l’hardware su come eseguire determinati compiti. Questo include i sistemi operativi (come Windows, macOS, Linux) e i software applicativi (come word processor, fogli di calcolo, browser).\n\n\n2. Architettura di Von Neumann\n2.1 Cos’è l’Architettura di Von Neumann\nL’architettura di Von Neumann è un modello teorico che descrive la struttura di base di un computer. È stata proposta dal matematico John von Neumann negli anni ‘40 ed è alla base della maggior parte dei computer moderni. Questo modello definisce come un computer deve essere organizzato e come deve elaborare le informazioni.\n2.2 Componenti Principali dell’Architettura di Von Neumann\nL’architettura di Von Neumann prevede che un computer sia composto da quattro componenti principali:\n\n\nUnità Centrale di Elaborazione (CPU): È il cervello del computer, dove vengono eseguite le istruzioni dei programmi. La CPU è divisa a sua volta in:\n\nUnità di Controllo (Control Unit): Coordina e gestisce l’esecuzione delle istruzioni.\nUnità Aritmetico-Logica (ALU): Esegue operazioni matematiche e logiche.\n\n\n\nMemoria: È il luogo in cui vengono archiviati sia i dati che le istruzioni del programma. La stessa memoria viene utilizzata sia per i dati che per le istruzioni, consentendo alla CPU di accedervi rapidamente.\n\n\nDispositivi di Input/Output (I/O): Permettono al computer di comunicare con l’esterno. I dispositivi di input includono tastiera e mouse, mentre i dispositivi di output includono monitor e stampanti.\n\n\nBus di Sistema: Un insieme di canali che permette il trasferimento di dati e istruzioni tra la CPU, la memoria e i dispositivi di I/O.\n\n\n2.3 Importanza dell’Architettura di Von Neumann\nL’architettura di Von Neumann è fondamentale perché definisce un modello standard per la costruzione e il funzionamento dei computer. Nonostante i progressi tecnologici, la struttura di base di tutti i moderni computer segue ancora i principi di questo modello.\n3. La CPU: Unità Centrale di Elaborazione\n3.1 Cos’è la CPU\nLa CPU (Central Processing Unit), o Unità Centrale di Elaborazione, è il componente principale del computer responsabile dell’esecuzione delle istruzioni dei programmi. È spesso considerata il “cervello” del computer, poiché coordina tutte le operazioni del sistema, eseguendo calcoli e gestendo il flusso di dati tra i diversi componenti.\n3.2 Componenti Principali della CPU\nLa CPU è costituita da diverse unità interne che collaborano per eseguire le istruzioni:\n\n\nUnità di Controllo (Control Unit): Dirige il flusso di dati e comandi tra la CPU e gli altri componenti del computer. Interpreta le istruzioni dei programmi e le trasforma in segnali di controllo che guidano le operazioni dell’intero sistema.\n\n\nUnità Aritmetico-Logica (ALU - Arithmetic Logic Unit): È responsabile dell’esecuzione delle operazioni matematiche (come addizioni e sottrazioni) e logiche (come AND, OR e confronti) sui dati.\n\n\nRegistri: Piccole unità di memoria interne alla CPU utilizzate per memorizzare temporaneamente dati e istruzioni durante l’elaborazione. I registri permettono un accesso estremamente rapido alle informazioni necessarie per le operazioni della CPU.\n\n\nCache: Memoria ad alta velocità situata all’interno o vicino alla CPU che immagazzina temporaneamente i dati e le istruzioni usati più di frequente. La cache riduce i tempi di accesso alla memoria principale, migliorando le prestazioni complessive del sistema.\n\n\n3.3 Come Funziona la CPU\nIl funzionamento della CPU può essere suddiviso in tre fasi principali, che formano il ciclo di esecuzione delle istruzioni:\n\n\nFetch (Prelievo): La CPU preleva un’istruzione dalla memoria principale (RAM) e la carica in un registro interno.\n\n\nDecode (Decodifica): L’istruzione prelevata viene decodificata dall’unità di controllo, che la trasforma in una serie di segnali di controllo per le operazioni che devono essere eseguite.\n\n\nExecute (Esecuzione): L’ALU esegue l’operazione specificata dall’istruzione (ad esempio, un calcolo matematico o un’operazione logica). Il risultato dell’operazione viene quindi memorizzato nei registri o inviato alla memoria.\n\n\n3.4 Frequenza e Prestazioni della CPU\nLe prestazioni di una CPU sono determinate da diversi fattori, tra cui:\n\n\nFrequenza di Clock: Misurata in Hertz (Hz), indica il numero di operazioni che la CPU può eseguire in un secondo. Una frequenza più alta generalmente corrisponde a una maggiore velocità di elaborazione.\n\n\nNumero di Core: Una CPU può avere più core, ossia unità di elaborazione indipendenti. Più core consentono al computer di eseguire più istruzioni contemporaneamente, migliorando le prestazioni in attività parallele o multitasking.\n\n\nArchitettura: L’architettura della CPU determina come vengono organizzate le unità interne e come vengono gestite le istruzioni. I progressi nell’architettura possono migliorare l’efficienza e le prestazioni anche a parità di frequenza di clock.\n\n\n3.5 Evoluzione delle CPU\nLe CPU sono evolute notevolmente nel corso del tempo, passando da processori a singolo core a processori multi-core con tecnologie avanzate come l’hyper-threading e l’architettura a 64 bit. Questi sviluppi hanno permesso di migliorare drasticamente le prestazioni e la capacità di elaborazione dei computer moderni.\n3.6 La Cache della CPU\nLa cache è una memoria estremamente veloce integrata nella CPU o posizionata nelle sue immediate vicinanze, progettata per migliorare le prestazioni riducendo i tempi di accesso ai dati e alle istruzioni. La cache agisce come un’interfaccia tra la CPU e la memoria principale (RAM), immagazzinando temporaneamente le informazioni più frequentemente utilizzate, in modo che la CPU possa accedervi rapidamente senza dover attendere il recupero dalla RAM, che è relativamente più lenta.\n3.6.1 Livelli di Cache\nLa cache della CPU è generalmente organizzata in più livelli, ciascuno con caratteristiche specifiche:\n\n\nCache L1 (Livello 1):\n\nÈ il livello di cache più piccolo e più veloce, direttamente integrato nel core della CPU.\nTipicamente suddivisa in due parti: una per le istruzioni (Instruction Cache) e una per i dati (Data Cache).\nHa una capacità che varia solitamente tra 32 KB e 128 KB per core.\nLa latenza (il tempo necessario per accedere ai dati) è molto bassa, solitamente di pochi cicli di clock.\n\n\n\nCache L2 (Livello 2):\n\nPiù grande rispetto alla cache L1, ma leggermente più lenta.\nLa capacità può variare da 256 KB a diversi MB per core.\nIn alcune architetture moderne, la cache L2 è condivisa tra più core all’interno della stessa CPU.\nServe come ulteriore livello di buffer per ridurre il carico sulla cache L1.\n\n\n\nCache L3 (Livello 3):\n\nGeneralmente condivisa tra tutti i core della CPU.\nPiù grande ma anche più lenta rispetto ai livelli L1 e L2, con capacità che possono raggiungere decine di MB.\nAgisce come una riserva di dati e istruzioni che non possono essere contenuti nelle cache L1 e L2.\n\n\n\nCache L4 (Livello 4):\n\nPresente solo in alcune architetture specifiche.\nPuò essere posizionata all’esterno della CPU ma comunque molto vicina, spesso implementata sulla scheda madre.\nServe come un ulteriore strato di buffer per dati e istruzioni di grandi dimensioni o meno frequentemente utilizzati.\n\n\n\n3.6.2 Funzionamento della Cache\nIl funzionamento della cache si basa su un principio chiamato località spaziale e temporale:\n\n\nLocalità Temporale: Se un dato o un’istruzione è stato utilizzato recentemente, è probabile che venga utilizzato di nuovo a breve. La cache conserva queste informazioni per un accesso rapido.\n\n\nLocalità Spaziale: Se un dato o un’istruzione è stato utilizzato, è probabile che i dati circostanti vengano utilizzati presto. Per questo motivo, la cache carica blocchi di dati (noti come cache lines) dalla memoria principale, non solo i dati specifici richiesti.\n\n\n3.6.3 Politiche di Gestione della Cache\nLa gestione della cache implica diverse politiche per ottimizzare l’uso dello spazio disponibile:\n\n\nPolitiche di Sostituzione: Determinano quali dati devono essere rimossi dalla cache quando è necessario fare spazio per nuovi dati. Una delle più comuni è la politica LRU (Least Recently Used), che rimuove i dati utilizzati meno di recente.\n\n\nPolitiche di Scrittura:\n\nWrite-Through: Ogni volta che la cache viene aggiornata, il dato viene scritto contemporaneamente anche nella memoria principale.\nWrite-Back: I dati vengono scritti nella memoria principale solo quando devono essere rimossi dalla cache, riducendo il traffico verso la memoria.\n\n\n\n3.6.4 Importanza della Cache nelle Prestazioni\nUna cache ben progettata può migliorare drasticamente le prestazioni della CPU, poiché riduce la necessità di attendere l’accesso ai dati dalla memoria principale. Questo consente alla CPU di eseguire le istruzioni più rapidamente e di gestire meglio operazioni complesse o processi multitasking.\n4. La RAM: Memoria ad Accesso Casuale\n4.1 Cos’è la RAM\nLa RAM (Random Access Memory), o memoria ad accesso casuale, è un tipo di memoria volatile utilizzata dai computer per immagazzinare temporaneamente i dati e le istruzioni necessari per l’esecuzione dei programmi in corso. A differenza della memoria permanente (come l’hard disk o l’SSD), la RAM perde tutte le informazioni immagazzinate quando il computer viene spento. Questo succede perché la RAM memorizza i dati esclusivamente con l’elettricità, questo la rende estremamente più veloce di una memoria permanente.\n4.2 Funzione della RAM\nLa RAM svolge un ruolo fondamentale nelle prestazioni complessive del sistema. Agisce come una sorta di spazio di lavoro temporaneo per la CPU, permettendo un accesso rapido ai dati necessari per eseguire le operazioni. Più RAM è disponibile, maggiore è la quantità di dati e programmi che possono essere gestiti simultaneamente, riducendo la necessità di accedere frequentemente alla memoria di massa, che è molto più lenta.\n4.3 Tipi di RAM\nEsistono vari tipi di RAM utilizzati nei computer:\n\n\nDRAM (Dynamic RAM):\n\nÈ il tipo di RAM più comune utilizzato nei computer.\nI dati vengono immagazzinati in condensatori che richiedono un refresh continuo per mantenere le informazioni, da cui il termine “dinamica”.\nViene utilizzata come memoria principale nei computer.\n\n\n\nSRAM (Static RAM):\n\nPiù veloce e costosa rispetto alla DRAM.\nNon richiede il refresh continuo dei dati, rendendola più veloce.\nViene solitamente utilizzata come memoria cache nella CPU.\n\n\n\nDDR (Double Data Rate) RAM:\n\nEvoluzione della DRAM, in grado di trasferire dati due volte per ciclo di clock, raddoppiando la velocità di trasferimento.\nLe versioni più recenti, come DDR3, DDR4 e DDR5, offrono capacità e velocità sempre maggiori, oltre a un consumo energetico ridotto.\n\n\n\n4.4 Caratteristiche della RAM\nLe principali caratteristiche tecniche della RAM includono:\n\n\nCapacità:\n\nMisurata in gigabyte (GB), indica la quantità di dati che la RAM può contenere. Una maggiore capacità permette di eseguire più applicazioni simultaneamente senza rallentamenti.\n\n\n\nVelocità (frequenza):\n\nMisurata in megahertz (MHz), indica la velocità con cui la RAM può leggere e scrivere dati. Una RAM più veloce migliora le prestazioni complessive del sistema.\n\n\n\nLatenza:\n\nRappresenta il tempo necessario affinché la RAM risponda a una richiesta di dati. Una latenza più bassa indica un accesso più rapido ai dati.\n\n\n\n4.5 Funzionamento della RAM nel Sistema\nQuando avvii un programma o apri un file, il sistema operativo carica i dati necessari dalla memoria permanente (come un hard disk) alla RAM. Questo consente alla CPU di accedere rapidamente alle informazioni richieste, evitando i lunghi tempi di attesa associati al recupero diretto dei dati dalla memoria di massa. Una volta che i dati non sono più necessari, vengono rimossi dalla RAM per fare spazio a nuove informazioni.\n4.6 Importanza della RAM nelle Prestazioni\nLa quantità e la velocità della RAM influiscono direttamente sulle prestazioni del computer. Una RAM insufficiente può portare a rallentamenti, poiché il sistema deve utilizzare file di paging su disco, che sono molto più lenti rispetto all’accesso diretto alla RAM. Questo è particolarmente evidente quando si eseguono più applicazioni contemporaneamente o quando si gestiscono programmi che richiedono molta memoria, come software di editing video o videogiochi.\n4.7 RAM e Memoria Virtuale\nQuando la RAM disponibile non è sufficiente per gestire tutti i processi attivi, il sistema operativo utilizza la memoria virtuale, che consente di utilizzare parte della memoria di massa come estensione della RAM. Questo processo, però, è molto più lento rispetto all’uso della RAM fisica, poiché l’accesso ai dati su disco richiede più tempo.\n5. La ROM: Memoria di Sola Lettura\n5.1 Cos’è la ROM\nLa ROM (Read-Only Memory) è una memoria permanente che conserva permanentemente i dati e le istruzioni anche quando il computer è spento. Come suggerisce il nome, è progettata per consentire solo la lettura dei dati, il che significa che una volta scritti, i dati non possono essere facilmente modificati o cancellati. Viene utilizzata principalmente per memorizzare il firmware, ovvero il software di base che controlla l’hardware del sistema.\n5.2 Funzioni della ROM\nLa ROM svolge un ruolo essenziale nel funzionamento di qualsiasi dispositivo informatico, soprattutto durante la fase di avvio e inizializzazione del sistema. Alcune delle principali funzioni includono:\n\nAvvio del Sistema: Contiene il firmware o il BIOS (Basic Input/Output System), che viene eseguito all’accensione del computer per testare l’hardware e avviare il sistema operativo (se presente sulla memoria di massa).\nConservazione di Istruzioni di Base: Memorizza le istruzioni fondamentali necessarie per l’operatività del sistema, come i protocolli di comunicazione tra componenti hardware e il controllo delle periferiche di input/output.\n\n5.3 Differenze tra ROM e RAM\n\nPersistenza dei Dati: La ROM conserva i dati in modo permanente, mentre la RAM è una memoria volatile che perde tutte le informazioni quando il dispositivo viene spento.\nModificabilità: I dati contenuti nella ROM sono pre-programmati e non possono essere facilmente modificati, mentre la RAM può essere letta e scritta continuamente durante l’esecuzione dei programmi.\nFunzione: La ROM è utilizzata per memorizzare il software di base del sistema (firmware) e altre informazioni critiche che non devono essere cambiate, mentre la RAM è utilizzata per memorizzare temporaneamente i dati dei programmi in esecuzione.\n\n5.4 Importanza della ROM\nLa ROM è fondamentale per il funzionamento di un computer poiché contiene le istruzioni necessarie per avviare il sistema e garantire il corretto funzionamento dell’hardware. Senza la ROM, un computer non sarebbe in grado di eseguire l’inizializzazione del sistema né di caricare il sistema operativo.\n6. Memoria Secondaria\n6.1 Cos’è la Memoria Secondaria\nLa memoria secondaria, o memoria di massa, è un tipo di memoria non volatile utilizzata per immagazzinare dati e programmi in modo permanente, anche quando il computer è spento. A differenza della RAM, la memoria secondaria conserva le informazioni a lungo termine e offre una capacità di archiviazione molto maggiore. È utilizzata per conservare il sistema operativo, i software applicativi, i file degli utenti e altri dati essenziali.\n6.2 Tipi di Memoria Secondaria\nEsistono diversi tipi di memoria secondaria, ciascuno con caratteristiche e usi specifici:\n6.2.1 Hard Disk Drive (HDD)\n\nDescrizione: È un dispositivo di archiviazione meccanico che utilizza piatti magnetici rotanti e una testina di lettura/scrittura per accedere ai dati.\nCaratteristiche:\n\nCapacità: Alta, fino a diversi terabyte (TB).\nVelocità: Relativamente bassa rispetto agli SSD; i tempi di accesso dipendono dalla velocità di rotazione (tipicamente 5400 o 7200 giri/minuto).\nDurata: Sensibili a urti e danni fisici, ma offrono una lunga durata se mantenuti in buone condizioni.\n\n\nVantaggi: Elevata capacità a un costo per gigabyte relativamente basso.\nSvantaggi: Maggiore lentezza rispetto agli SSD e vulnerabilità agli urti e alle vibrazioni.\n\n6.2.2 Solid State Drive (SSD)\n\nDescrizione: Utilizza memorie flash per archiviare dati, senza parti mobili. Gli SSD sono molto più veloci rispetto agli HDD tradizionali.\nCaratteristiche:\n\nCapacità: Da alcune centinaia di gigabyte fino a diversi terabyte.\nVelocità: Molto elevata, con tempi di accesso ai dati quasi immediati.\nDurata: Maggiore resistenza a urti e vibrazioni rispetto agli HDD, ma il numero di scritture su ciascuna cella di memoria è limitato.\n\n\nVantaggi: Velocità di lettura e scrittura elevate, miglioramento delle prestazioni complessive del sistema, maggiore durata in condizioni di utilizzo normale.\nSvantaggi: Costo per gigabyte più elevato rispetto agli HDD.\n\n6.2.3 Unità Ibride (SSHD - Solid State Hybrid Drive)\n\nDescrizione: Combinano un HDD tradizionale con una piccola quantità di memoria SSD. Usano l’SSD per archiviare i dati più frequentemente usati, migliorando le prestazioni rispetto a un HDD puro.\nCaratteristiche:\n\nCapacità: Simile agli HDD, ma con una piccola porzione (tipicamente 8-16 GB) dedicata alla memoria SSD.\nVelocità: Migliore rispetto agli HDD, specialmente per l’accesso ai dati più utilizzati.\nDurata: Combina i vantaggi di durata dell’HDD con i tempi di accesso più rapidi dell’SSD.\n\n\nVantaggi: Compromesso tra velocità e capacità a un costo contenuto.\nSvantaggi: Non raggiunge le prestazioni di un SSD puro.\n\n6.2.4 Dispositivi Ottici\n\nDescrizione: Utilizzano supporti fisici come CD, DVD o Blu-ray per l’archiviazione dei dati.\nCaratteristiche:\n\nCapacità: Fino a 700 MB per i CD, 4,7-8,5 GB per i DVD e fino a 100 GB per i Blu-ray.\nVelocità: Relativamente bassa rispetto agli HDD e agli SSD.\nDurata: I supporti ottici sono soggetti a degrado fisico e graffi, che possono comprometterne l’integrità.\n\n\nVantaggi: Ideali per l’archiviazione a lungo termine e la distribuzione di software e contenuti multimediali.\nSvantaggi: Capacità e velocità limitate, uso ridotto nei dispositivi moderni.\n\n6.2.5 Unità USB e Schede di Memoria\n\nDescrizione: Dispositivi portatili basati su memoria flash utilizzati per il trasferimento e l’archiviazione temporanea di dati.\nCaratteristiche:\n\nCapacità: Da pochi gigabyte a oltre un terabyte.\nVelocità: Varia a seconda dello standard (USB 2.0, 3.0, 3.1) ma comunque più lenta di una memoria interna.\nDurata: Buona resistenza agli urti e all’uso frequente.\n\n\nVantaggi: Portabilità e facilità d’uso.\nSvantaggi: Facilmente smarribili e, a volte, soggetti a usura della memoria flash.\n\n6.3 Importanza della Memoria Secondaria\nLa memoria secondaria è essenziale per il funzionamento del computer, poiché consente di immagazzinare in modo permanente il sistema operativo, i programmi e i dati degli utenti. Senza memoria secondaria, il computer perderebbe tutte le informazioni al momento dello spegnimento e sarebbe impossibile eseguire operazioni a lungo termine.\n6.4 Gerarchia della Memoria\nNel sistema informatico, la memoria è organizzata in una gerarchia, dove la RAM è più vicina alla CPU e più veloce, mentre la memoria secondaria è più lenta ma offre una capacità molto maggiore. La gestione efficiente di questa gerarchia è fondamentale per ottimizzare le prestazioni complessive del sistema.\n7. La Scheda Video\n7.1 Cos’è la Scheda Video\nLa scheda video, nota anche come GPU (Graphics Processing Unit) o scheda grafica, è un componente hardware del computer dedicato all’elaborazione e alla gestione delle immagini e dei video. La sua funzione principale è quella di convertire i dati digitali elaborati dalla CPU in segnali visivi che possono essere visualizzati sul monitor. È fondamentale per attività che richiedono una grafica avanzata, come la progettazione grafica, i videogiochi e l’elaborazione video.\n7.2 Funzioni Principali della Scheda Video\n\nRendering Grafico: La scheda video elabora le immagini e i video da visualizzare, occupandosi del rendering 2D e 3D. Questo include la gestione di ombre, luci, texture e animazioni complesse.\nAccelerazione Hardware: Migliora le prestazioni di applicazioni che richiedono un’alta potenza di calcolo grafico, come software di editing video, modellazione 3D e simulazioni.\nElaborazione Parallela: Le GPU sono progettate per eseguire calcoli in parallelo, rendendole molto efficienti per operazioni che richiedono l’elaborazione simultanea di grandi quantità di dati, come il machine learning e l’intelligenza artificiale.\n\n7.3 Componenti Principali di una Scheda Video\n\nGPU (Graphics Processing Unit): Il processore grafico che esegue i calcoli necessari per il rendering delle immagini.\nVRAM (Video RAM): Memoria ad alta velocità utilizzata per immagazzinare dati grafici come texture, modelli 3D e framebuffer. Una maggiore quantità di VRAM consente alla scheda video di gestire immagini più complesse e a risoluzioni più elevate.\nOutput Video: Porte di connessione (HDMI, DisplayPort, DVI, VGA) che permettono di collegare la scheda video ai monitor e ad altri dispositivi di visualizzazione.\nRaffreddamento: Sistemi di raffreddamento, come ventole e dissipatori, per mantenere la GPU a temperature operative sicure durante l’elaborazione grafica intensiva.\n\n7.4 Schede Video Dedicata vs. Integrata\nEsistono due principali tipologie di schede video:\n\n\nScheda Video Dedicata:\n\nÈ un componente autonomo, separato dalla scheda madre, con una propria GPU e VRAM.\nOffre prestazioni grafiche superiori, essendo progettata specificamente per l’elaborazione grafica.\nIdeale per giochi, progettazione grafica, rendering 3D e altre applicazioni ad alte prestazioni.\n\n\n\nScheda Video Integrata:\n\nÈ integrata nella CPU o nella scheda madre e condivide la memoria RAM del sistema.\nHa prestazioni grafiche inferiori rispetto alle schede video dedicate, ma consuma meno energia e produce meno calore.\nAdatta per attività quotidiane come la navigazione web, la riproduzione di video e l’uso di applicazioni di produttività.\n\n\n\nLe schede video integrate sono spesso utilizzate nei computer portatili e nei PC di fascia bassa o media, dove l’efficienza energetica e il costo sono più importanti delle prestazioni grafiche. Sebbene non siano ideali per applicazioni che richiedono molta potenza di calcolo grafico, le moderne GPU integrate, come quelle delle famiglie Intel UHD o AMD Radeon Vega, sono sufficientemente potenti per supportare la riproduzione video ad alta definizione, il rendering grafico di base e alcuni giochi leggeri.\n8. La Scheda Madre e il Bus di Sistema\n8.1 Cos’è la Scheda Madre\nLa scheda madre (o motherboard) è il principale circuito stampato di un computer, che ospita e connette tra loro tutti i componenti essenziali del sistema. È il centro di comunicazione e gestione dell’hardware, permettendo a CPU, RAM, scheda video, dispositivi di archiviazione e periferiche di interagire tra loro in modo coordinato.\n8.2 Componenti Principali della Scheda Madre\n\n\nSocket della CPU: Alloggiamento per il processore (CPU). Il tipo di socket determina quali modelli di CPU possono essere installati sulla scheda madre.\n\n\nSlot di Memoria (RAM): Slot per l’installazione dei moduli di memoria RAM. Il numero e il tipo di slot determinano la quantità e il tipo di RAM supportata.\n\n\nChipset: Insieme di circuiti integrati che gestisce la comunicazione tra la CPU, la memoria e i dispositivi di I/O. Il chipset è responsabile di determinare molte delle funzionalità della scheda madre, come il supporto per le porte USB, SATA, PCIe e altre interfacce.\n\n\nSlot di Espansione: Slot PCIe (Peripheral Component Interconnect Express) utilizzati per installare schede aggiuntive, come schede video, schede audio, schede di rete e SSD NVMe.\n\n\nPorte di Input/Output (I/O): Porte situate sul retro della scheda madre per connettere dispositivi esterni come mouse, tastiere, monitor, dispositivi USB e cavi di rete.\n\n\nConnettori di Alimentazione: Connettori che forniscono energia alla scheda madre e ai suoi componenti, come il connettore ATX principale e quello per la CPU.\n\n\nBIOS/UEFI: Chip di memoria che contiene il firmware di base del sistema, utilizzato per avviare il computer e configurare le impostazioni hardware.\n\n\nConnettori SATA e M.2: Utilizzati per collegare dispositivi di archiviazione come hard disk, SSD e unità ottiche.\n\n\n8.3 Funzioni della Scheda Madre\nLa scheda madre ha il compito di:\n\nConnessione e Comunicazione: Collegare e far comunicare tutti i componenti del computer attraverso il bus di sistema e altri collegamenti.\nGestione dell’Energia: Distribuire energia elettrica ai componenti attraverso il circuito di alimentazione.\nConfigurazione e Controllo: Permettere la configurazione dell’hardware tramite il BIOS/UEFI e controllare l’avvio del sistema.\n\n8.4 Il Bus di Sistema\n8.4.1 Cos’è il Bus di Sistema\nIl bus di sistema è un insieme di percorsi fisici (linee elettriche) sulla scheda madre che permette la comunicazione tra i vari componenti del computer, come CPU, memoria e dispositivi di input/output. Il bus trasporta dati, indirizzi e segnali di controllo tra le varie parti del sistema.\n8.4.2 Tipologie di Bus\n\n\nBus Dati:\n\nTrasporta i dati tra la CPU e gli altri componenti.\nLa sua larghezza, misurata in bit (ad esempio, 32 o 64 bit), determina la quantità di dati che possono essere trasferiti simultaneamente.\n\n\n\nBus degli Indirizzi:\n\nTrasporta gli indirizzi di memoria, indicando dove i dati devono essere letti o scritti.\nLa larghezza del bus degli indirizzi determina la quantità massima di memoria indirizzabile.\n\n\n\nBus di Controllo:\n\nTrasporta segnali di controllo e comandi per coordinare le operazioni dei vari componenti del sistema, come lettura/scrittura di memoria o comunicazione con periferiche.\n\n\n\n8.4.3 Tipi di Bus sulla Scheda Madre\n\n\nBus di Sistema (Front Side Bus - FSB):\n\nCollegava tradizionalmente la CPU al chipset della scheda madre, in particolare al Northbridge. Questo bus era responsabile della comunicazione tra la CPU, la RAM e altri componenti ad alta velocità.\nNelle architetture moderne, il FSB è stato sostituito da collegamenti diretti come il bus DMI (Direct Media Interface) o HyperTransport.\n\n\n\nBus PCIe (Peripheral Component Interconnect Express):\n\nUtilizzato per collegare schede di espansione ad alta velocità come schede video, schede di rete e SSD NVMe.\nOffre una comunicazione diretta con la CPU e il chipset, permettendo velocità di trasferimento dati molto elevate.\n\n\n\nBus SATA:\n\nUtilizzato per collegare dispositivi di archiviazione come hard disk, SSD e unità ottiche alla scheda madre.\nPermette la trasmissione dei dati tra questi dispositivi e il sistema.\n\n\n\nBus USB:\n\nConsente la comunicazione tra il computer e le periferiche esterne come mouse, tastiere, stampanti e unità di memoria esterne.\n\n\n\n9. Periferiche di Input e Output\n9.1 Cosa Sono le Periferiche di Input e Output\nLe periferiche di input e output (I/O) sono dispositivi che consentono al computer di interagire con il mondo esterno, permettendo agli utenti di inserire dati nel sistema (input) e di ricevere informazioni elaborate dal sistema (output). Queste periferiche sono essenziali per l’utilizzo quotidiano del computer e possono variare da dispositivi semplici, come tastiere e monitor, a sistemi più complessi, come scanner e stampanti 3D.\n9.2 Periferiche di Input\nLe periferiche di input sono dispositivi utilizzati per immettere dati e comandi nel computer. Ecco i principali tipi:\n\n\nTastiera:\n\nConsente di inserire dati alfanumerici e comandi attraverso i tasti.\nPuò includere tasti aggiuntivi per funzioni specifiche, come tasti multimediali o tasti di scelta rapida.\n\n\n\nMouse:\n\nDispositivo di puntamento che permette di muovere un cursore sullo schermo e di selezionare elementi tramite clic.\nPuò essere dotato di funzionalità aggiuntive come tasti laterali, rotella di scorrimento e sensori ottici o laser.\n\n\n\nTouchpad:\n\nSuperficie sensibile al tocco utilizzata come alternativa al mouse, comunemente presente nei computer portatili.\nPermette di muovere il cursore e di eseguire azioni attraverso gesti tattili.\n\n\n\nScanner:\n\nDispositivo che digitalizza documenti cartacei o immagini, trasformandoli in file digitali.\nUtilizzato per archiviare documenti o elaborare immagini grafiche.\n\n\n\nMicrofono:\n\nPermette di inserire input audio nel sistema, utilizzato per registrare suoni, comunicazioni vocali o per applicazioni di riconoscimento vocale.\n\n\n\nFotocamera/Webcam:\n\nDispositivo di acquisizione video utilizzato per scattare fotografie, registrare video o partecipare a videoconferenze.\n\n\n\nDispositivi di Puntamento Avanzati:\n\nComprendono tavolette grafiche, joystick, trackball e altri dispositivi specializzati per applicazioni di disegno, giochi e modellazione 3D.\n\n\n\nScanner di Codici a Barre e Lettori RFID:\n\nUtilizzati per la lettura di codici a barre o tag RFID, comuni in applicazioni commerciali e di gestione inventariale.\n\n\n\n9.3 Periferiche di Output\nLe periferiche di output permettono di visualizzare, ascoltare o ottenere informazioni elaborate dal computer. I principali dispositivi includono:\n\n\nMonitor:\n\nDispositivo di visualizzazione che mostra l’interfaccia utente grafica e i contenuti elaborati dal computer.\nI monitor variano per dimensioni, risoluzione e tecnologie di visualizzazione (LCD, LED, OLED).\n\n\n\nStampante:\n\nDispositivo che trasforma i documenti digitali in copie cartacee.\nEsistono vari tipi di stampanti, come quelle a getto d’inchiostro, laser e 3D, utilizzate per scopi specifici.\n\n\n\nAltoparlanti e Cuffie:\n\nTrasformano i segnali audio digitali in suoni udibili.\nUtilizzati per ascoltare musica, film, comunicazioni vocali o segnali di sistema.\n\n\n\nPlotter:\n\nDispositivo di output utilizzato per la stampa di disegni tecnici e grafici su larga scala.\nComuni in ambiti come l’ingegneria e l’architettura.\n\n\n\nProiettore:\n\nDispositivo che proietta immagini o video su una superficie più ampia, come uno schermo o una parete.\nUtilizzato in presentazioni, conferenze e ambienti educativi.\n\n\n\n9.4 Periferiche Ibride (Input/Output)\nEsistono anche periferiche che combinano le funzionalità di input e output in un unico dispositivo:\n\n\nTouchscreen:\n\nConsente di visualizzare informazioni e, contemporaneamente, di interagire con il sistema tramite il tocco.\nUtilizzato comunemente in smartphone, tablet, bancomat e schermi interattivi.\n\n\n\nStampanti Multifunzionali:\n\nCombina le funzionalità di stampa (output), scansione (input) e copia in un unico dispositivo.\nUtilizzata in uffici e ambienti domestici per gestire varie esigenze documentali.\n\n\n\n10. L’Alimentatore\n10.1 Cos’è l’Alimentatore\nL’alimentatore (PSU - Power Supply Unit) è un componente essenziale del computer che converte la corrente elettrica proveniente dalla rete elettrica in energia utilizzabile per alimentare i vari componenti del sistema. È responsabile di fornire la giusta quantità di energia elettrica, con le tensioni e i livelli di potenza appropriati, per garantire il funzionamento corretto e stabile del computer.\n10.2 Funzioni dell’Alimentatore\nL’alimentatore svolge diverse funzioni cruciali per il corretto funzionamento del sistema:\n\n\nConversione della Corrente Alternata (AC) in Corrente Continua (DC):\n\nLa corrente elettrica fornita dalle prese domestiche è in corrente alternata (AC), mentre i componenti interni del computer richiedono corrente continua (DC). L’alimentatore converte la corrente AC in DC con diversi livelli di tensione (tipicamente 3.3V, 5V e 12V).\n\n\n\nDistribuzione dell’Energia:\n\nFornisce energia a tutti i componenti del computer, inclusi la scheda madre, il processore (CPU), la scheda video (GPU), le unità di archiviazione e le periferiche.\n\n\n\nProtezione dei Componenti:\n\nL’alimentatore offre protezione contro sovratensioni, sovraccarichi e cortocircuiti, evitando danni ai componenti interni del computer.\n\n\n\n10.3 Caratteristiche Principali dell’Alimentatore\n\n\nPotenza Nominale (Watt):\n\nLa potenza di un alimentatore è espressa in watt (W) e rappresenta la quantità massima di energia che può fornire al sistema. Un alimentatore deve avere una potenza sufficiente per supportare tutti i componenti del computer. Ad esempio, un PC per ufficio potrebbe necessitare di 300-400 W, mentre un PC da gaming o workstation potrebbe richiedere 600-1000 W o più.\n\n\n\nEfficienza Energetica:\n\nL’efficienza di un alimentatore indica quanto della potenza prelevata dalla rete viene effettivamente convertita in energia utilizzabile, mentre il resto viene disperso sotto forma di calore. Un alimentatore efficiente riduce il consumo energetico e il calore prodotto. Gli alimentatori certificati 80 PLUS garantiscono un’efficienza minima dell’80% a vari carichi di lavoro.\n\n\n\nForm Factor:\n\nIndica le dimensioni e la compatibilità dell’alimentatore con il case del computer. Il formato più comune è l’ATX, ma esistono anche formati più piccoli, come il SFX, utilizzati per PC compatti.\n\n\n\nConnettori:\n\nGli alimentatori sono dotati di diversi connettori per alimentare i vari componenti:\n\nConnettore ATX a 24 pin: Fornisce energia alla scheda madre.\nConnettore EPS a 4/8 pin: Alimenta la CPU.\nConnettori PCIe a 6/8 pin: Utilizzati per alimentare le schede grafiche dedicate.\nConnettori SATA e Molex: Per dischi rigidi, SSD, unità ottiche e altre periferiche.\n\n\n\n\n\n10.4 Tipologie di Alimentatori\n\n\nAlimentatori Non Modulari:\n\nTutti i cavi sono collegati permanentemente all’alimentatore. Sono meno costosi, ma possono risultare ingombranti all’interno del case, poiché i cavi non necessari non possono essere rimossi.\n\n\n\nAlimentatori Semi-Modulari:\n\nAlcuni cavi, come il connettore principale della scheda madre e della CPU, sono fissi, mentre altri (per esempio i cavi PCIe e SATA) possono essere collegati o scollegati secondo necessità. Offrono un compromesso tra gestione dei cavi e prezzo.\n\n\n\nAlimentatori Modulari:\n\nTutti i cavi possono essere collegati o scollegati in base alle esigenze del sistema. Questo facilita la gestione dei cavi e migliora il flusso d’aria all’interno del case, rendendo più ordinato l’interno del computer.\n\n\n\n10.5 Importanza dell’Alimentatore nelle Prestazioni del Sistema\nUn alimentatore di buona qualità è fondamentale per garantire la stabilità e la sicurezza del sistema. Un alimentatore sottodimensionato o di bassa qualità può causare problemi di stabilità, spegnimenti improvvisi e persino danneggiare i componenti. Inoltre, un alimentatore con un’efficienza energetica elevata contribuisce a ridurre i costi energetici e a mantenere temperature più basse all’interno del case.\n10.6 Scelta dell’Alimentatore\nLa scelta dell’alimentatore deve basarsi sulle esigenze del sistema, considerando la potenza richiesta dai componenti e le eventuali necessità future (come upgrade di schede video o aggiunta di periferiche). È consigliabile scegliere un alimentatore con una potenza leggermente superiore a quella necessaria per garantire una certa flessibilità e sicurezza.\n11. Il Case del Computer\n11.1 Cos’è il Case\nIl case (o cabinet) è l’involucro esterno che ospita e protegge tutti i componenti interni del computer, come la scheda madre, l’alimentatore, la CPU, la RAM, le unità di archiviazione e le periferiche di espansione. Oltre a fornire una struttura fisica per il montaggio dei componenti, il case ha anche il compito di gestire il flusso d’aria per il raffreddamento e di proteggere il sistema da polvere e danni fisici.\n11.2 Funzioni del Case\nLe principali funzioni del case sono:\n\n\nProtezione e Struttura:\n\nFornisce una struttura robusta per il montaggio e il supporto dei vari componenti interni.\nProtegge i componenti da polvere, urti e altri fattori ambientali che potrebbero danneggiarli.\n\n\n\nGestione del Raffreddamento:\n\nConsente l’installazione di ventole e sistemi di raffreddamento (ad aria o a liquido) per mantenere i componenti alla giusta temperatura durante il funzionamento.\nUna buona gestione del flusso d’aria all’interno del case è essenziale per prevenire il surriscaldamento dei componenti.\n\n\n\nOrganizzazione dei Componenti e dei Cavi:\n\nOffre slot e alloggiamenti per installare in modo ordinato la scheda madre, le unità di archiviazione, le schede di espansione e altre periferiche.\nDispone di canali e ganci per una corretta gestione dei cavi, migliorando il flusso d’aria e l’estetica interna.\n\n\n\nAccessibilità e Espansione:\n\nPermette un facile accesso ai componenti interni per eventuali aggiornamenti, sostituzioni o manutenzioni.\nOffre slot e alloggiamenti per l’aggiunta di ulteriori dispositivi di archiviazione, schede di espansione e periferiche.\n\n\n\n11.3 Tipologie di Case\n\n\nFull Tower:\n\nDimensioni: I più grandi, con un’altezza di circa 50-60 cm o più.\nUso: Ideali per build avanzate che richiedono molti slot di espansione, schede grafiche grandi, sistemi di raffreddamento a liquido e numerose unità di archiviazione.\nCaratteristiche: Ampio spazio per una gestione ordinata dei cavi e un flusso d’aria ottimale.\n\n\n\nMid Tower:\n\nDimensioni: Dimensioni standard, con un’altezza di circa 40-50 cm.\nUso: Adatti per la maggior parte dei computer desktop, con spazio sufficiente per configurazioni di gioco e lavoro.\nCaratteristiche: Buon compromesso tra spazio interno, gestione del raffreddamento e facilità d’uso.\n\n\n\nMini Tower:\n\nDimensioni: Più piccoli dei mid tower, con un’altezza di circa 35-40 cm.\nUso: Ideali per sistemi compatti con esigenze di espansione limitate, come PC da ufficio o HTPC (Home Theater PC).\nCaratteristiche: Minore spazio per componenti e gestione del raffreddamento, ma più compatti e facili da collocare.\n\n\n\nSmall Form Factor (SFF) e Mini-ITX:\n\nDimensioni: Molto compatti, progettati per schede madri mini-ITX.\nUso: Perfetti per build compatte, come PC da salotto, sistemi di intrattenimento domestico o build portatili.\nCaratteristiche: Limitate possibilità di espansione e raffreddamento, ma ottima portabilità e design compatto.\n\n\n\n11.4 Caratteristiche Importanti del Case\n\n\nCompatibilità con Schede Madri:\n\nI case supportano diverse dimensioni di schede madri, come ATX, micro-ATX, mini-ITX. La compatibilità dipende dalle dimensioni del case e dai fori di montaggio interni.\n\n\n\nGestione del Raffreddamento:\n\nSpazi per l’installazione di ventole (frontali, superiori, posteriori) e radiatori per il raffreddamento a liquido.\nFiltro antipolvere per mantenere l’interno del case pulito e prevenire l’accumulo di polvere sui componenti.\n\n\n\nSlot di Espansione:\n\nSlot per schede grafiche, schede audio e altre periferiche.\nBay per unità da 3,5” e 2,5” per dischi rigidi e SSD.\n\n\n\nGestione dei Cavi:\n\nCanali e ganci interni per il passaggio ordinato dei cavi.\nPannello posteriore per nascondere i cavi e mantenere un aspetto ordinato.\n\n\n\nPorte Frontali:\n\nPorte USB, jack audio e pulsanti di accensione posizionati sul pannello frontale o superiore per un facile accesso.\n\n\n\nDesign e Estetica:\n\nFinestra laterale in vetro temperato o acrilico per mostrare i componenti interni.\nIlluminazione RGB integrata per un aspetto estetico personalizzato.\n\n\n\n11.5 Importanza del Case nella Costruzione del PC\nLa scelta del case è fondamentale per la costruzione di un PC ben bilanciato. Un case adeguato consente di ospitare tutti i componenti in modo sicuro e ordinato, garantendo un buon flusso d’aria e riducendo i rischi di surriscaldamento. Inoltre, la gestione dei cavi e l’accessibilità interna facilitano l’installazione e la manutenzione del sistema."},"Argomenti/Utilizzo-di-base-del-PC-Windows/Possibili-argomenti":{"slug":"Argomenti/Utilizzo-di-base-del-PC-Windows/Possibili-argomenti","filePath":"Argomenti/Utilizzo di base del PC Windows/Possibili argomenti.md","title":"Possibili argomenti","links":[],"tags":[],"content":"Modulo 1: Introduzione all’Utilizzo del Computer\n1.1 Primo approccio a Windows\n\nPanoramica dei sistemi operativi (introduzione a Windows)\nAccensione e spegnimento del computer\nLa schermata di login e il desktop\nCome utilizzare mouse e tastiera (click, doppio click, tasto destro)\n\nModulo 2: Navigazione nell’Interfaccia di Windows\n2.1 Il Desktop di Windows\n\nIcone, barra delle applicazioni, e menu Start\nPersonalizzazione del desktop (sfondo, layout delle icone)\n\n2.2 Gestione delle Finestre\n\nApertura, chiusura, ridimensionamento, e gestione delle finestre multiple\nUtilizzo di funzioni come “Snap” per organizzare le finestre sullo schermo\n\n2.3 Il Menu Start e la Ricerca\n\nNavigare nel menu Start\nUtilizzare la funzione di ricerca per trovare programmi e file\n\nModulo 3: Gestione di File e Cartelle\n3.1 Esplora File: Nozioni di Base\n\nStruttura di file e cartelle\nNavigare tra le cartelle (unità disco, cartelle principali come Documenti, Immagini, Download)\n\n3.2 Operazioni di Base su File e Cartelle\n\nCreare, rinominare, copiare, spostare, e cancellare file e cartelle\nScorciatoie da tastiera per la gestione dei files\nCreazione di una struttura di cartelle organizzata per un progetto\n\n3.3 Gestione delle Risorse del Computer\n\nControllare lo spazio su disco\nUtilizzare periferiche esterne (chiavette USB, hard disk esterni)\n\nModulo 4: Configurazione di Windows\n4.1 Impostazioni di Sistema\n\nUtilizzo del Pannello di Controllo e delle Impostazioni di Windows\nModifica delle impostazioni di base (lingua, orario, sfondo, risoluzione dello schermo)\n\n4.2 Gestione degli Account Utente\n\nCreazione e gestione di account utente\nDifferenza tra account amministratore e account standard\nProtezione dell’account con password\n\n4.3 Installazione e Disinstallazione di Software\n\nProcedura di installazione di nuovi programmi\nDisinstallazione sicura di programmi non più necessari\nUtilizzo del Microsoft Store per applicazioni\n\nModulo 5: Sicurezza Informatica di Base\n5.1 Protezione del Computer\n\nIntroduzione agli antivirus e firewall\nCome fare una scansione antivirus\n\n5.2 Sicurezza Online\n\nCreazione di password sicure\nIdentificazione di e-mail di phishing e truffe online\nComportamenti sicuri durante la navigazione su Internet\n\n5.3 Backup e Ripristino\n\nImportanza del backup dei dati\nCome fare un backup manuale\nUtilizzo di strumenti di backup integrati in Windows\n\nModulo 6: Utilizzo di Software di Base\n6.1 Introduzione ai Programmi di Ufficio\n\nPanoramica su Microsoft Office (Word, Excel, PowerPoint)\nCreazione di un documento di testo, un foglio di calcolo e una presentazione di base\n\n6.2 Navigazione Web\n\nUtilizzo dei browser web (Microsoft Edge, Google Chrome)\nNozioni di base su come cercare informazioni online\nGestione dei segnalibri e della cronologia\n\n6.3 Utilizzo della Posta Elettronica\n\nCreazione e gestione di un account email\nInviare, ricevere e organizzare e-mail\nGestione degli allegati e delle impostazioni di sicurezza\n\nModulo 7: Risoluzione dei Problemi Comuni\n7.1 Identificazione e Risoluzione di Problemi di Base\n\nCosa fare quando un programma non risponde\nCome risolvere problemi di connessione internet\nRipristino del sistema a uno stato precedente\n\n7.2 Manutenzione del Sistema\n\nPulizia del disco e gestione dello spazio\nAggiornamenti di Windows: come e quando farli\nMonitoraggio delle prestazioni del computer\n\nModulo 8: Conclusione e Progetto Finale\n8.1 Revisione degli Argomenti\n\nRipasso dei concetti chiave\nQuiz finale per verificare le competenze acquisite\n\n8.2 Progetto Finale\n\nRealizzazione di un progetto che integri tutte le competenze apprese (es. creazione di un piccolo documento o presentazione che coinvolga ricerca online, gestione dei file, e utilizzo di software di base)\n\n8.3 Feedback e Certificazione\n\nRaccogliere feedback dagli studenti sul corso\nRilascio di un certificato di partecipazione al corso\n\nMateriali e Risorse Aggiuntive\n\nGuide Rapide: Documenti scaricabili con riassunti di ogni modulo\nVideo Tutorial: Link a video che mostrano le operazioni trattate nel corso\nEsercizi Extra: Esercizi opzionali per approfondire le competenze=\n"},"Argomenti/Utilizzo-di-base-del-PC-Windows/Utilizzo-di-base-del-PC-Windows":{"slug":"Argomenti/Utilizzo-di-base-del-PC-Windows/Utilizzo-di-base-del-PC-Windows","filePath":"Argomenti/Utilizzo di base del PC Windows/Utilizzo di base del PC Windows.md","title":"Utilizzo di base del PC Windows","links":[],"tags":[],"content":"Modulo 1: Introduzione all’Utilizzo del Computer\n1.1 Primo Approccio a Windows\nPanoramica dei Sistemi Operativi (Introduzione a Windows)\nIl sistema operativo è il software principale che gestisce le risorse hardware di un computer e fornisce servizi comuni per i programmi applicativi. Windows è uno dei sistemi operativi più diffusi al mondo, sviluppato da Microsoft, ed è noto per la sua interfaccia utente grafica (GUI) che permette agli utenti di interagire con il computer attraverso finestre, icone e menu.\nWindows è utilizzato su una vasta gamma di dispositivi, dai computer desktop ai laptop, fino ai tablet. La sua popolarità è dovuta alla facilità d’uso, alla vasta compatibilità con software e hardware e al supporto per una varietà di applicazioni.\nAccensione e Spegnimento del Computer\nAccendere e spegnere correttamente il computer è un’operazione fondamentale per garantire la sicurezza dei dati e il corretto funzionamento del sistema.\nAccensione:\nPer accendere il computer, premere il pulsante di accensione, solitamente situato sul case del computer o sulla tastiera di un laptop. Una volta avviato, il computer esegue una serie di controlli iniziali, denominati POST (Power-On Self Test), per verificare che l’hardware funzioni correttamente. Successivamente, verrà caricato il sistema operativo, e l’utente verrà portato alla schermata di login.\nSpegnimento:\nPer spegnere correttamente il computer, seguire questi passaggi:\n\nFare clic sul pulsante Start (l’icona di Windows nell’angolo inferiore sinistro del desktop).\nSelezionare Arresta il sistema o Spegni.\nAttendere che il computer completi il processo di spegnimento. È importante non spegnere il computer premendo il pulsante di accensione finché il sistema operativo non ha concluso tutte le operazioni di spegnimento, poiché ciò potrebbe causare la perdita di dati o danneggiare i file di sistema.\n\nLa Schermata di Login e il Desktop\nSchermata di Login:\nLa schermata di login è la prima schermata che appare dopo l’accensione del computer e il caricamento del sistema operativo. Qui l’utente deve inserire le proprie credenziali (nome utente e password) per accedere al proprio account. Windows supporta diversi tipi di account, tra cui account locali, account Microsoft e account di dominio (in ambienti aziendali).\nDesktop:\nDopo aver effettuato l’accesso, l’utente viene portato sul desktop di Windows, che è l’area di lavoro principale. Il desktop è composto da varie componenti, tra cui:\n\nIcone: Rappresentano file, cartelle o applicazioni che possono essere aperti con un doppio clic.\nBarra delle Applicazioni: Situata generalmente nella parte inferiore dello schermo, contiene il pulsante Start, icone delle applicazioni attive, l’orologio e altri strumenti.\nSfondo: L’immagine o il colore che riempie l’area del desktop.\n\nIl desktop funge da punto di partenza per tutte le operazioni dell’utente, permettendo un rapido accesso ai file, alle applicazioni e alle impostazioni di sistema.\nCome Utilizzare il Mouse\nMouse:\nIl mouse è un dispositivo di puntamento che consente di interagire con gli elementi sullo schermo. Le operazioni principali che si possono eseguire con il mouse includono:\n\nClick Sinistro: Seleziona un oggetto o apre un programma.\nDoppio Click: Apre rapidamente un file o una cartella.\nClick Destro: Apre un menu contestuale con opzioni aggiuntive relative all’elemento selezionato.\nScorrimento: Utilizzando la rotellina del mouse (se presente), è possibile scorrere il contenuto di una finestra verso l’alto o verso il basso.\n\nModulo 2: Navigazione nell’Interfaccia di Windows\n2.1 Il Desktop di Windows\nIcone, Barra delle Applicazioni e Menu Start\nIl desktop di Windows è l’area principale in cui l’utente interagisce con il sistema operativo. Comprendere la disposizione e la funzione degli elementi sul desktop è essenziale per navigare efficacemente nell’ambiente Windows.\n\n\nIcone: Le icone sul desktop rappresentano file, cartelle o applicazioni che possono essere avviate con un doppio clic. Le icone possono essere organizzate secondo le preferenze dell’utente, spostate, rinominate o eliminate. Alcune delle icone comuni includono il Cestino, le cartelle di sistema come Documenti e collegamenti a programmi.\n\n\nBarra delle Applicazioni: Si trova generalmente nella parte inferiore dello schermo. La barra delle applicazioni contiene il pulsante Start, le applicazioni attualmente in esecuzione, le applicazioni bloccate per l’accesso rapido, e l’area di notifica. L’area di notifica, situata a destra della barra delle applicazioni, include l’orologio e icone per accessi rapidi a funzioni come la connessione internet, il volume e gli aggiornamenti di sistema.\n\n\nMenu Start: Il pulsante Start si trova nell’angolo inferiore sinistro della barra delle applicazioni. Facendo clic su di esso, si apre il menu Start, che fornisce accesso rapido a programmi installati, impostazioni di sistema e documenti recenti. Il menu Start è diviso in due parti principali: una colonna sinistra con un elenco di programmi e funzionalità, e una colonna destra con riquadri dinamici (live tiles) che possono mostrare informazioni aggiornate come notizie o meteo.\n\n\nPersonalizzazione del Desktop (Sfondo, Layout delle Icone)\nLa personalizzazione del desktop consente agli utenti di adattare l’aspetto e l’organizzazione del proprio spazio di lavoro per una maggiore efficienza e comfort visivo.\n\n\nSfondo: Lo sfondo è l’immagine o il colore che riempie l’area del desktop. Per cambiarlo, fare clic con il tasto destro sul desktop e selezionare “Personalizza”. Nella sezione “Sfondo”, è possibile scegliere tra immagini predefinite, colori solidi o caricare un’immagine personalizzata dal proprio computer.\n\n\nLayout delle Icone: È possibile personalizzare il layout delle icone per migliorare l’organizzazione del desktop. Le icone possono essere ridimensionate, allineate automaticamente alla griglia o distribuite liberamente sul desktop. Per modificare il layout, fare clic con il tasto destro sul desktop, selezionare “Visualizza” e scegliere le opzioni desiderate come “Icone piccole”, “Allinea icone alla griglia” o “Disponi icone automaticamente”.\n\n\n2.2 Gestione delle Finestre\nApertura, Chiusura, Ridimensionamento e Gestione delle Finestre Multiple\nLa gestione delle finestre è una delle competenze fondamentali per l’uso efficace di Windows. Le finestre rappresentano le interfacce grafiche delle applicazioni e possono essere manipolate per migliorare la produttività.\n\n\nApertura di una Finestra: Le finestre vengono aperte facendo clic sull’icona di un programma o di un file. Le applicazioni possono essere avviate dal menu Start, dalla barra delle applicazioni o facendo doppio clic su un file.\n\n\nChiusura di una Finestra: Per chiudere una finestra, fare clic sul pulsante “X” nell’angolo superiore destro della finestra. In alternativa, è possibile utilizzare la scorciatoia da tastiera “Alt + F4” per chiudere rapidamente la finestra attiva.\n\n\nRidimensionamento di una Finestra: Le finestre possono essere ridimensionate trascinando i bordi o gli angoli. Passando il cursore sui bordi della finestra, il cursore cambierà forma, permettendo di trascinare per aumentare o diminuire le dimensioni della finestra.\n\n\nGestione delle Finestre Multiple: Quando si lavora con più finestre aperte, è possibile ridimensionarle e posizionarle per migliorare l’efficienza. Windows offre funzioni come “Affianca finestre” che consente di posizionare due finestre una accanto all’altra. È anche possibile alternare tra le finestre attive utilizzando “Alt + Tab”.\n\n\nUtilizzo di Funzioni come “Snap” per Organizzare le Finestre sullo Schermo\nLa funzione “Snap” in Windows permette di agganciare rapidamente una finestra a metà schermo o in un angolo, facilitando la gestione delle finestre multiple.\n\n\nSnap per Metà Schermo: Per agganciare una finestra a metà schermo, trascinare la finestra verso il bordo sinistro o destro dello schermo. La finestra si ridimensionerà automaticamente occupando metà dello schermo. È possibile fare lo stesso con un’altra finestra per occupare l’altra metà dello schermo.\n\n\nSnap per un Angolo dello Schermo: Trascinando una finestra verso uno degli angoli dello schermo, questa si ridimensionerà per occupare un quarto dello schermo, consentendo di lavorare con fino a quattro finestre contemporaneamente.\n\n\nSnap Assist: Dopo aver agganciato una finestra, Windows mostrerà automaticamente un elenco di altre finestre aperte, permettendo di selezionare una finestra per riempire lo spazio rimanente sullo schermo.\n\n\n2.3 Il Menu Start e la Ricerca\nNavigare nel Menu Start\nIl menu Start è il punto di accesso principale a tutte le applicazioni, impostazioni e funzionalità del sistema operativo Windows.\n\n\nAccesso al Menu Start: Fare clic sull’icona di Windows nell’angolo inferiore sinistro dello schermo per aprire il menu Start. Può anche essere aperto utilizzando il tasto Windows sulla tastiera.\n\n\nNavigazione: Il menu Start è diviso in sezioni che includono l’elenco di tutte le applicazioni, i collegamenti rapidi alle impostazioni e cartelle di sistema, e i riquadri dinamici personalizzabili. Le applicazioni possono essere cercate direttamente dall’elenco o avviate dai riquadri.\n\n\nPersonalizzazione: Gli utenti possono aggiungere o rimuovere applicazioni dalla sezione riquadri, organizzandole in gruppi o ridimensionandole a seconda delle preferenze.\n\n\nUtilizzare la Funzione di Ricerca per Trovare Programmi e File\nLa funzione di ricerca integrata in Windows è uno strumento potente per trovare rapidamente applicazioni, file, impostazioni e informazioni online.\n\n\nAccesso alla Ricerca: La barra di ricerca è disponibile direttamente nel menu Start o sulla barra delle applicazioni, accanto al pulsante Start. È sufficiente iniziare a digitare per attivare la ricerca.\n\n\nRicerca di Applicazioni e File: Digitando il nome di un’applicazione, file o cartella, Windows mostrerà una lista di risultati pertinenti. Gli utenti possono avviare direttamente i programmi o aprire i file selezionando i risultati dalla lista.\n\n\nRicerca Web: Se il termine cercato non si riferisce a un’applicazione o file locali, Windows utilizza il motore di ricerca Bing per mostrare risultati dal web direttamente nella finestra di ricerca.\n\n\nFiltri di Ricerca: Durante la ricerca, è possibile applicare filtri per restringere i risultati, come “Documenti”, “Immagini”, “Video”, o “Impostazioni”, migliorando l’efficienza nella localizzazione delle informazioni desiderate.\n\n"},"Argomenti/Web-application/Body-request":{"slug":"Argomenti/Web-application/Body-request","filePath":"Argomenti/Web application/Body request.md","title":"Body request","links":[],"tags":[],"content":"Il corpo di una richiesta HTTP contiene i dati che il client sta inviando al server. I dati possono essere di qualsiasi tipo, come testo, immagini, video o file binari. Il corpo della richiesta è separato dall’intestazione da una singola riga vuota.\nI metodi HTTP che richiedono un corpo sono:\n\nPOST\nPUT\nPATCH\nDELETE\n\nPer i metodi GET e HEAD, il corpo della richiesta è vuoto.\nIl corpo della richiesta può essere codificato in diversi formati, come:\n\nTesto semplice (UTF-8)\nBase64\nJSON\nXML\n\nIl formato del corpo della richiesta è specificato dall’intestazione di contenuto della richiesta.\nEcco alcuni esempi di corpo di una richiesta HTTP:\n\nUna richiesta POST per creare un nuovo utente potrebbe avere un corpo che contiene i dati dell’utente, come il nome, l’indirizzo e-mail e la password.\nUna richiesta PUT per aggiornare un documento potrebbe avere un corpo che contiene il testo aggiornato del documento.\nUna richiesta DELETE per eliminare un file potrebbe avere un corpo vuoto.\n\nIl corpo della richiesta è utilizzato per una varietà di scopi, tra cui:\n\nTrasmettere dati al server, come dati di utente, dati di prodotto o file.\nEseguire azioni sul server, come creare un nuovo record, aggiornare un record o eliminare un record.\nRicevere dati dal server, come dati di risposta, dati di errore o file.\n"},"Argomenti/Web-application/GET-e-POST":{"slug":"Argomenti/Web-application/GET-e-POST","filePath":"Argomenti/Web application/GET e POST.md","title":"GET e POST","links":[],"tags":[],"content":"GET e POST sono due metodi HTTP utilizzati per inviare dati da un client a un server. La principale differenza tra i due metodi è il modo in cui i dati vengono inviati. GET passa i dati nella query string dell’URL, mentre POST passa i dati nel corpo della richiesta.\nEcco una tabella che riassume le principali differenze tra GET e POST:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nParametroGETPOSTPosizione dei datiQuery string dell’URLCorpo della richiestaLunghezza massima dei datiLimitata dalla lunghezza dell’URLNon limitataVisibilità dei datiI dati sono visibili nell’URLI dati non sono visibili nell’URLUtilizzo tipicoVisualizzazione di informazioni, impostazione di filtriAggiornamento di dati, invio di file\nIn generale, GET viene utilizzato per le richieste che non richiedono l’invio di dati sensibili o riservati. Ad esempio, GET può essere utilizzato per visualizzare una pagina web, impostare dei filtri o cercare informazioni. POST viene utilizzato per le richieste che richiedono l’invio di dati sensibili o riservati. Ad esempio, POST può essere utilizzato per eseguire un acquisto, inviare un modulo o caricare un file.\nEcco alcuni esempi specifici di utilizzo di GET e POST:\n\nGET:\n\nwww.example.com/\nwww.example.com/search\nwww.example.com/cart\n\n\nPOST:\n\nwww.example.com/login\nwww.example.com/signup\nwww.example.com/upload\n\n\n\nÈ importante notare che l’utilizzo di GET o POST è una decisione che deve essere presa in base alle specifiche esigenze dell’applicazione. Non esiste una regola generale che valga per tutte le situazioni."},"Argomenti/Web-application/Link-utili":{"slug":"Argomenti/Web-application/Link-utili","filePath":"Argomenti/Web application/Link utili.md","title":"Link utili","links":[],"tags":[],"content":"Bootstrap\n"},"Argomenti/Web-application/React":{"slug":"Argomenti/Web-application/React","filePath":"Argomenti/Web application/React.md","title":"React","links":[],"tags":[],"content":"www.youtube.com/watch\n📘 Corso Completo di React con TypeScript\nIntroduzione al Corso\nIn questo corso imparerai tutto ciò che serve per costruire applicazioni moderne con React, da zero fino ad argomenti avanzati, tra cui:\n\nRouting\nState Management\nReact Query\nOttimizzazione delle performance\nAutenticazione\nError Handling\nL’applicazione che costruiremo è completa, moderna e in produzione, con funzionalità come:\nModalità chiara/scura\nRicerca e filtri (genere, piattaforma)\nAggiornamento dinamico del titolo della pagina\nSkeleton Loader per i dati in caricamento\n\n\n✅ Requisiti per il Corso\nNon è necessario conoscere React, ma è richiesto:\n\nBuona conoscenza di HTML, CSS e JavaScript\nIn questo corso useremo TypeScript\n\nPerché TypeScript?\n\nPermette di trovare errori prima dell’esecuzione\nMigliora l’autocompletamento\nAiuta a mantenere il codice scalabile e manutenibile\n\n\n🔧 Setup Ambiente di Sviluppo\n1. Installazione di Node.js\n\nRichiesta: Node.js v16 o superiore\nComando per verificare versione:\n\nnode -v\n\nSe necessario, scarica da: nodejs.org\n\n2. Editor consigliato: Visual Studio Code\n\nEstensione consigliata: Prettier – Code formatter\n\n\nCerca e installa da Extensions\nAttiva “Format on Save” dalle impostazioni\n\n\n🚀 Creazione del Progetto con Vite\nUsiamo Vite invece di Create React App per prestazioni superiori.\nnpm create vite@4.1.0\n\nDurante la creazione:\n\n\nNome progetto: react-app\nFramework: React\nLinguaggio: TypeScript\nPoi:\n\ncd react-app\nnpm install\ncode .\nnpm run dev\nApri il browser su http://localhost:5173\n📁 Struttura del Progetto\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFile/CartellaDescrizionenode_modules/Librerie installate (non modificare)public/File pubblici (immagini, video)src/Codice sorgente dell’applicazioneindex.htmlTemplate HTML principale, contiene &lt;div id=&quot;root&quot;&gt;main.tsxEntry point dell’appApp.tsxComponente principale (root)package.jsonInformazioni sul progetto e dipendenzevite.config.tsConfigurazione di Vite (solitamente non da toccare)tsconfig.jsonConfigurazione TypeScript\n\n🧱 Primo Componente React: Message.tsx\nfunction Message() {\n  return &lt;h1&gt;Hello World&lt;/h1&gt;;\n}\nexport default Message;\n\nIl file ha estensione .tsx perché contiene JSX\nJSX è una sintassi simile all’HTML ma scritta dentro JavaScript\nJSX viene compilato in chiamate come React.createElement(...)\n\n\n🧩 Utilizzo del componente in App.tsx\nimport Message from &quot;./Message&quot;;\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;Message /&gt;\n    &lt;/div&gt;\n  );\n}\nexport default App;\n\n⚠️ Ogni componente React deve avere una lettera maiuscola all’inizio (PascalCase)\n\n\n📋 ListGroup Component con Bootstrap\nInstallazione di Bootstrap\nPer uno stile moderno e professionale, installiamo Bootstrap:\nnpm install bootstrap\nPulizia dei file CSS\nNel progetto generato da Vite, rimuoviamo gli stili generati automaticamente:\n\nsrc/app.css → elimina tutto il contenuto\nsrc/index.css → elimina l’intero file\nPoi modifichiamo main.tsx per importare Bootstrap:\n\nimport &quot;bootstrap/dist/css/bootstrap.css&quot;;\n\n🧱 Sezione: Creazione del componente ListGroup\n📁 Struttura del progetto\nAll’interno della cartella src, creiamo una nuova sottocartella chiamata components:\nsrc/\n├── components/\n│   └── ListGroup.tsx\n\n\n🔨 Codice iniziale di ListGroup.tsx\nfunction ListGroup() {\n  return &lt;h1&gt;ListGroup&lt;/h1&gt;;\n}\nexport default ListGroup;\n\n✅ Uso in App.tsx\nimport ListGroup from &quot;./components/ListGroup&quot;;\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;ListGroup /&gt;\n    &lt;/div&gt;\n  );\n}\nexport default App;\n\n🎨 Aggiunta del markup Bootstrap\nCopiamo da Bootstrap &gt; List group:\nfunction ListGroup() {\n  return (\n    &lt;ul className=&quot;list-group&quot;&gt;\n      &lt;li className=&quot;list-group-item&quot;&gt;New York&lt;/li&gt;\n      &lt;li className=&quot;list-group-item&quot;&gt;San Francisco&lt;/li&gt;\n      &lt;li className=&quot;list-group-item&quot;&gt;Tokyo&lt;/li&gt;\n      &lt;li className=&quot;list-group-item&quot;&gt;London&lt;/li&gt;\n      &lt;li className=&quot;list-group-item&quot;&gt;Paris&lt;/li&gt;\n    &lt;/ul&gt;\n  );\n}\n\n⚠️ In JSX si usa className al posto di class.\n\n\n🔁 Lista dinamica con .map()\nconst items = [&quot;New York&quot;, &quot;San Francisco&quot;, &quot;Tokyo&quot;, &quot;London&quot;, &quot;Paris&quot;];\nreturn (\n  &lt;ul className=&quot;list-group&quot;&gt;\n    {items.map((item) =&gt; (\n      &lt;li className=&quot;list-group-item&quot;&gt;{item}&lt;/li&gt;\n    ))}\n  &lt;/ul&gt;\n);\n\n❗ Ma React chiederà una key unica per ogni elemento.\n\nCorretto con key:\n{items.map((item) =&gt; (\n  &lt;li key={item} className=&quot;list-group-item&quot;&gt;{item}&lt;/li&gt;\n))}\n\n⚠️ Condizione: Lista vuota\nif (items.length === 0)\n  return &lt;p&gt;No item found&lt;/p&gt;;\nreturn (\n  &lt;&gt;\n    &lt;h1&gt;List&lt;/h1&gt;\n    &lt;ul className=&quot;list-group&quot;&gt;\n      {items.map((item) =&gt; (\n        &lt;li key={item} className=&quot;list-group-item&quot;&gt;{item}&lt;/li&gt;\n      ))}\n    &lt;/ul&gt;\n  &lt;/&gt;\n);\n\n🔀 Fragments: evitare div inutili\nReact non permette più di un elemento al return root. Le opzioni sono:\n❌ Usare &lt;div&gt;\nreturn (\n  &lt;div&gt;\n    &lt;h1&gt;List&lt;/h1&gt;\n    &lt;ul className=&quot;list-group&quot;&gt;...&lt;/ul&gt;\n  &lt;/div&gt;\n);\n✅ Usare &lt;React.Fragment&gt;\nimport { Fragment } from &quot;react&quot;;\nreturn (\n  &lt;Fragment&gt;\n    &lt;h1&gt;List&lt;/h1&gt;\n    &lt;ul className=&quot;list-group&quot;&gt;...&lt;/ul&gt;\n  &lt;/Fragment&gt;\n);\n✅✅ Sintassi breve consigliata: &lt;&gt;...&lt;/&gt;\nreturn (\n  &lt;&gt;\n    &lt;h1&gt;List&lt;/h1&gt;\n    &lt;ul className=&quot;list-group&quot;&gt;...&lt;/ul&gt;\n  &lt;/&gt;\n);\n\n🧠 Condizioni inline e pulizia JSX\nCon &amp;&amp;:\n{items.length === 0 &amp;&amp; &lt;p&gt;No item found&lt;/p&gt;}\nCon ternario:\n{items.length === 0 ? &lt;p&gt;No item found&lt;/p&gt; : null}\n\n🖱️ Gestione click + useState\nimport { useState } from &quot;react&quot;;\nfunction ListGroup() {\n  const items = [&quot;New York&quot;, &quot;San Francisco&quot;, &quot;Tokyo&quot;, &quot;London&quot;, &quot;Paris&quot;];\n  const [selectedIndex, setSelectedIndex] = useState(-1);\n  return (\n    &lt;&gt;\n      &lt;h1&gt;List&lt;/h1&gt;\n      {items.length === 0 &amp;&amp; &lt;p&gt;No item found&lt;/p&gt;}\n      &lt;ul className=&quot;list-group&quot;&gt;\n        {items.map((item, index) =&gt; (\n          &lt;li\n            key={item}\n            className={\n              selectedIndex === index\n                ? &quot;list-group-item active&quot;\n                : &quot;list-group-item&quot;\n            }\n            onClick={() =&gt; setSelectedIndex(index)}\n          &gt;\n            {item}\n          &lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/&gt;\n  );\n}\n\n🔌 Componenti riutilizzabili con Props\nDefinizione Props\ninterface Props {\n  items: string[];\n  heading: string;\n  onSelectItem: (item: string) =&gt; void;\n}\nUso delle Props\nfunction ListGroup({ items, heading, onSelectItem }: Props) {\n  const [selectedIndex, setSelectedIndex] = useState(-1);\n  return (\n    &lt;&gt;\n      &lt;h1&gt;{heading}&lt;/h1&gt;\n      {items.length === 0 &amp;&amp; &lt;p&gt;No item found&lt;/p&gt;}\n      &lt;ul className=&quot;list-group&quot;&gt;\n        {items.map((item, index) =&gt; (\n          &lt;li\n            key={item}\n            className={\n              selectedIndex === index\n                ? &quot;list-group-item active&quot;\n                : &quot;list-group-item&quot;\n            }\n            onClick={() =&gt; {\n              setSelectedIndex(index);\n              onSelectItem(item);\n            }}\n          &gt;\n            {item}\n          &lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/&gt;\n  );\n}\n\n🧪 Uso in App.tsx\nimport ListGroup from &quot;./components/ListGroup&quot;;\nfunction App() {\n  const items = [&quot;New York&quot;, &quot;San Francisco&quot;, &quot;Tokyo&quot;, &quot;London&quot;, &quot;Paris&quot;];\n  const handleSelectItem = (item: string) =&gt; {\n    console.log(&quot;Selected:&quot;, item);\n  };\n  return (\n    &lt;div&gt;\n      &lt;ListGroup\n        items={items}\n        heading=&quot;Cities&quot;\n        onSelectItem={handleSelectItem}\n      /&gt;\n    &lt;/div&gt;\n  );\n}\nexport default App;\n\n🚨 Sezione: Creazione del componente Alert\n🎯 Obiettivo\nCostruire un componente Alert riutilizzabile con:\n\nSupporto al contenuto dinamico via children\nPulsante per chiusura (×)\nComunicazione dell’evento al componente genitore\n\n\n📁 Struttura del file\nPercorso:\nsrc/\n├── components/\n│   └── Alert.tsx\n\n\n🧱 Creazione base di Alert.tsx\ninterface Props {\n  children: React.ReactNode;\n  onClose: () =&gt; void;\n}\nfunction Alert({ children, onClose }: Props) {\n  return (\n    &lt;div className=&quot;alert alert-primary alert-dismissible&quot;&gt;\n      {children}\n      &lt;button\n        type=&quot;button&quot;\n        className=&quot;btn-close&quot;\n        onClick={onClose}\n        aria-label=&quot;Close&quot;\n      &gt;&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\nexport default Alert;\n🔍 Spiegazione\n\nalert alert-primary → classi Bootstrap per lo stile\nalert-dismissible → abilita la chiusura\nbtn-close → stile del pulsante “×”\nchildren → contenuto dinamico HTML/JSX\nonClose → funzione chiamata alla chiusura\n\n\n🧪 Uso base in App.tsx\nimport Alert from &quot;./components/Alert&quot;;\nfunction App() {\n  return (\n    &lt;div&gt;\n      &lt;Alert onClose={() =&gt; console.log(&quot;Alert closed&quot;)}&gt;\n        Hello &lt;span&gt;world&lt;/span&gt;\n      &lt;/Alert&gt;\n    &lt;/div&gt;\n  );\n}\n\n⚙️ Gestione visibilità tramite useState\nimport { useState } from &quot;react&quot;;\nimport Alert from &quot;./components/Alert&quot;;\nfunction App() {\n  const [alertVisible, setAlertVisibility] = useState(false);\n  return (\n    &lt;div&gt;\n      {alertVisible &amp;&amp; (\n        &lt;Alert onClose={() =&gt; setAlertVisibility(false)}&gt;\n          My alert message\n        &lt;/Alert&gt;\n      )}\n      &lt;button\n        className=&quot;btn btn-primary&quot;\n        onClick={() =&gt; setAlertVisibility(true)}\n      &gt;\n        Show Alert\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n🔍 Spiegazione\n\nalertVisible controlla se mostrare o meno il componente\nIl bottone imposta alertVisible = true\nIl componente Alert notifica la chiusura tramite onClose\nQuesto imposta alertVisible = false ⇒ alert scompare\n\n\n🧠 Tipi avanzati con TypeScript\ninterface Props {\n  children: React.ReactNode;   // accetta qualsiasi contenuto JSX\n  onClose: () =&gt; void;         // funzione senza parametri, ritorna void\n}\n\nQuesto rende il componente versatile e fortemente tipizzato.\n\n\n📌 Vantaggi di children\n✅ Puoi scrivere contenuto direttamente nel JSX:\n&lt;Alert onClose={...}&gt;Simple string&lt;/Alert&gt;\n✅ O contenuto HTML/JSX più complesso:\n&lt;Alert onClose={...}&gt;\n  This is &lt;strong&gt;important&lt;/strong&gt;!\n&lt;/Alert&gt;\n\n🔁 Riepilogo logica\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAspettoImplementazioneVisualizzazioneuseState in App.tsxChiusuraonClose passato da App.tsxContenuto dinamicochildrenStileClassi BootstrapAccessibilitàaria-label=&quot;Close&quot;\n"}}